/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}
impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ptr(&self) -> *const T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut_ptr(&mut self) -> *mut T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
impl<T> ::std::clone::Clone for __IncompleteArrayField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __IncompleteArrayField<T> {}
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const __SAL_H_FULL_VER: u32 = 140050727;
pub const __SPECSTRINGS_STRICT_LEVEL: u32 = 1;
pub const __drv_typeConst: u32 = 0;
pub const __drv_typeCond: u32 = 1;
pub const __drv_typeBitset: u32 = 2;
pub const __drv_typeExpr: u32 = 3;
pub const WINAPI_FAMILY_PC_APP: u32 = 2;
pub const WINAPI_FAMILY_PHONE_APP: u32 = 3;
pub const WINAPI_FAMILY_SYSTEM: u32 = 4;
pub const WINAPI_FAMILY_SERVER: u32 = 5;
pub const WINAPI_FAMILY_DESKTOP_APP: u32 = 100;
pub const WINAPI_FAMILY_APP: u32 = 2;
pub const WINAPI_FAMILY: u32 = 100;
pub const STRICT: u32 = 1;
pub const MAX_PATH: u32 = 260;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _UPPER: u32 = 1;
pub const _LOWER: u32 = 2;
pub const _DIGIT: u32 = 4;
pub const _SPACE: u32 = 8;
pub const _PUNCT: u32 = 16;
pub const _CONTROL: u32 = 32;
pub const _BLANK: u32 = 64;
pub const _HEX: u32 = 128;
pub const _LEADBYTE: u32 = 32768;
pub const _ALPHA: u32 = 259;
pub const ANYSIZE_ARRAY: u32 = 1;
pub const DISPATCH_LEVEL: u32 = 2;
pub const APC_LEVEL: u32 = 1;
pub const PASSIVE_LEVEL: u32 = 0;
pub const HIGH_LEVEL: u32 = 15;
pub const MEMORY_ALLOCATION_ALIGNMENT: u32 = 16;
pub const SYSTEM_CACHE_ALIGNMENT_SIZE: u32 = 64;
pub const PRAGMA_DEPRECATED_DDK: u32 = 0;
pub const ALL_PROCESSOR_GROUPS: u32 = 65535;
pub const MAXIMUM_PROC_PER_GROUP: u32 = 64;
pub const MAXIMUM_PROCESSORS: u32 = 64;
pub const APPLICATION_ERROR_MASK: u32 = 536870912;
pub const ERROR_SEVERITY_SUCCESS: u32 = 0;
pub const ERROR_SEVERITY_INFORMATIONAL: u32 = 1073741824;
pub const ERROR_SEVERITY_WARNING: u32 = 2147483648;
pub const ERROR_SEVERITY_ERROR: u32 = 3221225472;
pub const MAXLONGLONG: u64 = 9223372036854775807;
pub const UNICODE_STRING_MAX_CHARS: u32 = 32767;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINCHAR: u32 = 128;
pub const MAXCHAR: u32 = 127;
pub const MINSHORT: u32 = 32768;
pub const MAXSHORT: u32 = 32767;
pub const MINLONG: u32 = 2147483648;
pub const MAXLONG: u32 = 2147483647;
pub const MAXBYTE: u32 = 255;
pub const MAXWORD: u32 = 65535;
pub const MAXDWORD: u32 = 4294967295;
pub const EXCEPTION_EXECUTE_HANDLER: u32 = 1;
pub const EXCEPTION_CONTINUE_SEARCH: u32 = 0;
pub const EXCEPTION_CONTINUE_EXECUTION: i32 = -1;
pub const VER_SERVER_NT: u32 = 2147483648;
pub const VER_WORKSTATION_NT: u32 = 1073741824;
pub const VER_SUITE_SMALLBUSINESS: u32 = 1;
pub const VER_SUITE_ENTERPRISE: u32 = 2;
pub const VER_SUITE_BACKOFFICE: u32 = 4;
pub const VER_SUITE_COMMUNICATIONS: u32 = 8;
pub const VER_SUITE_TERMINAL: u32 = 16;
pub const VER_SUITE_SMALLBUSINESS_RESTRICTED: u32 = 32;
pub const VER_SUITE_EMBEDDEDNT: u32 = 64;
pub const VER_SUITE_DATACENTER: u32 = 128;
pub const VER_SUITE_SINGLEUSERTS: u32 = 256;
pub const VER_SUITE_PERSONAL: u32 = 512;
pub const VER_SUITE_BLADE: u32 = 1024;
pub const VER_SUITE_EMBEDDED_RESTRICTED: u32 = 2048;
pub const VER_SUITE_SECURITY_APPLIANCE: u32 = 4096;
pub const VER_SUITE_STORAGE_SERVER: u32 = 8192;
pub const VER_SUITE_COMPUTE_SERVER: u32 = 16384;
pub const VER_SUITE_WH_SERVER: u32 = 32768;
pub const VER_SUITE_MULTIUSERTS: u32 = 131072;
pub const PRODUCT_UNDEFINED: u32 = 0;
pub const PRODUCT_ULTIMATE: u32 = 1;
pub const PRODUCT_HOME_BASIC: u32 = 2;
pub const PRODUCT_HOME_PREMIUM: u32 = 3;
pub const PRODUCT_ENTERPRISE: u32 = 4;
pub const PRODUCT_HOME_BASIC_N: u32 = 5;
pub const PRODUCT_BUSINESS: u32 = 6;
pub const PRODUCT_STANDARD_SERVER: u32 = 7;
pub const PRODUCT_DATACENTER_SERVER: u32 = 8;
pub const PRODUCT_SMALLBUSINESS_SERVER: u32 = 9;
pub const PRODUCT_ENTERPRISE_SERVER: u32 = 10;
pub const PRODUCT_STARTER: u32 = 11;
pub const PRODUCT_DATACENTER_SERVER_CORE: u32 = 12;
pub const PRODUCT_STANDARD_SERVER_CORE: u32 = 13;
pub const PRODUCT_ENTERPRISE_SERVER_CORE: u32 = 14;
pub const PRODUCT_ENTERPRISE_SERVER_IA64: u32 = 15;
pub const PRODUCT_BUSINESS_N: u32 = 16;
pub const PRODUCT_WEB_SERVER: u32 = 17;
pub const PRODUCT_CLUSTER_SERVER: u32 = 18;
pub const PRODUCT_HOME_SERVER: u32 = 19;
pub const PRODUCT_STORAGE_EXPRESS_SERVER: u32 = 20;
pub const PRODUCT_STORAGE_STANDARD_SERVER: u32 = 21;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER: u32 = 22;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER: u32 = 23;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS: u32 = 24;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM: u32 = 25;
pub const PRODUCT_HOME_PREMIUM_N: u32 = 26;
pub const PRODUCT_ENTERPRISE_N: u32 = 27;
pub const PRODUCT_ULTIMATE_N: u32 = 28;
pub const PRODUCT_WEB_SERVER_CORE: u32 = 29;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT: u32 = 30;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY: u32 = 31;
pub const PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING: u32 = 32;
pub const PRODUCT_SERVER_FOUNDATION: u32 = 33;
pub const PRODUCT_HOME_PREMIUM_SERVER: u32 = 34;
pub const PRODUCT_SERVER_FOR_SMALLBUSINESS_V: u32 = 35;
pub const PRODUCT_STANDARD_SERVER_V: u32 = 36;
pub const PRODUCT_DATACENTER_SERVER_V: u32 = 37;
pub const PRODUCT_ENTERPRISE_SERVER_V: u32 = 38;
pub const PRODUCT_DATACENTER_SERVER_CORE_V: u32 = 39;
pub const PRODUCT_STANDARD_SERVER_CORE_V: u32 = 40;
pub const PRODUCT_ENTERPRISE_SERVER_CORE_V: u32 = 41;
pub const PRODUCT_HYPERV: u32 = 42;
pub const PRODUCT_STORAGE_EXPRESS_SERVER_CORE: u32 = 43;
pub const PRODUCT_STORAGE_STANDARD_SERVER_CORE: u32 = 44;
pub const PRODUCT_STORAGE_WORKGROUP_SERVER_CORE: u32 = 45;
pub const PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE: u32 = 46;
pub const PRODUCT_STARTER_N: u32 = 47;
pub const PRODUCT_PROFESSIONAL: u32 = 48;
pub const PRODUCT_PROFESSIONAL_N: u32 = 49;
pub const PRODUCT_SB_SOLUTION_SERVER: u32 = 50;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS: u32 = 51;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS: u32 = 52;
pub const PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE: u32 = 53;
pub const PRODUCT_SB_SOLUTION_SERVER_EM: u32 = 54;
pub const PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM: u32 = 55;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER: u32 = 56;
pub const PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE: u32 = 57;
pub const PRODUCT_PROFESSIONAL_EMBEDDED: u32 = 58;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT: u32 = 59;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL: u32 = 60;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC: u32 = 61;
pub const PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC: u32 = 62;
pub const PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE: u32 = 63;
pub const PRODUCT_CLUSTER_SERVER_V: u32 = 64;
pub const PRODUCT_EMBEDDED: u32 = 65;
pub const PRODUCT_STARTER_E: u32 = 66;
pub const PRODUCT_HOME_BASIC_E: u32 = 67;
pub const PRODUCT_HOME_PREMIUM_E: u32 = 68;
pub const PRODUCT_PROFESSIONAL_E: u32 = 69;
pub const PRODUCT_ENTERPRISE_E: u32 = 70;
pub const PRODUCT_ULTIMATE_E: u32 = 71;
pub const PRODUCT_ENTERPRISE_EVALUATION: u32 = 72;
pub const PRODUCT_MULTIPOINT_STANDARD_SERVER: u32 = 76;
pub const PRODUCT_MULTIPOINT_PREMIUM_SERVER: u32 = 77;
pub const PRODUCT_STANDARD_EVALUATION_SERVER: u32 = 79;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER: u32 = 80;
pub const PRODUCT_ENTERPRISE_N_EVALUATION: u32 = 84;
pub const PRODUCT_EMBEDDED_AUTOMOTIVE: u32 = 85;
pub const PRODUCT_EMBEDDED_INDUSTRY_A: u32 = 86;
pub const PRODUCT_THINPC: u32 = 87;
pub const PRODUCT_EMBEDDED_A: u32 = 88;
pub const PRODUCT_EMBEDDED_INDUSTRY: u32 = 89;
pub const PRODUCT_EMBEDDED_E: u32 = 90;
pub const PRODUCT_EMBEDDED_INDUSTRY_E: u32 = 91;
pub const PRODUCT_EMBEDDED_INDUSTRY_A_E: u32 = 92;
pub const PRODUCT_STORAGE_WORKGROUP_EVALUATION_SERVER: u32 = 95;
pub const PRODUCT_STORAGE_STANDARD_EVALUATION_SERVER: u32 = 96;
pub const PRODUCT_CORE_ARM: u32 = 97;
pub const PRODUCT_CORE_N: u32 = 98;
pub const PRODUCT_CORE_COUNTRYSPECIFIC: u32 = 99;
pub const PRODUCT_CORE_SINGLELANGUAGE: u32 = 100;
pub const PRODUCT_CORE: u32 = 101;
pub const PRODUCT_PROFESSIONAL_WMC: u32 = 103;
pub const PRODUCT_EMBEDDED_INDUSTRY_EVAL: u32 = 105;
pub const PRODUCT_EMBEDDED_INDUSTRY_E_EVAL: u32 = 106;
pub const PRODUCT_EMBEDDED_EVAL: u32 = 107;
pub const PRODUCT_EMBEDDED_E_EVAL: u32 = 108;
pub const PRODUCT_NANO_SERVER: u32 = 109;
pub const PRODUCT_CLOUD_STORAGE_SERVER: u32 = 110;
pub const PRODUCT_CORE_CONNECTED: u32 = 111;
pub const PRODUCT_PROFESSIONAL_STUDENT: u32 = 112;
pub const PRODUCT_CORE_CONNECTED_N: u32 = 113;
pub const PRODUCT_PROFESSIONAL_STUDENT_N: u32 = 114;
pub const PRODUCT_CORE_CONNECTED_SINGLELANGUAGE: u32 = 115;
pub const PRODUCT_CORE_CONNECTED_COUNTRYSPECIFIC: u32 = 116;
pub const PRODUCT_CONNECTED_CAR: u32 = 117;
pub const PRODUCT_INDUSTRY_HANDHELD: u32 = 118;
pub const PRODUCT_PPI_PRO: u32 = 119;
pub const PRODUCT_ARM64_SERVER: u32 = 120;
pub const PRODUCT_EDUCATION: u32 = 121;
pub const PRODUCT_EDUCATION_N: u32 = 122;
pub const PRODUCT_IOTUAP: u32 = 123;
pub const PRODUCT_CLOUD_HOST_INFRASTRUCTURE_SERVER: u32 = 124;
pub const PRODUCT_ENTERPRISE_S: u32 = 125;
pub const PRODUCT_ENTERPRISE_S_N: u32 = 126;
pub const PRODUCT_PROFESSIONAL_S: u32 = 127;
pub const PRODUCT_PROFESSIONAL_S_N: u32 = 128;
pub const PRODUCT_ENTERPRISE_S_EVALUATION: u32 = 129;
pub const PRODUCT_ENTERPRISE_S_N_EVALUATION: u32 = 130;
pub const PRODUCT_HOLOGRAPHIC: u32 = 135;
pub const PRODUCT_PRO_SINGLE_LANGUAGE: u32 = 138;
pub const PRODUCT_PRO_CHINA: u32 = 139;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION: u32 = 140;
pub const PRODUCT_ENTERPRISE_SUBSCRIPTION_N: u32 = 141;
pub const PRODUCT_DATACENTER_NANO_SERVER: u32 = 143;
pub const PRODUCT_STANDARD_NANO_SERVER: u32 = 144;
pub const PRODUCT_DATACENTER_A_SERVER_CORE: u32 = 145;
pub const PRODUCT_STANDARD_A_SERVER_CORE: u32 = 146;
pub const PRODUCT_DATACENTER_WS_SERVER_CORE: u32 = 147;
pub const PRODUCT_STANDARD_WS_SERVER_CORE: u32 = 148;
pub const PRODUCT_UTILITY_VM: u32 = 149;
pub const PRODUCT_DATACENTER_EVALUATION_SERVER_CORE: u32 = 159;
pub const PRODUCT_STANDARD_EVALUATION_SERVER_CORE: u32 = 160;
pub const PRODUCT_PRO_WORKSTATION: u32 = 161;
pub const PRODUCT_PRO_WORKSTATION_N: u32 = 162;
pub const PRODUCT_PRO_FOR_EDUCATION: u32 = 164;
pub const PRODUCT_PRO_FOR_EDUCATION_N: u32 = 165;
pub const PRODUCT_AZURE_SERVER_CORE: u32 = 168;
pub const PRODUCT_AZURE_NANO_SERVER: u32 = 169;
pub const PRODUCT_ENTERPRISEG: u32 = 171;
pub const PRODUCT_ENTERPRISEGN: u32 = 172;
pub const PRODUCT_SERVERRDSH: u32 = 175;
pub const PRODUCT_CLOUD: u32 = 178;
pub const PRODUCT_CLOUDN: u32 = 179;
pub const PRODUCT_HUBOS: u32 = 180;
pub const PRODUCT_ONECOREUPDATEOS: u32 = 182;
pub const PRODUCT_CLOUDE: u32 = 183;
pub const PRODUCT_ANDROMEDA: u32 = 184;
pub const PRODUCT_IOTOS: u32 = 185;
pub const PRODUCT_CLOUDEN: u32 = 186;
pub const PRODUCT_UNLICENSED: u32 = 2882382797;
pub const _WIN32_WINNT_NT4: u32 = 1024;
pub const _WIN32_WINNT_WIN2K: u32 = 1280;
pub const _WIN32_WINNT_WINXP: u32 = 1281;
pub const _WIN32_WINNT_WS03: u32 = 1282;
pub const _WIN32_WINNT_WIN6: u32 = 1536;
pub const _WIN32_WINNT_VISTA: u32 = 1536;
pub const _WIN32_WINNT_WS08: u32 = 1536;
pub const _WIN32_WINNT_LONGHORN: u32 = 1536;
pub const _WIN32_WINNT_WIN7: u32 = 1537;
pub const _WIN32_WINNT_WIN8: u32 = 1538;
pub const _WIN32_WINNT_WINBLUE: u32 = 1539;
pub const _WIN32_WINNT_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_WINNT_WIN10: u32 = 2560;
pub const _WIN32_IE_IE20: u32 = 512;
pub const _WIN32_IE_IE30: u32 = 768;
pub const _WIN32_IE_IE302: u32 = 770;
pub const _WIN32_IE_IE40: u32 = 1024;
pub const _WIN32_IE_IE401: u32 = 1025;
pub const _WIN32_IE_IE50: u32 = 1280;
pub const _WIN32_IE_IE501: u32 = 1281;
pub const _WIN32_IE_IE55: u32 = 1360;
pub const _WIN32_IE_IE60: u32 = 1536;
pub const _WIN32_IE_IE60SP1: u32 = 1537;
pub const _WIN32_IE_IE60SP2: u32 = 1539;
pub const _WIN32_IE_IE70: u32 = 1792;
pub const _WIN32_IE_IE80: u32 = 2048;
pub const _WIN32_IE_IE90: u32 = 2304;
pub const _WIN32_IE_IE100: u32 = 2560;
pub const _WIN32_IE_IE110: u32 = 2560;
pub const _WIN32_IE_NT4: u32 = 512;
pub const _WIN32_IE_NT4SP1: u32 = 512;
pub const _WIN32_IE_NT4SP2: u32 = 512;
pub const _WIN32_IE_NT4SP3: u32 = 770;
pub const _WIN32_IE_NT4SP4: u32 = 1025;
pub const _WIN32_IE_NT4SP5: u32 = 1025;
pub const _WIN32_IE_NT4SP6: u32 = 1280;
pub const _WIN32_IE_WIN98: u32 = 1025;
pub const _WIN32_IE_WIN98SE: u32 = 1280;
pub const _WIN32_IE_WINME: u32 = 1360;
pub const _WIN32_IE_WIN2K: u32 = 1281;
pub const _WIN32_IE_WIN2KSP1: u32 = 1281;
pub const _WIN32_IE_WIN2KSP2: u32 = 1281;
pub const _WIN32_IE_WIN2KSP3: u32 = 1281;
pub const _WIN32_IE_WIN2KSP4: u32 = 1281;
pub const _WIN32_IE_XP: u32 = 1536;
pub const _WIN32_IE_XPSP1: u32 = 1537;
pub const _WIN32_IE_XPSP2: u32 = 1539;
pub const _WIN32_IE_WS03: u32 = 1538;
pub const _WIN32_IE_WS03SP1: u32 = 1539;
pub const _WIN32_IE_WIN6: u32 = 1792;
pub const _WIN32_IE_LONGHORN: u32 = 1792;
pub const _WIN32_IE_WIN7: u32 = 2048;
pub const _WIN32_IE_WIN8: u32 = 2560;
pub const _WIN32_IE_WINBLUE: u32 = 2560;
pub const _WIN32_IE_WINTHRESHOLD: u32 = 2560;
pub const _WIN32_IE_WIN10: u32 = 2560;
pub const NTDDI_WIN2K: u32 = 83886080;
pub const NTDDI_WIN2KSP1: u32 = 83886336;
pub const NTDDI_WIN2KSP2: u32 = 83886592;
pub const NTDDI_WIN2KSP3: u32 = 83886848;
pub const NTDDI_WIN2KSP4: u32 = 83887104;
pub const NTDDI_WINXP: u32 = 83951616;
pub const NTDDI_WINXPSP1: u32 = 83951872;
pub const NTDDI_WINXPSP2: u32 = 83952128;
pub const NTDDI_WINXPSP3: u32 = 83952384;
pub const NTDDI_WINXPSP4: u32 = 83952640;
pub const NTDDI_WS03: u32 = 84017152;
pub const NTDDI_WS03SP1: u32 = 84017408;
pub const NTDDI_WS03SP2: u32 = 84017664;
pub const NTDDI_WS03SP3: u32 = 84017920;
pub const NTDDI_WS03SP4: u32 = 84018176;
pub const NTDDI_WIN6: u32 = 100663296;
pub const NTDDI_WIN6SP1: u32 = 100663552;
pub const NTDDI_WIN6SP2: u32 = 100663808;
pub const NTDDI_WIN6SP3: u32 = 100664064;
pub const NTDDI_WIN6SP4: u32 = 100664320;
pub const NTDDI_VISTA: u32 = 100663296;
pub const NTDDI_VISTASP1: u32 = 100663552;
pub const NTDDI_VISTASP2: u32 = 100663808;
pub const NTDDI_VISTASP3: u32 = 100664064;
pub const NTDDI_VISTASP4: u32 = 100664320;
pub const NTDDI_LONGHORN: u32 = 100663296;
pub const NTDDI_WS08: u32 = 100663552;
pub const NTDDI_WS08SP2: u32 = 100663808;
pub const NTDDI_WS08SP3: u32 = 100664064;
pub const NTDDI_WS08SP4: u32 = 100664320;
pub const NTDDI_WIN7: u32 = 100728832;
pub const NTDDI_WIN8: u32 = 100794368;
pub const NTDDI_WINBLUE: u32 = 100859904;
pub const NTDDI_WINTHRESHOLD: u32 = 167772160;
pub const NTDDI_WIN10: u32 = 167772160;
pub const NTDDI_WIN10_TH2: u32 = 167772161;
pub const NTDDI_WIN10_RS1: u32 = 167772162;
pub const NTDDI_WIN10_RS2: u32 = 167772163;
pub const NTDDI_WIN10_RS3: u32 = 167772164;
pub const NTDDI_WIN10_RS4: u32 = 167772165;
pub const NTDDI_WIN10_RS5: u32 = 167772166;
pub const WDK_NTDDI_VERSION: u32 = 167772166;
pub const OSVERSION_MASK: u32 = 4294901760;
pub const SPVERSION_MASK: u32 = 65280;
pub const SUBVERSION_MASK: u32 = 255;
pub const _WIN32_WINNT: u32 = 2560;
pub const NTDDI_VERSION: u32 = 167772166;
pub const WINVER: u32 = 2560;
pub const _WIN32_IE: u32 = 2560;
pub const LANG_NEUTRAL: u32 = 0;
pub const LANG_INVARIANT: u32 = 127;
pub const LANG_AFRIKAANS: u32 = 54;
pub const LANG_ALBANIAN: u32 = 28;
pub const LANG_ALSATIAN: u32 = 132;
pub const LANG_AMHARIC: u32 = 94;
pub const LANG_ARABIC: u32 = 1;
pub const LANG_ARMENIAN: u32 = 43;
pub const LANG_ASSAMESE: u32 = 77;
pub const LANG_AZERI: u32 = 44;
pub const LANG_AZERBAIJANI: u32 = 44;
pub const LANG_BANGLA: u32 = 69;
pub const LANG_BASHKIR: u32 = 109;
pub const LANG_BASQUE: u32 = 45;
pub const LANG_BELARUSIAN: u32 = 35;
pub const LANG_BENGALI: u32 = 69;
pub const LANG_BRETON: u32 = 126;
pub const LANG_BOSNIAN: u32 = 26;
pub const LANG_BOSNIAN_NEUTRAL: u32 = 30746;
pub const LANG_BULGARIAN: u32 = 2;
pub const LANG_CATALAN: u32 = 3;
pub const LANG_CENTRAL_KURDISH: u32 = 146;
pub const LANG_CHEROKEE: u32 = 92;
pub const LANG_CHINESE: u32 = 4;
pub const LANG_CHINESE_SIMPLIFIED: u32 = 4;
pub const LANG_CHINESE_TRADITIONAL: u32 = 31748;
pub const LANG_CORSICAN: u32 = 131;
pub const LANG_CROATIAN: u32 = 26;
pub const LANG_CZECH: u32 = 5;
pub const LANG_DANISH: u32 = 6;
pub const LANG_DARI: u32 = 140;
pub const LANG_DIVEHI: u32 = 101;
pub const LANG_DUTCH: u32 = 19;
pub const LANG_ENGLISH: u32 = 9;
pub const LANG_ESTONIAN: u32 = 37;
pub const LANG_FAEROESE: u32 = 56;
pub const LANG_FARSI: u32 = 41;
pub const LANG_FILIPINO: u32 = 100;
pub const LANG_FINNISH: u32 = 11;
pub const LANG_FRENCH: u32 = 12;
pub const LANG_FRISIAN: u32 = 98;
pub const LANG_FULAH: u32 = 103;
pub const LANG_GALICIAN: u32 = 86;
pub const LANG_GEORGIAN: u32 = 55;
pub const LANG_GERMAN: u32 = 7;
pub const LANG_GREEK: u32 = 8;
pub const LANG_GREENLANDIC: u32 = 111;
pub const LANG_GUJARATI: u32 = 71;
pub const LANG_HAUSA: u32 = 104;
pub const LANG_HAWAIIAN: u32 = 117;
pub const LANG_HEBREW: u32 = 13;
pub const LANG_HINDI: u32 = 57;
pub const LANG_HUNGARIAN: u32 = 14;
pub const LANG_ICELANDIC: u32 = 15;
pub const LANG_IGBO: u32 = 112;
pub const LANG_INDONESIAN: u32 = 33;
pub const LANG_INUKTITUT: u32 = 93;
pub const LANG_IRISH: u32 = 60;
pub const LANG_ITALIAN: u32 = 16;
pub const LANG_JAPANESE: u32 = 17;
pub const LANG_KANNADA: u32 = 75;
pub const LANG_KASHMIRI: u32 = 96;
pub const LANG_KAZAK: u32 = 63;
pub const LANG_KHMER: u32 = 83;
pub const LANG_KICHE: u32 = 134;
pub const LANG_KINYARWANDA: u32 = 135;
pub const LANG_KONKANI: u32 = 87;
pub const LANG_KOREAN: u32 = 18;
pub const LANG_KYRGYZ: u32 = 64;
pub const LANG_LAO: u32 = 84;
pub const LANG_LATVIAN: u32 = 38;
pub const LANG_LITHUANIAN: u32 = 39;
pub const LANG_LOWER_SORBIAN: u32 = 46;
pub const LANG_LUXEMBOURGISH: u32 = 110;
pub const LANG_MACEDONIAN: u32 = 47;
pub const LANG_MALAY: u32 = 62;
pub const LANG_MALAYALAM: u32 = 76;
pub const LANG_MALTESE: u32 = 58;
pub const LANG_MANIPURI: u32 = 88;
pub const LANG_MAORI: u32 = 129;
pub const LANG_MAPUDUNGUN: u32 = 122;
pub const LANG_MARATHI: u32 = 78;
pub const LANG_MOHAWK: u32 = 124;
pub const LANG_MONGOLIAN: u32 = 80;
pub const LANG_NEPALI: u32 = 97;
pub const LANG_NORWEGIAN: u32 = 20;
pub const LANG_OCCITAN: u32 = 130;
pub const LANG_ODIA: u32 = 72;
pub const LANG_ORIYA: u32 = 72;
pub const LANG_PASHTO: u32 = 99;
pub const LANG_PERSIAN: u32 = 41;
pub const LANG_POLISH: u32 = 21;
pub const LANG_PORTUGUESE: u32 = 22;
pub const LANG_PULAR: u32 = 103;
pub const LANG_PUNJABI: u32 = 70;
pub const LANG_QUECHUA: u32 = 107;
pub const LANG_ROMANIAN: u32 = 24;
pub const LANG_ROMANSH: u32 = 23;
pub const LANG_RUSSIAN: u32 = 25;
pub const LANG_SAKHA: u32 = 133;
pub const LANG_SAMI: u32 = 59;
pub const LANG_SANSKRIT: u32 = 79;
pub const LANG_SCOTTISH_GAELIC: u32 = 145;
pub const LANG_SERBIAN: u32 = 26;
pub const LANG_SERBIAN_NEUTRAL: u32 = 31770;
pub const LANG_SINDHI: u32 = 89;
pub const LANG_SINHALESE: u32 = 91;
pub const LANG_SLOVAK: u32 = 27;
pub const LANG_SLOVENIAN: u32 = 36;
pub const LANG_SOTHO: u32 = 108;
pub const LANG_SPANISH: u32 = 10;
pub const LANG_SWAHILI: u32 = 65;
pub const LANG_SWEDISH: u32 = 29;
pub const LANG_SYRIAC: u32 = 90;
pub const LANG_TAJIK: u32 = 40;
pub const LANG_TAMAZIGHT: u32 = 95;
pub const LANG_TAMIL: u32 = 73;
pub const LANG_TATAR: u32 = 68;
pub const LANG_TELUGU: u32 = 74;
pub const LANG_THAI: u32 = 30;
pub const LANG_TIBETAN: u32 = 81;
pub const LANG_TIGRIGNA: u32 = 115;
pub const LANG_TIGRINYA: u32 = 115;
pub const LANG_TSWANA: u32 = 50;
pub const LANG_TURKISH: u32 = 31;
pub const LANG_TURKMEN: u32 = 66;
pub const LANG_UIGHUR: u32 = 128;
pub const LANG_UKRAINIAN: u32 = 34;
pub const LANG_UPPER_SORBIAN: u32 = 46;
pub const LANG_URDU: u32 = 32;
pub const LANG_UZBEK: u32 = 67;
pub const LANG_VALENCIAN: u32 = 3;
pub const LANG_VIETNAMESE: u32 = 42;
pub const LANG_WELSH: u32 = 82;
pub const LANG_WOLOF: u32 = 136;
pub const LANG_XHOSA: u32 = 52;
pub const LANG_YAKUT: u32 = 133;
pub const LANG_YI: u32 = 120;
pub const LANG_YORUBA: u32 = 106;
pub const LANG_ZULU: u32 = 53;
pub const SUBLANG_NEUTRAL: u32 = 0;
pub const SUBLANG_DEFAULT: u32 = 1;
pub const SUBLANG_SYS_DEFAULT: u32 = 2;
pub const SUBLANG_CUSTOM_DEFAULT: u32 = 3;
pub const SUBLANG_CUSTOM_UNSPECIFIED: u32 = 4;
pub const SUBLANG_UI_CUSTOM_DEFAULT: u32 = 5;
pub const SUBLANG_AFRIKAANS_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_ALBANIAN_ALBANIA: u32 = 1;
pub const SUBLANG_ALSATIAN_FRANCE: u32 = 1;
pub const SUBLANG_AMHARIC_ETHIOPIA: u32 = 1;
pub const SUBLANG_ARABIC_SAUDI_ARABIA: u32 = 1;
pub const SUBLANG_ARABIC_IRAQ: u32 = 2;
pub const SUBLANG_ARABIC_EGYPT: u32 = 3;
pub const SUBLANG_ARABIC_LIBYA: u32 = 4;
pub const SUBLANG_ARABIC_ALGERIA: u32 = 5;
pub const SUBLANG_ARABIC_MOROCCO: u32 = 6;
pub const SUBLANG_ARABIC_TUNISIA: u32 = 7;
pub const SUBLANG_ARABIC_OMAN: u32 = 8;
pub const SUBLANG_ARABIC_YEMEN: u32 = 9;
pub const SUBLANG_ARABIC_SYRIA: u32 = 10;
pub const SUBLANG_ARABIC_JORDAN: u32 = 11;
pub const SUBLANG_ARABIC_LEBANON: u32 = 12;
pub const SUBLANG_ARABIC_KUWAIT: u32 = 13;
pub const SUBLANG_ARABIC_UAE: u32 = 14;
pub const SUBLANG_ARABIC_BAHRAIN: u32 = 15;
pub const SUBLANG_ARABIC_QATAR: u32 = 16;
pub const SUBLANG_ARMENIAN_ARMENIA: u32 = 1;
pub const SUBLANG_ASSAMESE_INDIA: u32 = 1;
pub const SUBLANG_AZERI_LATIN: u32 = 1;
pub const SUBLANG_AZERI_CYRILLIC: u32 = 2;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_LATIN: u32 = 1;
pub const SUBLANG_AZERBAIJANI_AZERBAIJAN_CYRILLIC: u32 = 2;
pub const SUBLANG_BANGLA_INDIA: u32 = 1;
pub const SUBLANG_BANGLA_BANGLADESH: u32 = 2;
pub const SUBLANG_BASHKIR_RUSSIA: u32 = 1;
pub const SUBLANG_BASQUE_BASQUE: u32 = 1;
pub const SUBLANG_BELARUSIAN_BELARUS: u32 = 1;
pub const SUBLANG_BENGALI_INDIA: u32 = 1;
pub const SUBLANG_BENGALI_BANGLADESH: u32 = 2;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 5;
pub const SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 8;
pub const SUBLANG_BRETON_FRANCE: u32 = 1;
pub const SUBLANG_BULGARIAN_BULGARIA: u32 = 1;
pub const SUBLANG_CATALAN_CATALAN: u32 = 1;
pub const SUBLANG_CENTRAL_KURDISH_IRAQ: u32 = 1;
pub const SUBLANG_CHEROKEE_CHEROKEE: u32 = 1;
pub const SUBLANG_CHINESE_TRADITIONAL: u32 = 1;
pub const SUBLANG_CHINESE_SIMPLIFIED: u32 = 2;
pub const SUBLANG_CHINESE_HONGKONG: u32 = 3;
pub const SUBLANG_CHINESE_SINGAPORE: u32 = 4;
pub const SUBLANG_CHINESE_MACAU: u32 = 5;
pub const SUBLANG_CORSICAN_FRANCE: u32 = 1;
pub const SUBLANG_CZECH_CZECH_REPUBLIC: u32 = 1;
pub const SUBLANG_CROATIAN_CROATIA: u32 = 1;
pub const SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 4;
pub const SUBLANG_DANISH_DENMARK: u32 = 1;
pub const SUBLANG_DARI_AFGHANISTAN: u32 = 1;
pub const SUBLANG_DIVEHI_MALDIVES: u32 = 1;
pub const SUBLANG_DUTCH: u32 = 1;
pub const SUBLANG_DUTCH_BELGIAN: u32 = 2;
pub const SUBLANG_ENGLISH_US: u32 = 1;
pub const SUBLANG_ENGLISH_UK: u32 = 2;
pub const SUBLANG_ENGLISH_AUS: u32 = 3;
pub const SUBLANG_ENGLISH_CAN: u32 = 4;
pub const SUBLANG_ENGLISH_NZ: u32 = 5;
pub const SUBLANG_ENGLISH_EIRE: u32 = 6;
pub const SUBLANG_ENGLISH_SOUTH_AFRICA: u32 = 7;
pub const SUBLANG_ENGLISH_JAMAICA: u32 = 8;
pub const SUBLANG_ENGLISH_CARIBBEAN: u32 = 9;
pub const SUBLANG_ENGLISH_BELIZE: u32 = 10;
pub const SUBLANG_ENGLISH_TRINIDAD: u32 = 11;
pub const SUBLANG_ENGLISH_ZIMBABWE: u32 = 12;
pub const SUBLANG_ENGLISH_PHILIPPINES: u32 = 13;
pub const SUBLANG_ENGLISH_INDIA: u32 = 16;
pub const SUBLANG_ENGLISH_MALAYSIA: u32 = 17;
pub const SUBLANG_ENGLISH_SINGAPORE: u32 = 18;
pub const SUBLANG_ESTONIAN_ESTONIA: u32 = 1;
pub const SUBLANG_FAEROESE_FAROE_ISLANDS: u32 = 1;
pub const SUBLANG_FILIPINO_PHILIPPINES: u32 = 1;
pub const SUBLANG_FINNISH_FINLAND: u32 = 1;
pub const SUBLANG_FRENCH: u32 = 1;
pub const SUBLANG_FRENCH_BELGIAN: u32 = 2;
pub const SUBLANG_FRENCH_CANADIAN: u32 = 3;
pub const SUBLANG_FRENCH_SWISS: u32 = 4;
pub const SUBLANG_FRENCH_LUXEMBOURG: u32 = 5;
pub const SUBLANG_FRENCH_MONACO: u32 = 6;
pub const SUBLANG_FRISIAN_NETHERLANDS: u32 = 1;
pub const SUBLANG_FULAH_SENEGAL: u32 = 2;
pub const SUBLANG_GALICIAN_GALICIAN: u32 = 1;
pub const SUBLANG_GEORGIAN_GEORGIA: u32 = 1;
pub const SUBLANG_GERMAN: u32 = 1;
pub const SUBLANG_GERMAN_SWISS: u32 = 2;
pub const SUBLANG_GERMAN_AUSTRIAN: u32 = 3;
pub const SUBLANG_GERMAN_LUXEMBOURG: u32 = 4;
pub const SUBLANG_GERMAN_LIECHTENSTEIN: u32 = 5;
pub const SUBLANG_GREEK_GREECE: u32 = 1;
pub const SUBLANG_GREENLANDIC_GREENLAND: u32 = 1;
pub const SUBLANG_GUJARATI_INDIA: u32 = 1;
pub const SUBLANG_HAUSA_NIGERIA_LATIN: u32 = 1;
pub const SUBLANG_HAWAIIAN_US: u32 = 1;
pub const SUBLANG_HEBREW_ISRAEL: u32 = 1;
pub const SUBLANG_HINDI_INDIA: u32 = 1;
pub const SUBLANG_HUNGARIAN_HUNGARY: u32 = 1;
pub const SUBLANG_ICELANDIC_ICELAND: u32 = 1;
pub const SUBLANG_IGBO_NIGERIA: u32 = 1;
pub const SUBLANG_INDONESIAN_INDONESIA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA: u32 = 1;
pub const SUBLANG_INUKTITUT_CANADA_LATIN: u32 = 2;
pub const SUBLANG_IRISH_IRELAND: u32 = 2;
pub const SUBLANG_ITALIAN: u32 = 1;
pub const SUBLANG_ITALIAN_SWISS: u32 = 2;
pub const SUBLANG_JAPANESE_JAPAN: u32 = 1;
pub const SUBLANG_KANNADA_INDIA: u32 = 1;
pub const SUBLANG_KASHMIRI_SASIA: u32 = 2;
pub const SUBLANG_KASHMIRI_INDIA: u32 = 2;
pub const SUBLANG_KAZAK_KAZAKHSTAN: u32 = 1;
pub const SUBLANG_KHMER_CAMBODIA: u32 = 1;
pub const SUBLANG_KICHE_GUATEMALA: u32 = 1;
pub const SUBLANG_KINYARWANDA_RWANDA: u32 = 1;
pub const SUBLANG_KONKANI_INDIA: u32 = 1;
pub const SUBLANG_KOREAN: u32 = 1;
pub const SUBLANG_KYRGYZ_KYRGYZSTAN: u32 = 1;
pub const SUBLANG_LAO_LAO: u32 = 1;
pub const SUBLANG_LATVIAN_LATVIA: u32 = 1;
pub const SUBLANG_LITHUANIAN: u32 = 1;
pub const SUBLANG_LOWER_SORBIAN_GERMANY: u32 = 2;
pub const SUBLANG_LUXEMBOURGISH_LUXEMBOURG: u32 = 1;
pub const SUBLANG_MACEDONIAN_MACEDONIA: u32 = 1;
pub const SUBLANG_MALAY_MALAYSIA: u32 = 1;
pub const SUBLANG_MALAY_BRUNEI_DARUSSALAM: u32 = 2;
pub const SUBLANG_MALAYALAM_INDIA: u32 = 1;
pub const SUBLANG_MALTESE_MALTA: u32 = 1;
pub const SUBLANG_MAORI_NEW_ZEALAND: u32 = 1;
pub const SUBLANG_MAPUDUNGUN_CHILE: u32 = 1;
pub const SUBLANG_MARATHI_INDIA: u32 = 1;
pub const SUBLANG_MOHAWK_MOHAWK: u32 = 1;
pub const SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA: u32 = 1;
pub const SUBLANG_MONGOLIAN_PRC: u32 = 2;
pub const SUBLANG_NEPALI_INDIA: u32 = 2;
pub const SUBLANG_NEPALI_NEPAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_BOKMAL: u32 = 1;
pub const SUBLANG_NORWEGIAN_NYNORSK: u32 = 2;
pub const SUBLANG_OCCITAN_FRANCE: u32 = 1;
pub const SUBLANG_ODIA_INDIA: u32 = 1;
pub const SUBLANG_ORIYA_INDIA: u32 = 1;
pub const SUBLANG_PASHTO_AFGHANISTAN: u32 = 1;
pub const SUBLANG_PERSIAN_IRAN: u32 = 1;
pub const SUBLANG_POLISH_POLAND: u32 = 1;
pub const SUBLANG_PORTUGUESE: u32 = 2;
pub const SUBLANG_PORTUGUESE_BRAZILIAN: u32 = 1;
pub const SUBLANG_PULAR_SENEGAL: u32 = 2;
pub const SUBLANG_PUNJABI_INDIA: u32 = 1;
pub const SUBLANG_PUNJABI_PAKISTAN: u32 = 2;
pub const SUBLANG_QUECHUA_BOLIVIA: u32 = 1;
pub const SUBLANG_QUECHUA_ECUADOR: u32 = 2;
pub const SUBLANG_QUECHUA_PERU: u32 = 3;
pub const SUBLANG_ROMANIAN_ROMANIA: u32 = 1;
pub const SUBLANG_ROMANSH_SWITZERLAND: u32 = 1;
pub const SUBLANG_RUSSIAN_RUSSIA: u32 = 1;
pub const SUBLANG_SAKHA_RUSSIA: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_NORWAY: u32 = 1;
pub const SUBLANG_SAMI_NORTHERN_SWEDEN: u32 = 2;
pub const SUBLANG_SAMI_NORTHERN_FINLAND: u32 = 3;
pub const SUBLANG_SAMI_LULE_NORWAY: u32 = 4;
pub const SUBLANG_SAMI_LULE_SWEDEN: u32 = 5;
pub const SUBLANG_SAMI_SOUTHERN_NORWAY: u32 = 6;
pub const SUBLANG_SAMI_SOUTHERN_SWEDEN: u32 = 7;
pub const SUBLANG_SAMI_SKOLT_FINLAND: u32 = 8;
pub const SUBLANG_SAMI_INARI_FINLAND: u32 = 9;
pub const SUBLANG_SANSKRIT_INDIA: u32 = 1;
pub const SUBLANG_SCOTTISH_GAELIC: u32 = 1;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN: u32 = 6;
pub const SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC: u32 = 7;
pub const SUBLANG_SERBIAN_MONTENEGRO_LATIN: u32 = 11;
pub const SUBLANG_SERBIAN_MONTENEGRO_CYRILLIC: u32 = 12;
pub const SUBLANG_SERBIAN_SERBIA_LATIN: u32 = 9;
pub const SUBLANG_SERBIAN_SERBIA_CYRILLIC: u32 = 10;
pub const SUBLANG_SERBIAN_CROATIA: u32 = 1;
pub const SUBLANG_SERBIAN_LATIN: u32 = 2;
pub const SUBLANG_SERBIAN_CYRILLIC: u32 = 3;
pub const SUBLANG_SINDHI_INDIA: u32 = 1;
pub const SUBLANG_SINDHI_PAKISTAN: u32 = 2;
pub const SUBLANG_SINDHI_AFGHANISTAN: u32 = 2;
pub const SUBLANG_SINHALESE_SRI_LANKA: u32 = 1;
pub const SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_SLOVAK_SLOVAKIA: u32 = 1;
pub const SUBLANG_SLOVENIAN_SLOVENIA: u32 = 1;
pub const SUBLANG_SPANISH: u32 = 1;
pub const SUBLANG_SPANISH_MEXICAN: u32 = 2;
pub const SUBLANG_SPANISH_MODERN: u32 = 3;
pub const SUBLANG_SPANISH_GUATEMALA: u32 = 4;
pub const SUBLANG_SPANISH_COSTA_RICA: u32 = 5;
pub const SUBLANG_SPANISH_PANAMA: u32 = 6;
pub const SUBLANG_SPANISH_DOMINICAN_REPUBLIC: u32 = 7;
pub const SUBLANG_SPANISH_VENEZUELA: u32 = 8;
pub const SUBLANG_SPANISH_COLOMBIA: u32 = 9;
pub const SUBLANG_SPANISH_PERU: u32 = 10;
pub const SUBLANG_SPANISH_ARGENTINA: u32 = 11;
pub const SUBLANG_SPANISH_ECUADOR: u32 = 12;
pub const SUBLANG_SPANISH_CHILE: u32 = 13;
pub const SUBLANG_SPANISH_URUGUAY: u32 = 14;
pub const SUBLANG_SPANISH_PARAGUAY: u32 = 15;
pub const SUBLANG_SPANISH_BOLIVIA: u32 = 16;
pub const SUBLANG_SPANISH_EL_SALVADOR: u32 = 17;
pub const SUBLANG_SPANISH_HONDURAS: u32 = 18;
pub const SUBLANG_SPANISH_NICARAGUA: u32 = 19;
pub const SUBLANG_SPANISH_PUERTO_RICO: u32 = 20;
pub const SUBLANG_SPANISH_US: u32 = 21;
pub const SUBLANG_SWAHILI_KENYA: u32 = 1;
pub const SUBLANG_SWEDISH: u32 = 1;
pub const SUBLANG_SWEDISH_FINLAND: u32 = 2;
pub const SUBLANG_SYRIAC_SYRIA: u32 = 1;
pub const SUBLANG_TAJIK_TAJIKISTAN: u32 = 1;
pub const SUBLANG_TAMAZIGHT_ALGERIA_LATIN: u32 = 2;
pub const SUBLANG_TAMAZIGHT_MOROCCO_TIFINAGH: u32 = 4;
pub const SUBLANG_TAMIL_INDIA: u32 = 1;
pub const SUBLANG_TAMIL_SRI_LANKA: u32 = 2;
pub const SUBLANG_TATAR_RUSSIA: u32 = 1;
pub const SUBLANG_TELUGU_INDIA: u32 = 1;
pub const SUBLANG_THAI_THAILAND: u32 = 1;
pub const SUBLANG_TIBETAN_PRC: u32 = 1;
pub const SUBLANG_TIGRIGNA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ERITREA: u32 = 2;
pub const SUBLANG_TIGRINYA_ETHIOPIA: u32 = 1;
pub const SUBLANG_TSWANA_BOTSWANA: u32 = 2;
pub const SUBLANG_TSWANA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_TURKISH_TURKEY: u32 = 1;
pub const SUBLANG_TURKMEN_TURKMENISTAN: u32 = 1;
pub const SUBLANG_UIGHUR_PRC: u32 = 1;
pub const SUBLANG_UKRAINIAN_UKRAINE: u32 = 1;
pub const SUBLANG_UPPER_SORBIAN_GERMANY: u32 = 1;
pub const SUBLANG_URDU_PAKISTAN: u32 = 1;
pub const SUBLANG_URDU_INDIA: u32 = 2;
pub const SUBLANG_UZBEK_LATIN: u32 = 1;
pub const SUBLANG_UZBEK_CYRILLIC: u32 = 2;
pub const SUBLANG_VALENCIAN_VALENCIA: u32 = 2;
pub const SUBLANG_VIETNAMESE_VIETNAM: u32 = 1;
pub const SUBLANG_WELSH_UNITED_KINGDOM: u32 = 1;
pub const SUBLANG_WOLOF_SENEGAL: u32 = 1;
pub const SUBLANG_XHOSA_SOUTH_AFRICA: u32 = 1;
pub const SUBLANG_YAKUT_RUSSIA: u32 = 1;
pub const SUBLANG_YI_PRC: u32 = 1;
pub const SUBLANG_YORUBA_NIGERIA: u32 = 1;
pub const SUBLANG_ZULU_SOUTH_AFRICA: u32 = 1;
pub const SORT_DEFAULT: u32 = 0;
pub const SORT_INVARIANT_MATH: u32 = 1;
pub const SORT_JAPANESE_XJIS: u32 = 0;
pub const SORT_JAPANESE_UNICODE: u32 = 1;
pub const SORT_JAPANESE_RADICALSTROKE: u32 = 4;
pub const SORT_CHINESE_BIG5: u32 = 0;
pub const SORT_CHINESE_PRCP: u32 = 0;
pub const SORT_CHINESE_UNICODE: u32 = 1;
pub const SORT_CHINESE_PRC: u32 = 2;
pub const SORT_CHINESE_BOPOMOFO: u32 = 3;
pub const SORT_CHINESE_RADICALSTROKE: u32 = 4;
pub const SORT_KOREAN_KSC: u32 = 0;
pub const SORT_KOREAN_UNICODE: u32 = 1;
pub const SORT_GERMAN_PHONE_BOOK: u32 = 1;
pub const SORT_HUNGARIAN_DEFAULT: u32 = 0;
pub const SORT_HUNGARIAN_TECHNICAL: u32 = 1;
pub const SORT_GEORGIAN_TRADITIONAL: u32 = 0;
pub const SORT_GEORGIAN_MODERN: u32 = 1;
pub const NLS_VALID_LOCALE_MASK: u32 = 1048575;
pub const LOCALE_NAME_MAX_LENGTH: u32 = 85;
pub const LOCALE_TRANSIENT_KEYBOARD1: u32 = 8192;
pub const LOCALE_TRANSIENT_KEYBOARD2: u32 = 9216;
pub const LOCALE_TRANSIENT_KEYBOARD3: u32 = 10240;
pub const LOCALE_TRANSIENT_KEYBOARD4: u32 = 11264;
pub const MAXIMUM_WAIT_OBJECTS: u32 = 64;
pub const MAXIMUM_SUSPEND_COUNT: u32 = 127;
pub const _MM_HINT_T0: u32 = 1;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 3;
pub const _MM_HINT_NTA: u32 = 0;
pub const PF_TEMPORAL_LEVEL_1: u32 = 1;
pub const PF_TEMPORAL_LEVEL_2: u32 = 2;
pub const PF_TEMPORAL_LEVEL_3: u32 = 3;
pub const PF_NON_TEMPORAL_LEVEL_ALL: u32 = 0;
pub const EXCEPTION_READ_FAULT: u32 = 0;
pub const EXCEPTION_WRITE_FAULT: u32 = 1;
pub const EXCEPTION_EXECUTE_FAULT: u32 = 8;
pub const CONTEXT_AMD64: u32 = 1048576;
pub const CONTEXT_CONTROL: u32 = 1048577;
pub const CONTEXT_INTEGER: u32 = 1048578;
pub const CONTEXT_SEGMENTS: u32 = 1048580;
pub const CONTEXT_FLOATING_POINT: u32 = 1048584;
pub const CONTEXT_DEBUG_REGISTERS: u32 = 1048592;
pub const CONTEXT_FULL: u32 = 1048587;
pub const CONTEXT_ALL: u32 = 1048607;
pub const CONTEXT_XSTATE: u32 = 1048640;
pub const CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const INITIAL_MXCSR: u32 = 8064;
pub const INITIAL_FPCSR: u32 = 639;
pub const RUNTIME_FUNCTION_INDIRECT: u32 = 1;
pub const UNW_FLAG_NHANDLER: u32 = 0;
pub const UNW_FLAG_EHANDLER: u32 = 1;
pub const UNW_FLAG_UHANDLER: u32 = 2;
pub const UNW_FLAG_CHAININFO: u32 = 4;
pub const UNW_FLAG_NO_EPILOGUE: u32 = 2147483648;
pub const UNWIND_HISTORY_TABLE_SIZE: u32 = 12;
pub const OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK_EXPORT_NAME: &'static [u8; 34usize] =
    b"OutOfProcessFunctionTableCallback\0";
pub const WOW64_CONTEXT_i386: u32 = 65536;
pub const WOW64_CONTEXT_i486: u32 = 65536;
pub const WOW64_CONTEXT_CONTROL: u32 = 65537;
pub const WOW64_CONTEXT_INTEGER: u32 = 65538;
pub const WOW64_CONTEXT_SEGMENTS: u32 = 65540;
pub const WOW64_CONTEXT_FLOATING_POINT: u32 = 65544;
pub const WOW64_CONTEXT_DEBUG_REGISTERS: u32 = 65552;
pub const WOW64_CONTEXT_EXTENDED_REGISTERS: u32 = 65568;
pub const WOW64_CONTEXT_FULL: u32 = 65543;
pub const WOW64_CONTEXT_ALL: u32 = 65599;
pub const WOW64_CONTEXT_XSTATE: u32 = 65600;
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE: u32 = 134217728;
pub const WOW64_CONTEXT_SERVICE_ACTIVE: u32 = 268435456;
pub const WOW64_CONTEXT_EXCEPTION_REQUEST: u32 = 1073741824;
pub const WOW64_CONTEXT_EXCEPTION_REPORTING: u32 = 2147483648;
pub const WOW64_SIZE_OF_80387_REGISTERS: u32 = 80;
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION: u32 = 512;
pub const EXCEPTION_NONCONTINUABLE: u32 = 1;
pub const EXCEPTION_UNWINDING: u32 = 2;
pub const EXCEPTION_EXIT_UNWIND: u32 = 4;
pub const EXCEPTION_STACK_INVALID: u32 = 8;
pub const EXCEPTION_NESTED_CALL: u32 = 16;
pub const EXCEPTION_TARGET_UNWIND: u32 = 32;
pub const EXCEPTION_COLLIDED_UNWIND: u32 = 64;
pub const EXCEPTION_UNWIND: u32 = 102;
pub const EXCEPTION_MAXIMUM_PARAMETERS: u32 = 15;
pub const DELETE: u32 = 65536;
pub const READ_CONTROL: u32 = 131072;
pub const WRITE_DAC: u32 = 262144;
pub const WRITE_OWNER: u32 = 524288;
pub const SYNCHRONIZE: u32 = 1048576;
pub const STANDARD_RIGHTS_REQUIRED: u32 = 983040;
pub const STANDARD_RIGHTS_READ: u32 = 131072;
pub const STANDARD_RIGHTS_WRITE: u32 = 131072;
pub const STANDARD_RIGHTS_EXECUTE: u32 = 131072;
pub const STANDARD_RIGHTS_ALL: u32 = 2031616;
pub const SPECIFIC_RIGHTS_ALL: u32 = 65535;
pub const ACCESS_SYSTEM_SECURITY: u32 = 16777216;
pub const MAXIMUM_ALLOWED: u32 = 33554432;
pub const GENERIC_READ: u32 = 2147483648;
pub const GENERIC_WRITE: u32 = 1073741824;
pub const GENERIC_EXECUTE: u32 = 536870912;
pub const GENERIC_ALL: u32 = 268435456;
pub const SID_REVISION: u32 = 1;
pub const SID_MAX_SUB_AUTHORITIES: u32 = 15;
pub const SID_RECOMMENDED_SUB_AUTHORITIES: u32 = 1;
pub const SECURITY_MAX_SID_STRING_CHARACTERS: u32 = 187;
pub const SID_HASH_SIZE: u32 = 32;
pub const SECURITY_NULL_RID: u32 = 0;
pub const SECURITY_WORLD_RID: u32 = 0;
pub const SECURITY_LOCAL_RID: u32 = 0;
pub const SECURITY_LOCAL_LOGON_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_RID: u32 = 0;
pub const SECURITY_CREATOR_GROUP_RID: u32 = 1;
pub const SECURITY_CREATOR_OWNER_SERVER_RID: u32 = 2;
pub const SECURITY_CREATOR_GROUP_SERVER_RID: u32 = 3;
pub const SECURITY_CREATOR_OWNER_RIGHTS_RID: u32 = 4;
pub const SECURITY_DIALUP_RID: u32 = 1;
pub const SECURITY_NETWORK_RID: u32 = 2;
pub const SECURITY_BATCH_RID: u32 = 3;
pub const SECURITY_INTERACTIVE_RID: u32 = 4;
pub const SECURITY_LOGON_IDS_RID: u32 = 5;
pub const SECURITY_LOGON_IDS_RID_COUNT: u32 = 3;
pub const SECURITY_SERVICE_RID: u32 = 6;
pub const SECURITY_ANONYMOUS_LOGON_RID: u32 = 7;
pub const SECURITY_PROXY_RID: u32 = 8;
pub const SECURITY_ENTERPRISE_CONTROLLERS_RID: u32 = 9;
pub const SECURITY_SERVER_LOGON_RID: u32 = 9;
pub const SECURITY_PRINCIPAL_SELF_RID: u32 = 10;
pub const SECURITY_AUTHENTICATED_USER_RID: u32 = 11;
pub const SECURITY_RESTRICTED_CODE_RID: u32 = 12;
pub const SECURITY_TERMINAL_SERVER_RID: u32 = 13;
pub const SECURITY_REMOTE_LOGON_RID: u32 = 14;
pub const SECURITY_THIS_ORGANIZATION_RID: u32 = 15;
pub const SECURITY_IUSER_RID: u32 = 17;
pub const SECURITY_LOCAL_SYSTEM_RID: u32 = 18;
pub const SECURITY_LOCAL_SERVICE_RID: u32 = 19;
pub const SECURITY_NETWORK_SERVICE_RID: u32 = 20;
pub const SECURITY_NT_NON_UNIQUE: u32 = 21;
pub const SECURITY_NT_NON_UNIQUE_SUB_AUTH_COUNT: u32 = 3;
pub const SECURITY_ENTERPRISE_READONLY_CONTROLLERS_RID: u32 = 22;
pub const SECURITY_BUILTIN_DOMAIN_RID: u32 = 32;
pub const SECURITY_WRITE_RESTRICTED_CODE_RID: u32 = 33;
pub const SECURITY_PACKAGE_BASE_RID: u32 = 64;
pub const SECURITY_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_PACKAGE_NTLM_RID: u32 = 10;
pub const SECURITY_PACKAGE_SCHANNEL_RID: u32 = 14;
pub const SECURITY_PACKAGE_DIGEST_RID: u32 = 21;
pub const SECURITY_CRED_TYPE_BASE_RID: u32 = 65;
pub const SECURITY_CRED_TYPE_RID_COUNT: u32 = 2;
pub const SECURITY_CRED_TYPE_THIS_ORG_CERT_RID: u32 = 1;
pub const SECURITY_MIN_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_BASE_RID: u32 = 80;
pub const SECURITY_SERVICE_ID_RID_COUNT: u32 = 6;
pub const SECURITY_RESERVED_ID_BASE_RID: u32 = 81;
pub const SECURITY_APPPOOL_ID_BASE_RID: u32 = 82;
pub const SECURITY_APPPOOL_ID_RID_COUNT: u32 = 6;
pub const SECURITY_VIRTUALSERVER_ID_BASE_RID: u32 = 83;
pub const SECURITY_VIRTUALSERVER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMODEDRIVERHOST_ID_BASE_RID: u32 = 84;
pub const SECURITY_USERMODEDRIVERHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_BASE_RID: u32 = 85;
pub const SECURITY_CLOUD_INFRASTRUCTURE_SERVICES_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WMIHOST_ID_BASE_RID: u32 = 86;
pub const SECURITY_WMIHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_TASK_ID_BASE_RID: u32 = 87;
pub const SECURITY_NFS_ID_BASE_RID: u32 = 88;
pub const SECURITY_COM_ID_BASE_RID: u32 = 89;
pub const SECURITY_WINDOW_MANAGER_BASE_RID: u32 = 90;
pub const SECURITY_RDV_GFX_BASE_RID: u32 = 91;
pub const SECURITY_DASHOST_ID_BASE_RID: u32 = 92;
pub const SECURITY_DASHOST_ID_RID_COUNT: u32 = 6;
pub const SECURITY_USERMANAGER_ID_BASE_RID: u32 = 93;
pub const SECURITY_USERMANAGER_ID_RID_COUNT: u32 = 6;
pub const SECURITY_WINRM_ID_BASE_RID: u32 = 94;
pub const SECURITY_WINRM_ID_RID_COUNT: u32 = 6;
pub const SECURITY_CCG_ID_BASE_RID: u32 = 95;
pub const SECURITY_UMFD_BASE_RID: u32 = 96;
pub const SECURITY_VIRTUALACCOUNT_ID_RID_COUNT: u32 = 6;
pub const SECURITY_MAX_BASE_RID: u32 = 111;
pub const SECURITY_MAX_ALWAYS_FILTERED: u32 = 999;
pub const SECURITY_MIN_NEVER_FILTERED: u32 = 1000;
pub const SECURITY_OTHER_ORGANIZATION_RID: u32 = 1000;
pub const SECURITY_WINDOWSMOBILE_ID_BASE_RID: u32 = 112;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_BASE: u32 = 32;
pub const SECURITY_INSTALLER_GROUP_CAPABILITY_RID_COUNT: u32 = 9;
pub const SECURITY_INSTALLER_CAPABILITY_RID_COUNT: u32 = 10;
pub const SECURITY_LOCAL_ACCOUNT_RID: u32 = 113;
pub const SECURITY_LOCAL_ACCOUNT_AND_ADMIN_RID: u32 = 114;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_IS_COMPOUNDED: u32 = 496;
pub const DOMAIN_GROUP_RID_AUTHORIZATION_DATA_CONTAINS_CLAIMS: u32 = 497;
pub const DOMAIN_GROUP_RID_ENTERPRISE_READONLY_DOMAIN_CONTROLLERS: u32 = 498;
pub const FOREST_USER_RID_MAX: u32 = 499;
pub const DOMAIN_USER_RID_ADMIN: u32 = 500;
pub const DOMAIN_USER_RID_GUEST: u32 = 501;
pub const DOMAIN_USER_RID_KRBTGT: u32 = 502;
pub const DOMAIN_USER_RID_DEFAULT_ACCOUNT: u32 = 503;
pub const DOMAIN_USER_RID_WDAG_ACCOUNT: u32 = 504;
pub const DOMAIN_USER_RID_MAX: u32 = 999;
pub const DOMAIN_GROUP_RID_ADMINS: u32 = 512;
pub const DOMAIN_GROUP_RID_USERS: u32 = 513;
pub const DOMAIN_GROUP_RID_GUESTS: u32 = 514;
pub const DOMAIN_GROUP_RID_COMPUTERS: u32 = 515;
pub const DOMAIN_GROUP_RID_CONTROLLERS: u32 = 516;
pub const DOMAIN_GROUP_RID_CERT_ADMINS: u32 = 517;
pub const DOMAIN_GROUP_RID_SCHEMA_ADMINS: u32 = 518;
pub const DOMAIN_GROUP_RID_ENTERPRISE_ADMINS: u32 = 519;
pub const DOMAIN_GROUP_RID_POLICY_ADMINS: u32 = 520;
pub const DOMAIN_GROUP_RID_READONLY_CONTROLLERS: u32 = 521;
pub const DOMAIN_GROUP_RID_CLONEABLE_CONTROLLERS: u32 = 522;
pub const DOMAIN_GROUP_RID_CDC_RESERVED: u32 = 524;
pub const DOMAIN_GROUP_RID_PROTECTED_USERS: u32 = 525;
pub const DOMAIN_GROUP_RID_KEY_ADMINS: u32 = 526;
pub const DOMAIN_GROUP_RID_ENTERPRISE_KEY_ADMINS: u32 = 527;
pub const DOMAIN_ALIAS_RID_ADMINS: u32 = 544;
pub const DOMAIN_ALIAS_RID_USERS: u32 = 545;
pub const DOMAIN_ALIAS_RID_GUESTS: u32 = 546;
pub const DOMAIN_ALIAS_RID_POWER_USERS: u32 = 547;
pub const DOMAIN_ALIAS_RID_ACCOUNT_OPS: u32 = 548;
pub const DOMAIN_ALIAS_RID_SYSTEM_OPS: u32 = 549;
pub const DOMAIN_ALIAS_RID_PRINT_OPS: u32 = 550;
pub const DOMAIN_ALIAS_RID_BACKUP_OPS: u32 = 551;
pub const DOMAIN_ALIAS_RID_REPLICATOR: u32 = 552;
pub const DOMAIN_ALIAS_RID_RAS_SERVERS: u32 = 553;
pub const DOMAIN_ALIAS_RID_PREW2KCOMPACCESS: u32 = 554;
pub const DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS: u32 = 555;
pub const DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS: u32 = 556;
pub const DOMAIN_ALIAS_RID_INCOMING_FOREST_TRUST_BUILDERS: u32 = 557;
pub const DOMAIN_ALIAS_RID_MONITORING_USERS: u32 = 558;
pub const DOMAIN_ALIAS_RID_LOGGING_USERS: u32 = 559;
pub const DOMAIN_ALIAS_RID_AUTHORIZATIONACCESS: u32 = 560;
pub const DOMAIN_ALIAS_RID_TS_LICENSE_SERVERS: u32 = 561;
pub const DOMAIN_ALIAS_RID_DCOM_USERS: u32 = 562;
pub const DOMAIN_ALIAS_RID_IUSERS: u32 = 568;
pub const DOMAIN_ALIAS_RID_CRYPTO_OPERATORS: u32 = 569;
pub const DOMAIN_ALIAS_RID_CACHEABLE_PRINCIPALS_GROUP: u32 = 571;
pub const DOMAIN_ALIAS_RID_NON_CACHEABLE_PRINCIPALS_GROUP: u32 = 572;
pub const DOMAIN_ALIAS_RID_EVENT_LOG_READERS_GROUP: u32 = 573;
pub const DOMAIN_ALIAS_RID_CERTSVC_DCOM_ACCESS_GROUP: u32 = 574;
pub const DOMAIN_ALIAS_RID_RDS_REMOTE_ACCESS_SERVERS: u32 = 575;
pub const DOMAIN_ALIAS_RID_RDS_ENDPOINT_SERVERS: u32 = 576;
pub const DOMAIN_ALIAS_RID_RDS_MANAGEMENT_SERVERS: u32 = 577;
pub const DOMAIN_ALIAS_RID_HYPER_V_ADMINS: u32 = 578;
pub const DOMAIN_ALIAS_RID_ACCESS_CONTROL_ASSISTANCE_OPS: u32 = 579;
pub const DOMAIN_ALIAS_RID_REMOTE_MANAGEMENT_USERS: u32 = 580;
pub const DOMAIN_ALIAS_RID_DEFAULT_ACCOUNT: u32 = 581;
pub const DOMAIN_ALIAS_RID_STORAGE_REPLICA_ADMINS: u32 = 582;
pub const DOMAIN_ALIAS_RID_DEVICE_OWNERS: u32 = 583;
pub const SECURITY_APP_PACKAGE_BASE_RID: u32 = 2;
pub const SECURITY_BUILTIN_APP_PACKAGE_RID_COUNT: u32 = 2;
pub const SECURITY_APP_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CAPABILITY_BASE_RID: u32 = 3;
pub const SECURITY_CAPABILITY_APP_RID: u32 = 1024;
pub const SECURITY_BUILTIN_CAPABILITY_RID_COUNT: u32 = 2;
pub const SECURITY_CAPABILITY_RID_COUNT: u32 = 5;
pub const SECURITY_PARENT_PACKAGE_RID_COUNT: u32 = 8;
pub const SECURITY_CHILD_PACKAGE_RID_COUNT: u32 = 12;
pub const SECURITY_BUILTIN_PACKAGE_ANY_PACKAGE: u32 = 1;
pub const SECURITY_BUILTIN_PACKAGE_ANY_RESTRICTED_PACKAGE: u32 = 2;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT: u32 = 1;
pub const SECURITY_CAPABILITY_INTERNET_CLIENT_SERVER: u32 = 2;
pub const SECURITY_CAPABILITY_PRIVATE_NETWORK_CLIENT_SERVER: u32 = 3;
pub const SECURITY_CAPABILITY_PICTURES_LIBRARY: u32 = 4;
pub const SECURITY_CAPABILITY_VIDEOS_LIBRARY: u32 = 5;
pub const SECURITY_CAPABILITY_MUSIC_LIBRARY: u32 = 6;
pub const SECURITY_CAPABILITY_DOCUMENTS_LIBRARY: u32 = 7;
pub const SECURITY_CAPABILITY_ENTERPRISE_AUTHENTICATION: u32 = 8;
pub const SECURITY_CAPABILITY_SHARED_USER_CERTIFICATES: u32 = 9;
pub const SECURITY_CAPABILITY_REMOVABLE_STORAGE: u32 = 10;
pub const SECURITY_CAPABILITY_APPOINTMENTS: u32 = 11;
pub const SECURITY_CAPABILITY_CONTACTS: u32 = 12;
pub const SECURITY_CAPABILITY_INTERNET_EXPLORER: u32 = 4096;
pub const SECURITY_MANDATORY_UNTRUSTED_RID: u32 = 0;
pub const SECURITY_MANDATORY_LOW_RID: u32 = 4096;
pub const SECURITY_MANDATORY_MEDIUM_RID: u32 = 8192;
pub const SECURITY_MANDATORY_MEDIUM_PLUS_RID: u32 = 8448;
pub const SECURITY_MANDATORY_HIGH_RID: u32 = 12288;
pub const SECURITY_MANDATORY_SYSTEM_RID: u32 = 16384;
pub const SECURITY_MANDATORY_PROTECTED_PROCESS_RID: u32 = 20480;
pub const SECURITY_MANDATORY_MAXIMUM_USER_RID: u32 = 16384;
pub const SECURITY_AUTHENTICATION_AUTHORITY_RID_COUNT: u32 = 1;
pub const SECURITY_AUTHENTICATION_AUTHORITY_ASSERTED_RID: u32 = 1;
pub const SECURITY_AUTHENTICATION_SERVICE_ASSERTED_RID: u32 = 2;
pub const SECURITY_AUTHENTICATION_FRESH_KEY_AUTH_RID: u32 = 3;
pub const SECURITY_AUTHENTICATION_KEY_TRUST_RID: u32 = 4;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_MFA_RID: u32 = 5;
pub const SECURITY_AUTHENTICATION_KEY_PROPERTY_ATTESTATION_RID: u32 = 6;
pub const SECURITY_PROCESS_TRUST_AUTHORITY_RID_COUNT: u32 = 2;
pub const SECURITY_PROCESS_PROTECTION_TYPE_FULL_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_TYPE_LITE_RID: u32 = 512;
pub const SECURITY_PROCESS_PROTECTION_TYPE_NONE_RID: u32 = 0;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINTCB_RID: u32 = 8192;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_WINDOWS_RID: u32 = 4096;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_APP_RID: u32 = 2048;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_ANTIMALWARE_RID: u32 = 1536;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_AUTHENTICODE_RID: u32 = 1024;
pub const SECURITY_PROCESS_PROTECTION_LEVEL_NONE_RID: u32 = 0;
pub const SECURITY_TRUSTED_INSTALLER_RID1: u32 = 956008885;
pub const SECURITY_TRUSTED_INSTALLER_RID2: u32 = 3418522649;
pub const SECURITY_TRUSTED_INSTALLER_RID3: u32 = 1831038044;
pub const SECURITY_TRUSTED_INSTALLER_RID4: u32 = 1853292631;
pub const SECURITY_TRUSTED_INSTALLER_RID5: u32 = 2271478464;
pub const SE_GROUP_MANDATORY: u32 = 1;
pub const SE_GROUP_ENABLED_BY_DEFAULT: u32 = 2;
pub const SE_GROUP_ENABLED: u32 = 4;
pub const SE_GROUP_OWNER: u32 = 8;
pub const SE_GROUP_USE_FOR_DENY_ONLY: u32 = 16;
pub const SE_GROUP_INTEGRITY: u32 = 32;
pub const SE_GROUP_INTEGRITY_ENABLED: u32 = 64;
pub const SE_GROUP_LOGON_ID: u32 = 3221225472;
pub const SE_GROUP_RESOURCE: u32 = 536870912;
pub const SE_GROUP_VALID_ATTRIBUTES: u32 = 3758096511;
pub const ACL_REVISION: u32 = 2;
pub const ACL_REVISION_DS: u32 = 4;
pub const ACL_REVISION1: u32 = 1;
pub const ACL_REVISION2: u32 = 2;
pub const ACL_REVISION3: u32 = 3;
pub const ACL_REVISION4: u32 = 4;
pub const MAX_ACL_REVISION: u32 = 4;
pub const ACCESS_MIN_MS_ACE_TYPE: u32 = 0;
pub const ACCESS_ALLOWED_ACE_TYPE: u32 = 0;
pub const ACCESS_DENIED_ACE_TYPE: u32 = 1;
pub const SYSTEM_AUDIT_ACE_TYPE: u32 = 2;
pub const SYSTEM_ALARM_ACE_TYPE: u32 = 3;
pub const ACCESS_MAX_MS_V2_ACE_TYPE: u32 = 3;
pub const ACCESS_ALLOWED_COMPOUND_ACE_TYPE: u32 = 4;
pub const ACCESS_MAX_MS_V3_ACE_TYPE: u32 = 4;
pub const ACCESS_MIN_MS_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_ALLOWED_OBJECT_ACE_TYPE: u32 = 5;
pub const ACCESS_DENIED_OBJECT_ACE_TYPE: u32 = 6;
pub const SYSTEM_AUDIT_OBJECT_ACE_TYPE: u32 = 7;
pub const SYSTEM_ALARM_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_OBJECT_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_V4_ACE_TYPE: u32 = 8;
pub const ACCESS_MAX_MS_ACE_TYPE: u32 = 8;
pub const ACCESS_ALLOWED_CALLBACK_ACE_TYPE: u32 = 9;
pub const ACCESS_DENIED_CALLBACK_ACE_TYPE: u32 = 10;
pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE_TYPE: u32 = 11;
pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE_TYPE: u32 = 12;
pub const SYSTEM_AUDIT_CALLBACK_ACE_TYPE: u32 = 13;
pub const SYSTEM_ALARM_CALLBACK_ACE_TYPE: u32 = 14;
pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE_TYPE: u32 = 15;
pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE_TYPE: u32 = 16;
pub const SYSTEM_MANDATORY_LABEL_ACE_TYPE: u32 = 17;
pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE_TYPE: u32 = 18;
pub const SYSTEM_SCOPED_POLICY_ID_ACE_TYPE: u32 = 19;
pub const SYSTEM_PROCESS_TRUST_LABEL_ACE_TYPE: u32 = 20;
pub const SYSTEM_ACCESS_FILTER_ACE_TYPE: u32 = 21;
pub const ACCESS_MAX_MS_V5_ACE_TYPE: u32 = 21;
pub const OBJECT_INHERIT_ACE: u32 = 1;
pub const CONTAINER_INHERIT_ACE: u32 = 2;
pub const NO_PROPAGATE_INHERIT_ACE: u32 = 4;
pub const INHERIT_ONLY_ACE: u32 = 8;
pub const INHERITED_ACE: u32 = 16;
pub const VALID_INHERIT_FLAGS: u32 = 31;
pub const CRITICAL_ACE_FLAG: u32 = 32;
pub const SUCCESSFUL_ACCESS_ACE_FLAG: u32 = 64;
pub const FAILED_ACCESS_ACE_FLAG: u32 = 128;
pub const TRUST_PROTECTED_FILTER_ACE_FLAG: u32 = 64;
pub const SYSTEM_MANDATORY_LABEL_NO_WRITE_UP: u32 = 1;
pub const SYSTEM_MANDATORY_LABEL_NO_READ_UP: u32 = 2;
pub const SYSTEM_MANDATORY_LABEL_NO_EXECUTE_UP: u32 = 4;
pub const SYSTEM_MANDATORY_LABEL_VALID_MASK: u32 = 7;
pub const SYSTEM_PROCESS_TRUST_LABEL_VALID_MASK: u32 = 16777215;
pub const SYSTEM_PROCESS_TRUST_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const SYSTEM_ACCESS_FILTER_VALID_MASK: u32 = 16777215;
pub const SYSTEM_ACCESS_FILTER_NOCONSTRAINT_MASK: u32 = 4294967295;
pub const ACE_OBJECT_TYPE_PRESENT: u32 = 1;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT: u32 = 2;
pub const SECURITY_DESCRIPTOR_REVISION: u32 = 1;
pub const SECURITY_DESCRIPTOR_REVISION1: u32 = 1;
pub const SE_OWNER_DEFAULTED: u32 = 1;
pub const SE_GROUP_DEFAULTED: u32 = 2;
pub const SE_DACL_PRESENT: u32 = 4;
pub const SE_DACL_DEFAULTED: u32 = 8;
pub const SE_SACL_PRESENT: u32 = 16;
pub const SE_SACL_DEFAULTED: u32 = 32;
pub const SE_DACL_AUTO_INHERIT_REQ: u32 = 256;
pub const SE_SACL_AUTO_INHERIT_REQ: u32 = 512;
pub const SE_DACL_AUTO_INHERITED: u32 = 1024;
pub const SE_SACL_AUTO_INHERITED: u32 = 2048;
pub const SE_DACL_PROTECTED: u32 = 4096;
pub const SE_SACL_PROTECTED: u32 = 8192;
pub const SE_RM_CONTROL_VALID: u32 = 16384;
pub const SE_SELF_RELATIVE: u32 = 32768;
pub const ACCESS_OBJECT_GUID: u32 = 0;
pub const ACCESS_PROPERTY_SET_GUID: u32 = 1;
pub const ACCESS_PROPERTY_GUID: u32 = 2;
pub const ACCESS_MAX_LEVEL: u32 = 4;
pub const AUDIT_ALLOW_NO_PRIVILEGE: u32 = 1;
pub const ACCESS_DS_SOURCE_A: &'static [u8; 3usize] = b"DS\0";
pub const ACCESS_DS_SOURCE_W: &'static [u8; 3usize] = b"DS\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_A: &'static [u8; 25usize] = b"Directory Service Object\0";
pub const ACCESS_DS_OBJECT_TYPE_NAME_W: &'static [u8; 25usize] = b"Directory Service Object\0";
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT: u32 = 1;
pub const SE_PRIVILEGE_ENABLED: u32 = 2;
pub const SE_PRIVILEGE_USED_FOR_ACCESS: u32 = 2147483648;
pub const PRIVILEGE_SET_ALL_NECESSARY: u32 = 1;
pub const ACCESS_REASON_TYPE_MASK: u32 = 16711680;
pub const ACCESS_REASON_DATA_MASK: u32 = 65535;
pub const ACCESS_REASON_STAGING_MASK: u32 = 2147483648;
pub const ACCESS_REASON_EXDATA_MASK: u32 = 2130706432;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_OWNER_ACE: u32 = 1;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_LABEL_ACE: u32 = 2;
pub const SE_SECURITY_DESCRIPTOR_FLAG_NO_ACCESS_FILTER_ACE: u32 = 4;
pub const SE_SECURITY_DESCRIPTOR_VALID_FLAGS: u32 = 7;
pub const SE_ACTIVATE_AS_USER_CAPABILITY: &'static [u8; 15usize] = b"activateAsUser\0";
pub const SE_CONSTRAINED_IMPERSONATION_CAPABILITY: &'static [u8; 25usize] =
    b"constrainedImpersonation\0";
pub const SE_SESSION_IMPERSONATION_CAPABILITY: &'static [u8; 21usize] = b"sessionImpersonation\0";
pub const SE_MUMA_CAPABILITY: &'static [u8; 5usize] = b"muma\0";
pub const SE_DEVELOPMENT_MODE_NETWORK_CAPABILITY: &'static [u8; 23usize] =
    b"developmentModeNetwork\0";
pub const TOKEN_ASSIGN_PRIMARY: u32 = 1;
pub const TOKEN_DUPLICATE: u32 = 2;
pub const TOKEN_IMPERSONATE: u32 = 4;
pub const TOKEN_QUERY: u32 = 8;
pub const TOKEN_QUERY_SOURCE: u32 = 16;
pub const TOKEN_ADJUST_PRIVILEGES: u32 = 32;
pub const TOKEN_ADJUST_GROUPS: u32 = 64;
pub const TOKEN_ADJUST_DEFAULT: u32 = 128;
pub const TOKEN_ADJUST_SESSIONID: u32 = 256;
pub const TOKEN_ALL_ACCESS_P: u32 = 983295;
pub const TOKEN_ALL_ACCESS: u32 = 983551;
pub const TOKEN_READ: u32 = 131080;
pub const TOKEN_WRITE: u32 = 131296;
pub const TOKEN_EXECUTE: u32 = 131072;
pub const TOKEN_TRUST_CONSTRAINT_MASK: u32 = 131096;
pub const TOKEN_ACCESS_PSEUDO_HANDLE_WIN8: u32 = 24;
pub const TOKEN_ACCESS_PSEUDO_HANDLE: u32 = 24;
pub const TOKEN_MANDATORY_POLICY_OFF: u32 = 0;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP: u32 = 1;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN: u32 = 2;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK: u32 = 3;
pub const POLICY_AUDIT_SUBCATEGORY_COUNT: u32 = 59;
pub const TOKEN_SOURCE_LENGTH: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INVALID: u32 = 0;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING: u32 = 3;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID: u32 = 5;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN: u32 = 6;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE: u32 = 2;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY: u32 = 4;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT: u32 = 8;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED: u32 = 16;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY: u32 = 32;
pub const CLAIM_SECURITY_ATTRIBUTE_VALID_FLAGS: u32 = 63;
pub const CLAIM_SECURITY_ATTRIBUTE_CUSTOM_FLAGS: u32 = 4294901760;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION_V1: u32 = 1;
pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION_VERSION: u32 = 1;
pub const SECURITY_DYNAMIC_TRACKING: u32 = 1;
pub const SECURITY_STATIC_TRACKING: u32 = 0;
pub const DISABLE_MAX_PRIVILEGE: u32 = 1;
pub const SANDBOX_INERT: u32 = 2;
pub const LUA_TOKEN: u32 = 4;
pub const WRITE_RESTRICTED: u32 = 8;
pub const OWNER_SECURITY_INFORMATION: u32 = 1;
pub const GROUP_SECURITY_INFORMATION: u32 = 2;
pub const DACL_SECURITY_INFORMATION: u32 = 4;
pub const SACL_SECURITY_INFORMATION: u32 = 8;
pub const LABEL_SECURITY_INFORMATION: u32 = 16;
pub const ATTRIBUTE_SECURITY_INFORMATION: u32 = 32;
pub const SCOPE_SECURITY_INFORMATION: u32 = 64;
pub const PROCESS_TRUST_LABEL_SECURITY_INFORMATION: u32 = 128;
pub const ACCESS_FILTER_SECURITY_INFORMATION: u32 = 256;
pub const BACKUP_SECURITY_INFORMATION: u32 = 65536;
pub const PROTECTED_DACL_SECURITY_INFORMATION: u32 = 2147483648;
pub const PROTECTED_SACL_SECURITY_INFORMATION: u32 = 1073741824;
pub const UNPROTECTED_DACL_SECURITY_INFORMATION: u32 = 536870912;
pub const UNPROTECTED_SACL_SECURITY_INFORMATION: u32 = 268435456;
pub const SE_SIGNING_LEVEL_UNCHECKED: u32 = 0;
pub const SE_SIGNING_LEVEL_UNSIGNED: u32 = 1;
pub const SE_SIGNING_LEVEL_ENTERPRISE: u32 = 2;
pub const SE_SIGNING_LEVEL_CUSTOM_1: u32 = 3;
pub const SE_SIGNING_LEVEL_DEVELOPER: u32 = 3;
pub const SE_SIGNING_LEVEL_AUTHENTICODE: u32 = 4;
pub const SE_SIGNING_LEVEL_CUSTOM_2: u32 = 5;
pub const SE_SIGNING_LEVEL_STORE: u32 = 6;
pub const SE_SIGNING_LEVEL_CUSTOM_3: u32 = 7;
pub const SE_SIGNING_LEVEL_ANTIMALWARE: u32 = 7;
pub const SE_SIGNING_LEVEL_MICROSOFT: u32 = 8;
pub const SE_SIGNING_LEVEL_CUSTOM_4: u32 = 9;
pub const SE_SIGNING_LEVEL_CUSTOM_5: u32 = 10;
pub const SE_SIGNING_LEVEL_DYNAMIC_CODEGEN: u32 = 11;
pub const SE_SIGNING_LEVEL_WINDOWS: u32 = 12;
pub const SE_SIGNING_LEVEL_CUSTOM_7: u32 = 13;
pub const SE_SIGNING_LEVEL_WINDOWS_TCB: u32 = 14;
pub const SE_SIGNING_LEVEL_CUSTOM_6: u32 = 15;
pub const SE_LEARNING_MODE_FLAG_PERMISSIVE: u32 = 1;
pub const PROCESS_TERMINATE: u32 = 1;
pub const PROCESS_CREATE_THREAD: u32 = 2;
pub const PROCESS_SET_SESSIONID: u32 = 4;
pub const PROCESS_VM_OPERATION: u32 = 8;
pub const PROCESS_VM_READ: u32 = 16;
pub const PROCESS_VM_WRITE: u32 = 32;
pub const PROCESS_DUP_HANDLE: u32 = 64;
pub const PROCESS_CREATE_PROCESS: u32 = 128;
pub const PROCESS_SET_QUOTA: u32 = 256;
pub const PROCESS_SET_INFORMATION: u32 = 512;
pub const PROCESS_QUERY_INFORMATION: u32 = 1024;
pub const PROCESS_SUSPEND_RESUME: u32 = 2048;
pub const PROCESS_QUERY_LIMITED_INFORMATION: u32 = 4096;
pub const PROCESS_SET_LIMITED_INFORMATION: u32 = 8192;
pub const PROCESS_ALL_ACCESS: u32 = 2097151;
pub const THREAD_TERMINATE: u32 = 1;
pub const THREAD_SUSPEND_RESUME: u32 = 2;
pub const THREAD_GET_CONTEXT: u32 = 8;
pub const THREAD_SET_CONTEXT: u32 = 16;
pub const THREAD_QUERY_INFORMATION: u32 = 64;
pub const THREAD_SET_INFORMATION: u32 = 32;
pub const THREAD_SET_THREAD_TOKEN: u32 = 128;
pub const THREAD_IMPERSONATE: u32 = 256;
pub const THREAD_DIRECT_IMPERSONATION: u32 = 512;
pub const THREAD_SET_LIMITED_INFORMATION: u32 = 1024;
pub const THREAD_QUERY_LIMITED_INFORMATION: u32 = 2048;
pub const THREAD_RESUME: u32 = 4096;
pub const THREAD_ALL_ACCESS: u32 = 2097151;
pub const JOB_OBJECT_ASSIGN_PROCESS: u32 = 1;
pub const JOB_OBJECT_SET_ATTRIBUTES: u32 = 2;
pub const JOB_OBJECT_QUERY: u32 = 4;
pub const JOB_OBJECT_TERMINATE: u32 = 8;
pub const JOB_OBJECT_SET_SECURITY_ATTRIBUTES: u32 = 16;
pub const JOB_OBJECT_IMPERSONATE: u32 = 32;
pub const JOB_OBJECT_ALL_ACCESS: u32 = 2031679;
pub const FLS_MAXIMUM_AVAILABLE: u32 = 128;
pub const TLS_MINIMUM_AVAILABLE: u32 = 64;
pub const THREAD_DYNAMIC_CODE_ALLOW: u32 = 1;
pub const THREAD_BASE_PRIORITY_LOWRT: u32 = 15;
pub const THREAD_BASE_PRIORITY_MAX: u32 = 2;
pub const THREAD_BASE_PRIORITY_MIN: i32 = -2;
pub const THREAD_BASE_PRIORITY_IDLE: i32 = -15;
pub const MEMORY_PRIORITY_LOWEST: u32 = 0;
pub const MEMORY_PRIORITY_VERY_LOW: u32 = 1;
pub const MEMORY_PRIORITY_LOW: u32 = 2;
pub const MEMORY_PRIORITY_MEDIUM: u32 = 3;
pub const MEMORY_PRIORITY_BELOW_NORMAL: u32 = 4;
pub const MEMORY_PRIORITY_NORMAL: u32 = 5;
pub const QUOTA_LIMITS_HARDWS_MIN_ENABLE: u32 = 1;
pub const QUOTA_LIMITS_HARDWS_MIN_DISABLE: u32 = 2;
pub const QUOTA_LIMITS_HARDWS_MAX_ENABLE: u32 = 4;
pub const QUOTA_LIMITS_HARDWS_MAX_DISABLE: u32 = 8;
pub const QUOTA_LIMITS_USE_DEFAULT_LIMITS: u32 = 16;
pub const MAX_HW_COUNTERS: u32 = 16;
pub const THREAD_PROFILING_FLAG_DISPATCH: u32 = 1;
pub const JOB_OBJECT_NET_RATE_CONTROL_MAX_DSCP_TAG: u32 = 64;
pub const JOB_OBJECT_TERMINATE_AT_END_OF_JOB: u32 = 0;
pub const JOB_OBJECT_POST_AT_END_OF_JOB: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_JOB_TIME: u32 = 1;
pub const JOB_OBJECT_MSG_END_OF_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_LIMIT: u32 = 3;
pub const JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO: u32 = 4;
pub const JOB_OBJECT_MSG_NEW_PROCESS: u32 = 6;
pub const JOB_OBJECT_MSG_EXIT_PROCESS: u32 = 7;
pub const JOB_OBJECT_MSG_ABNORMAL_EXIT_PROCESS: u32 = 8;
pub const JOB_OBJECT_MSG_PROCESS_MEMORY_LIMIT: u32 = 9;
pub const JOB_OBJECT_MSG_JOB_MEMORY_LIMIT: u32 = 10;
pub const JOB_OBJECT_MSG_NOTIFICATION_LIMIT: u32 = 11;
pub const JOB_OBJECT_MSG_JOB_CYCLE_TIME_LIMIT: u32 = 12;
pub const JOB_OBJECT_MSG_SILO_TERMINATED: u32 = 13;
pub const JOB_OBJECT_MSG_MINIMUM: u32 = 1;
pub const JOB_OBJECT_MSG_MAXIMUM: u32 = 13;
pub const JOB_OBJECT_VALID_COMPLETION_FILTER: u32 = 16382;
pub const JOB_OBJECT_LIMIT_WORKINGSET: u32 = 1;
pub const JOB_OBJECT_LIMIT_PROCESS_TIME: u32 = 2;
pub const JOB_OBJECT_LIMIT_JOB_TIME: u32 = 4;
pub const JOB_OBJECT_LIMIT_ACTIVE_PROCESS: u32 = 8;
pub const JOB_OBJECT_LIMIT_AFFINITY: u32 = 16;
pub const JOB_OBJECT_LIMIT_PRIORITY_CLASS: u32 = 32;
pub const JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME: u32 = 64;
pub const JOB_OBJECT_LIMIT_SCHEDULING_CLASS: u32 = 128;
pub const JOB_OBJECT_LIMIT_PROCESS_MEMORY: u32 = 256;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY: u32 = 512;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_HIGH: u32 = 512;
pub const JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION: u32 = 1024;
pub const JOB_OBJECT_LIMIT_BREAKAWAY_OK: u32 = 2048;
pub const JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK: u32 = 4096;
pub const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: u32 = 8192;
pub const JOB_OBJECT_LIMIT_SUBSET_AFFINITY: u32 = 16384;
pub const JOB_OBJECT_LIMIT_JOB_MEMORY_LOW: u32 = 32768;
pub const JOB_OBJECT_LIMIT_JOB_READ_BYTES: u32 = 65536;
pub const JOB_OBJECT_LIMIT_JOB_WRITE_BYTES: u32 = 131072;
pub const JOB_OBJECT_LIMIT_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_CPU_RATE_CONTROL: u32 = 262144;
pub const JOB_OBJECT_LIMIT_IO_RATE_CONTROL: u32 = 524288;
pub const JOB_OBJECT_LIMIT_NET_RATE_CONTROL: u32 = 1048576;
pub const JOB_OBJECT_LIMIT_VALID_FLAGS: u32 = 524287;
pub const JOB_OBJECT_BASIC_LIMIT_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_EXTENDED_LIMIT_VALID_FLAGS: u32 = 32767;
pub const JOB_OBJECT_NOTIFICATION_LIMIT_VALID_FLAGS: u32 = 2064900;
pub const JOB_OBJECT_UILIMIT_NONE: u32 = 0;
pub const JOB_OBJECT_UILIMIT_HANDLES: u32 = 1;
pub const JOB_OBJECT_UILIMIT_READCLIPBOARD: u32 = 2;
pub const JOB_OBJECT_UILIMIT_WRITECLIPBOARD: u32 = 4;
pub const JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS: u32 = 8;
pub const JOB_OBJECT_UILIMIT_DISPLAYSETTINGS: u32 = 16;
pub const JOB_OBJECT_UILIMIT_GLOBALATOMS: u32 = 32;
pub const JOB_OBJECT_UILIMIT_DESKTOP: u32 = 64;
pub const JOB_OBJECT_UILIMIT_EXITWINDOWS: u32 = 128;
pub const JOB_OBJECT_UILIMIT_ALL: u32 = 255;
pub const JOB_OBJECT_UI_VALID_FLAGS: u32 = 255;
pub const JOB_OBJECT_SECURITY_NO_ADMIN: u32 = 1;
pub const JOB_OBJECT_SECURITY_RESTRICTED_TOKEN: u32 = 2;
pub const JOB_OBJECT_SECURITY_ONLY_TOKEN: u32 = 4;
pub const JOB_OBJECT_SECURITY_FILTER_TOKENS: u32 = 8;
pub const JOB_OBJECT_SECURITY_VALID_FLAGS: u32 = 15;
pub const JOB_OBJECT_CPU_RATE_CONTROL_ENABLE: u32 = 1;
pub const JOB_OBJECT_CPU_RATE_CONTROL_WEIGHT_BASED: u32 = 2;
pub const JOB_OBJECT_CPU_RATE_CONTROL_HARD_CAP: u32 = 4;
pub const JOB_OBJECT_CPU_RATE_CONTROL_NOTIFY: u32 = 8;
pub const JOB_OBJECT_CPU_RATE_CONTROL_MIN_MAX_RATE: u32 = 16;
pub const JOB_OBJECT_CPU_RATE_CONTROL_VALID_FLAGS: u32 = 31;
pub const EVENT_MODIFY_STATE: u32 = 2;
pub const EVENT_ALL_ACCESS: u32 = 2031619;
pub const MUTANT_QUERY_STATE: u32 = 1;
pub const MUTANT_ALL_ACCESS: u32 = 2031617;
pub const SEMAPHORE_MODIFY_STATE: u32 = 2;
pub const SEMAPHORE_ALL_ACCESS: u32 = 2031619;
pub const TIMER_QUERY_STATE: u32 = 1;
pub const TIMER_MODIFY_STATE: u32 = 2;
pub const TIMER_ALL_ACCESS: u32 = 2031619;
pub const TIME_ZONE_ID_UNKNOWN: u32 = 0;
pub const TIME_ZONE_ID_STANDARD: u32 = 1;
pub const TIME_ZONE_ID_DAYLIGHT: u32 = 2;
pub const LTP_PC_SMT: u32 = 1;
pub const CACHE_FULLY_ASSOCIATIVE: u32 = 255;
pub const SYSTEM_CPU_SET_INFORMATION_PARKED: u32 = 1;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED: u32 = 2;
pub const SYSTEM_CPU_SET_INFORMATION_ALLOCATED_TO_TARGET_PROCESS: u32 = 4;
pub const SYSTEM_CPU_SET_INFORMATION_REALTIME: u32 = 8;
pub const PROCESSOR_INTEL_386: u32 = 386;
pub const PROCESSOR_INTEL_486: u32 = 486;
pub const PROCESSOR_INTEL_PENTIUM: u32 = 586;
pub const PROCESSOR_INTEL_IA64: u32 = 2200;
pub const PROCESSOR_AMD_X8664: u32 = 8664;
pub const PROCESSOR_MIPS_R4000: u32 = 4000;
pub const PROCESSOR_ALPHA_21064: u32 = 21064;
pub const PROCESSOR_PPC_601: u32 = 601;
pub const PROCESSOR_PPC_603: u32 = 603;
pub const PROCESSOR_PPC_604: u32 = 604;
pub const PROCESSOR_PPC_620: u32 = 620;
pub const PROCESSOR_HITACHI_SH3: u32 = 10003;
pub const PROCESSOR_HITACHI_SH3E: u32 = 10004;
pub const PROCESSOR_HITACHI_SH4: u32 = 10005;
pub const PROCESSOR_MOTOROLA_821: u32 = 821;
pub const PROCESSOR_SHx_SH3: u32 = 103;
pub const PROCESSOR_SHx_SH4: u32 = 104;
pub const PROCESSOR_STRONGARM: u32 = 2577;
pub const PROCESSOR_ARM720: u32 = 1824;
pub const PROCESSOR_ARM820: u32 = 2080;
pub const PROCESSOR_ARM920: u32 = 2336;
pub const PROCESSOR_ARM_7TDMI: u32 = 70001;
pub const PROCESSOR_OPTIL: u32 = 18767;
pub const PROCESSOR_ARCHITECTURE_INTEL: u32 = 0;
pub const PROCESSOR_ARCHITECTURE_MIPS: u32 = 1;
pub const PROCESSOR_ARCHITECTURE_ALPHA: u32 = 2;
pub const PROCESSOR_ARCHITECTURE_PPC: u32 = 3;
pub const PROCESSOR_ARCHITECTURE_SHX: u32 = 4;
pub const PROCESSOR_ARCHITECTURE_ARM: u32 = 5;
pub const PROCESSOR_ARCHITECTURE_IA64: u32 = 6;
pub const PROCESSOR_ARCHITECTURE_ALPHA64: u32 = 7;
pub const PROCESSOR_ARCHITECTURE_MSIL: u32 = 8;
pub const PROCESSOR_ARCHITECTURE_AMD64: u32 = 9;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: u32 = 10;
pub const PROCESSOR_ARCHITECTURE_NEUTRAL: u32 = 11;
pub const PROCESSOR_ARCHITECTURE_ARM64: u32 = 12;
pub const PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64: u32 = 13;
pub const PROCESSOR_ARCHITECTURE_IA32_ON_ARM64: u32 = 14;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN: u32 = 65535;
pub const PF_FLOATING_POINT_PRECISION_ERRATA: u32 = 0;
pub const PF_FLOATING_POINT_EMULATED: u32 = 1;
pub const PF_COMPARE_EXCHANGE_DOUBLE: u32 = 2;
pub const PF_MMX_INSTRUCTIONS_AVAILABLE: u32 = 3;
pub const PF_PPC_MOVEMEM_64BIT_OK: u32 = 4;
pub const PF_ALPHA_BYTE_INSTRUCTIONS: u32 = 5;
pub const PF_XMMI_INSTRUCTIONS_AVAILABLE: u32 = 6;
pub const PF_3DNOW_INSTRUCTIONS_AVAILABLE: u32 = 7;
pub const PF_RDTSC_INSTRUCTION_AVAILABLE: u32 = 8;
pub const PF_PAE_ENABLED: u32 = 9;
pub const PF_XMMI64_INSTRUCTIONS_AVAILABLE: u32 = 10;
pub const PF_SSE_DAZ_MODE_AVAILABLE: u32 = 11;
pub const PF_NX_ENABLED: u32 = 12;
pub const PF_SSE3_INSTRUCTIONS_AVAILABLE: u32 = 13;
pub const PF_COMPARE_EXCHANGE128: u32 = 14;
pub const PF_COMPARE64_EXCHANGE128: u32 = 15;
pub const PF_CHANNELS_ENABLED: u32 = 16;
pub const PF_XSAVE_ENABLED: u32 = 17;
pub const PF_ARM_VFP_32_REGISTERS_AVAILABLE: u32 = 18;
pub const PF_ARM_NEON_INSTRUCTIONS_AVAILABLE: u32 = 19;
pub const PF_SECOND_LEVEL_ADDRESS_TRANSLATION: u32 = 20;
pub const PF_VIRT_FIRMWARE_ENABLED: u32 = 21;
pub const PF_RDWRFSGSBASE_AVAILABLE: u32 = 22;
pub const PF_FASTFAIL_AVAILABLE: u32 = 23;
pub const PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE: u32 = 24;
pub const PF_ARM_64BIT_LOADSTORE_ATOMIC: u32 = 25;
pub const PF_ARM_EXTERNAL_CACHE_AVAILABLE: u32 = 26;
pub const PF_ARM_FMAC_INSTRUCTIONS_AVAILABLE: u32 = 27;
pub const PF_RDRAND_INSTRUCTION_AVAILABLE: u32 = 28;
pub const PF_ARM_V8_INSTRUCTIONS_AVAILABLE: u32 = 29;
pub const PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE: u32 = 30;
pub const PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE: u32 = 31;
pub const PF_RDTSCP_INSTRUCTION_AVAILABLE: u32 = 32;
pub const PF_RDPID_INSTRUCTION_AVAILABLE: u32 = 33;
pub const XSTATE_LEGACY_FLOATING_POINT: u32 = 0;
pub const XSTATE_LEGACY_SSE: u32 = 1;
pub const XSTATE_GSSE: u32 = 2;
pub const XSTATE_AVX: u32 = 2;
pub const XSTATE_MPX_BNDREGS: u32 = 3;
pub const XSTATE_MPX_BNDCSR: u32 = 4;
pub const XSTATE_AVX512_KMASK: u32 = 5;
pub const XSTATE_AVX512_ZMM_H: u32 = 6;
pub const XSTATE_AVX512_ZMM: u32 = 7;
pub const XSTATE_IPT: u32 = 8;
pub const XSTATE_CET_U: u32 = 11;
pub const XSTATE_LWP: u32 = 62;
pub const MAXIMUM_XSTATE_FEATURES: u32 = 64;
pub const XSTATE_COMPACTION_ENABLE: u32 = 63;
pub const XSTATE_ALIGN_BIT: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEOPT_MASK: u32 = 1;
pub const XSTATE_CONTROLFLAG_XSAVEC_MASK: u32 = 2;
pub const XSTATE_CONTROLFLAG_VALID_MASK: u32 = 3;
pub const CFG_CALL_TARGET_VALID: u32 = 1;
pub const CFG_CALL_TARGET_PROCESSED: u32 = 2;
pub const CFG_CALL_TARGET_CONVERT_EXPORT_SUPPRESSED_TO_VALID: u32 = 4;
pub const SECTION_QUERY: u32 = 1;
pub const SECTION_MAP_WRITE: u32 = 2;
pub const SECTION_MAP_READ: u32 = 4;
pub const SECTION_MAP_EXECUTE: u32 = 8;
pub const SECTION_EXTEND_SIZE: u32 = 16;
pub const SECTION_MAP_EXECUTE_EXPLICIT: u32 = 32;
pub const SECTION_ALL_ACCESS: u32 = 983071;
pub const SESSION_QUERY_ACCESS: u32 = 1;
pub const SESSION_MODIFY_ACCESS: u32 = 2;
pub const SESSION_ALL_ACCESS: u32 = 983043;
pub const PAGE_NOACCESS: u32 = 1;
pub const PAGE_READONLY: u32 = 2;
pub const PAGE_READWRITE: u32 = 4;
pub const PAGE_WRITECOPY: u32 = 8;
pub const PAGE_EXECUTE: u32 = 16;
pub const PAGE_EXECUTE_READ: u32 = 32;
pub const PAGE_EXECUTE_READWRITE: u32 = 64;
pub const PAGE_EXECUTE_WRITECOPY: u32 = 128;
pub const PAGE_GUARD: u32 = 256;
pub const PAGE_NOCACHE: u32 = 512;
pub const PAGE_WRITECOMBINE: u32 = 1024;
pub const PAGE_ENCLAVE_THREAD_CONTROL: u32 = 2147483648;
pub const PAGE_REVERT_TO_FILE_MAP: u32 = 2147483648;
pub const PAGE_TARGETS_NO_UPDATE: u32 = 1073741824;
pub const PAGE_TARGETS_INVALID: u32 = 1073741824;
pub const PAGE_ENCLAVE_UNVALIDATED: u32 = 536870912;
pub const PAGE_ENCLAVE_DECOMMIT: u32 = 268435456;
pub const MEM_COMMIT: u32 = 4096;
pub const MEM_RESERVE: u32 = 8192;
pub const MEM_REPLACE_PLACEHOLDER: u32 = 16384;
pub const MEM_RESERVE_PLACEHOLDER: u32 = 262144;
pub const MEM_RESET: u32 = 524288;
pub const MEM_TOP_DOWN: u32 = 1048576;
pub const MEM_WRITE_WATCH: u32 = 2097152;
pub const MEM_PHYSICAL: u32 = 4194304;
pub const MEM_ROTATE: u32 = 8388608;
pub const MEM_DIFFERENT_IMAGE_BASE_OK: u32 = 8388608;
pub const MEM_RESET_UNDO: u32 = 16777216;
pub const MEM_LARGE_PAGES: u32 = 536870912;
pub const MEM_4MB_PAGES: u32 = 2147483648;
pub const MEM_64K_PAGES: u32 = 541065216;
pub const MEM_UNMAP_WITH_TRANSIENT_BOOST: u32 = 1;
pub const MEM_COALESCE_PLACEHOLDERS: u32 = 1;
pub const MEM_PRESERVE_PLACEHOLDER: u32 = 2;
pub const MEM_DECOMMIT: u32 = 16384;
pub const MEM_RELEASE: u32 = 32768;
pub const MEM_FREE: u32 = 65536;
pub const MEM_EXTENDED_PARAMETER_GRAPHICS: u32 = 1;
pub const MEM_EXTENDED_PARAMETER_TYPE_BITS: u32 = 8;
pub const SEC_PARTITION_OWNER_HANDLE: u32 = 262144;
pub const SEC_64K_PAGES: u32 = 524288;
pub const SEC_FILE: u32 = 8388608;
pub const SEC_IMAGE: u32 = 16777216;
pub const SEC_PROTECTED_IMAGE: u32 = 33554432;
pub const SEC_RESERVE: u32 = 67108864;
pub const SEC_COMMIT: u32 = 134217728;
pub const SEC_NOCACHE: u32 = 268435456;
pub const SEC_WRITECOMBINE: u32 = 1073741824;
pub const SEC_LARGE_PAGES: u32 = 2147483648;
pub const SEC_IMAGE_NO_EXECUTE: u32 = 285212672;
pub const MEM_PRIVATE: u32 = 131072;
pub const MEM_MAPPED: u32 = 262144;
pub const MEM_IMAGE: u32 = 16777216;
pub const WRITE_WATCH_FLAG_RESET: u32 = 1;
pub const ENCLAVE_TYPE_SGX: u32 = 1;
pub const ENCLAVE_TYPE_SGX2: u32 = 2;
pub const ENCLAVE_TYPE_VBS: u32 = 16;
pub const ENCLAVE_VBS_FLAG_DEBUG: u32 = 1;
pub const FILE_READ_DATA: u32 = 1;
pub const FILE_LIST_DIRECTORY: u32 = 1;
pub const FILE_WRITE_DATA: u32 = 2;
pub const FILE_ADD_FILE: u32 = 2;
pub const FILE_APPEND_DATA: u32 = 4;
pub const FILE_ADD_SUBDIRECTORY: u32 = 4;
pub const FILE_CREATE_PIPE_INSTANCE: u32 = 4;
pub const FILE_READ_EA: u32 = 8;
pub const FILE_WRITE_EA: u32 = 16;
pub const FILE_EXECUTE: u32 = 32;
pub const FILE_TRAVERSE: u32 = 32;
pub const FILE_DELETE_CHILD: u32 = 64;
pub const FILE_READ_ATTRIBUTES: u32 = 128;
pub const FILE_WRITE_ATTRIBUTES: u32 = 256;
pub const FILE_ALL_ACCESS: u32 = 2032127;
pub const FILE_GENERIC_READ: u32 = 1179785;
pub const FILE_GENERIC_WRITE: u32 = 1179926;
pub const FILE_GENERIC_EXECUTE: u32 = 1179808;
pub const FILE_SHARE_READ: u32 = 1;
pub const FILE_SHARE_WRITE: u32 = 2;
pub const FILE_SHARE_DELETE: u32 = 4;
pub const FILE_ATTRIBUTE_READONLY: u32 = 1;
pub const FILE_ATTRIBUTE_HIDDEN: u32 = 2;
pub const FILE_ATTRIBUTE_SYSTEM: u32 = 4;
pub const FILE_ATTRIBUTE_DIRECTORY: u32 = 16;
pub const FILE_ATTRIBUTE_ARCHIVE: u32 = 32;
pub const FILE_ATTRIBUTE_DEVICE: u32 = 64;
pub const FILE_ATTRIBUTE_NORMAL: u32 = 128;
pub const FILE_ATTRIBUTE_TEMPORARY: u32 = 256;
pub const FILE_ATTRIBUTE_SPARSE_FILE: u32 = 512;
pub const FILE_ATTRIBUTE_REPARSE_POINT: u32 = 1024;
pub const FILE_ATTRIBUTE_COMPRESSED: u32 = 2048;
pub const FILE_ATTRIBUTE_OFFLINE: u32 = 4096;
pub const FILE_ATTRIBUTE_NOT_CONTENT_INDEXED: u32 = 8192;
pub const FILE_ATTRIBUTE_ENCRYPTED: u32 = 16384;
pub const FILE_ATTRIBUTE_INTEGRITY_STREAM: u32 = 32768;
pub const FILE_ATTRIBUTE_VIRTUAL: u32 = 65536;
pub const FILE_ATTRIBUTE_NO_SCRUB_DATA: u32 = 131072;
pub const FILE_ATTRIBUTE_EA: u32 = 262144;
pub const FILE_ATTRIBUTE_PINNED: u32 = 524288;
pub const FILE_ATTRIBUTE_UNPINNED: u32 = 1048576;
pub const FILE_ATTRIBUTE_RECALL_ON_OPEN: u32 = 262144;
pub const FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS: u32 = 4194304;
pub const TREE_CONNECT_ATTRIBUTE_PRIVACY: u32 = 16384;
pub const TREE_CONNECT_ATTRIBUTE_INTEGRITY: u32 = 32768;
pub const TREE_CONNECT_ATTRIBUTE_GLOBAL: u32 = 4;
pub const TREE_CONNECT_ATTRIBUTE_PINNED: u32 = 2;
pub const FILE_ATTRIBUTE_STRICTLY_SEQUENTIAL: u32 = 536870912;
pub const FILE_NOTIFY_CHANGE_FILE_NAME: u32 = 1;
pub const FILE_NOTIFY_CHANGE_DIR_NAME: u32 = 2;
pub const FILE_NOTIFY_CHANGE_ATTRIBUTES: u32 = 4;
pub const FILE_NOTIFY_CHANGE_SIZE: u32 = 8;
pub const FILE_NOTIFY_CHANGE_LAST_WRITE: u32 = 16;
pub const FILE_NOTIFY_CHANGE_LAST_ACCESS: u32 = 32;
pub const FILE_NOTIFY_CHANGE_CREATION: u32 = 64;
pub const FILE_NOTIFY_CHANGE_SECURITY: u32 = 256;
pub const FILE_ACTION_ADDED: u32 = 1;
pub const FILE_ACTION_REMOVED: u32 = 2;
pub const FILE_ACTION_MODIFIED: u32 = 3;
pub const FILE_ACTION_RENAMED_OLD_NAME: u32 = 4;
pub const FILE_ACTION_RENAMED_NEW_NAME: u32 = 5;
pub const FILE_CASE_SENSITIVE_SEARCH: u32 = 1;
pub const FILE_CASE_PRESERVED_NAMES: u32 = 2;
pub const FILE_UNICODE_ON_DISK: u32 = 4;
pub const FILE_PERSISTENT_ACLS: u32 = 8;
pub const FILE_FILE_COMPRESSION: u32 = 16;
pub const FILE_VOLUME_QUOTAS: u32 = 32;
pub const FILE_SUPPORTS_SPARSE_FILES: u32 = 64;
pub const FILE_SUPPORTS_REPARSE_POINTS: u32 = 128;
pub const FILE_SUPPORTS_REMOTE_STORAGE: u32 = 256;
pub const FILE_RETURNS_CLEANUP_RESULT_INFO: u32 = 512;
pub const FILE_SUPPORTS_POSIX_UNLINK_RENAME: u32 = 1024;
pub const FILE_VOLUME_IS_COMPRESSED: u32 = 32768;
pub const FILE_SUPPORTS_OBJECT_IDS: u32 = 65536;
pub const FILE_SUPPORTS_ENCRYPTION: u32 = 131072;
pub const FILE_NAMED_STREAMS: u32 = 262144;
pub const FILE_READ_ONLY_VOLUME: u32 = 524288;
pub const FILE_SEQUENTIAL_WRITE_ONCE: u32 = 1048576;
pub const FILE_SUPPORTS_TRANSACTIONS: u32 = 2097152;
pub const FILE_SUPPORTS_HARD_LINKS: u32 = 4194304;
pub const FILE_SUPPORTS_EXTENDED_ATTRIBUTES: u32 = 8388608;
pub const FILE_SUPPORTS_OPEN_BY_FILE_ID: u32 = 16777216;
pub const FILE_SUPPORTS_USN_JOURNAL: u32 = 33554432;
pub const FILE_SUPPORTS_INTEGRITY_STREAMS: u32 = 67108864;
pub const FILE_SUPPORTS_BLOCK_REFCOUNTING: u32 = 134217728;
pub const FILE_SUPPORTS_SPARSE_VDL: u32 = 268435456;
pub const FILE_DAX_VOLUME: u32 = 536870912;
pub const FILE_SUPPORTS_GHOSTING: u32 = 1073741824;
pub const FLUSH_FLAGS_FILE_DATA_ONLY: u32 = 1;
pub const FLUSH_FLAGS_NO_SYNC: u32 = 2;
pub const FLUSH_FLAGS_FILE_DATA_SYNC_ONLY: u32 = 4;
pub const MAXIMUM_REPARSE_DATA_BUFFER_SIZE: u32 = 16384;
pub const IO_REPARSE_TAG_RESERVED_ZERO: u32 = 0;
pub const IO_REPARSE_TAG_RESERVED_ONE: u32 = 1;
pub const IO_REPARSE_TAG_RESERVED_TWO: u32 = 2;
pub const IO_REPARSE_TAG_RESERVED_RANGE: u32 = 2;
pub const IO_REPARSE_TAG_MOUNT_POINT: u32 = 2684354563;
pub const IO_REPARSE_TAG_HSM: u32 = 3221225476;
pub const IO_REPARSE_TAG_HSM2: u32 = 2147483654;
pub const IO_REPARSE_TAG_SIS: u32 = 2147483655;
pub const IO_REPARSE_TAG_WIM: u32 = 2147483656;
pub const IO_REPARSE_TAG_CSV: u32 = 2147483657;
pub const IO_REPARSE_TAG_DFS: u32 = 2147483658;
pub const IO_REPARSE_TAG_SYMLINK: u32 = 2684354572;
pub const IO_REPARSE_TAG_DFSR: u32 = 2147483666;
pub const IO_REPARSE_TAG_DEDUP: u32 = 2147483667;
pub const IO_REPARSE_TAG_NFS: u32 = 2147483668;
pub const IO_REPARSE_TAG_FILE_PLACEHOLDER: u32 = 2147483669;
pub const IO_REPARSE_TAG_WOF: u32 = 2147483671;
pub const IO_REPARSE_TAG_WCI: u32 = 2147483672;
pub const IO_REPARSE_TAG_WCI_1: u32 = 2415923224;
pub const IO_REPARSE_TAG_GLOBAL_REPARSE: u32 = 2684354585;
pub const IO_REPARSE_TAG_CLOUD: u32 = 2415919130;
pub const IO_REPARSE_TAG_CLOUD_1: u32 = 2415923226;
pub const IO_REPARSE_TAG_CLOUD_2: u32 = 2415927322;
pub const IO_REPARSE_TAG_CLOUD_3: u32 = 2415931418;
pub const IO_REPARSE_TAG_CLOUD_4: u32 = 2415935514;
pub const IO_REPARSE_TAG_CLOUD_5: u32 = 2415939610;
pub const IO_REPARSE_TAG_CLOUD_6: u32 = 2415943706;
pub const IO_REPARSE_TAG_CLOUD_7: u32 = 2415947802;
pub const IO_REPARSE_TAG_CLOUD_8: u32 = 2415951898;
pub const IO_REPARSE_TAG_CLOUD_9: u32 = 2415955994;
pub const IO_REPARSE_TAG_CLOUD_A: u32 = 2415960090;
pub const IO_REPARSE_TAG_CLOUD_B: u32 = 2415964186;
pub const IO_REPARSE_TAG_CLOUD_C: u32 = 2415968282;
pub const IO_REPARSE_TAG_CLOUD_D: u32 = 2415972378;
pub const IO_REPARSE_TAG_CLOUD_E: u32 = 2415976474;
pub const IO_REPARSE_TAG_CLOUD_F: u32 = 2415980570;
pub const IO_REPARSE_TAG_CLOUD_MASK: u32 = 61440;
pub const IO_REPARSE_TAG_APPEXECLINK: u32 = 2147483675;
pub const IO_REPARSE_TAG_PROJFS: u32 = 2415919132;
pub const IO_REPARSE_TAG_STORAGE_SYNC: u32 = 2147483678;
pub const IO_REPARSE_TAG_WCI_TOMBSTONE: u32 = 2684354591;
pub const IO_REPARSE_TAG_UNHANDLED: u32 = 2147483680;
pub const IO_REPARSE_TAG_ONEDRIVE: u32 = 2147483681;
pub const IO_REPARSE_TAG_PROJFS_TOMBSTONE: u32 = 2684354594;
pub const IO_REPARSE_TAG_AF_UNIX: u32 = 2147483683;
pub const SCRUB_DATA_INPUT_FLAG_RESUME: u32 = 1;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_IN_SYNC: u32 = 2;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_NON_INTEGRITY_DATA: u32 = 4;
pub const SCRUB_DATA_INPUT_FLAG_IGNORE_REDUNDANCY: u32 = 8;
pub const SCRUB_DATA_INPUT_FLAG_SKIP_DATA: u32 = 16;
pub const SCRUB_DATA_INPUT_FLAG_SCRUB_BY_OBJECT_ID: u32 = 32;
pub const SCRUB_DATA_OUTPUT_FLAG_INCOMPLETE: u32 = 1;
pub const SCRUB_DATA_OUTPUT_FLAG_NON_USER_DATA_RANGE: u32 = 65536;
pub const SCRUB_DATA_OUTPUT_FLAG_PARITY_EXTENT_DATA_RETURNED: u32 = 131072;
pub const SCRUB_DATA_OUTPUT_FLAG_RESUME_CONTEXT_LENGTH_SPECIFIED: u32 = 262144;
pub const SHUFFLE_FILE_FLAG_SKIP_INITIALIZING_NEW_CLUSTERS: u32 = 1;
pub const IO_COMPLETION_MODIFY_STATE: u32 = 2;
pub const IO_COMPLETION_ALL_ACCESS: u32 = 2031619;
pub const IO_QOS_MAX_RESERVATION: u32 = 1000000000;
pub const SMB_CCF_APP_INSTANCE_EA_NAME: &'static [u8; 29usize] = b"ClusteredApplicationInstance\0";
pub const NETWORK_APP_INSTANCE_CSV_FLAGS_VALID_ONLY_IF_CSV_COORDINATOR: u32 = 1;
pub const DUPLICATE_CLOSE_SOURCE: u32 = 1;
pub const DUPLICATE_SAME_ACCESS: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_INDEX_SLEEP: u32 = 1;
pub const POWERBUTTON_ACTION_INDEX_HIBERNATE: u32 = 2;
pub const POWERBUTTON_ACTION_INDEX_SHUTDOWN: u32 = 3;
pub const POWERBUTTON_ACTION_INDEX_TURN_OFF_THE_DISPLAY: u32 = 4;
pub const POWERBUTTON_ACTION_VALUE_NOTHING: u32 = 0;
pub const POWERBUTTON_ACTION_VALUE_SLEEP: u32 = 2;
pub const POWERBUTTON_ACTION_VALUE_HIBERNATE: u32 = 3;
pub const POWERBUTTON_ACTION_VALUE_SHUTDOWN: u32 = 6;
pub const POWERBUTTON_ACTION_VALUE_TURN_OFF_THE_DISPLAY: u32 = 8;
pub const PERFSTATE_POLICY_CHANGE_IDEAL: u32 = 0;
pub const PERFSTATE_POLICY_CHANGE_SINGLE: u32 = 1;
pub const PERFSTATE_POLICY_CHANGE_ROCKET: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_IDEAL_AGGRESSIVE: u32 = 3;
pub const PERFSTATE_POLICY_CHANGE_DECREASE_MAX: u32 = 2;
pub const PERFSTATE_POLICY_CHANGE_INCREASE_MAX: u32 = 3;
pub const PROCESSOR_THROTTLE_DISABLED: u32 = 0;
pub const PROCESSOR_THROTTLE_ENABLED: u32 = 1;
pub const PROCESSOR_THROTTLE_AUTOMATIC: u32 = 2;
pub const PROCESSOR_PERF_BOOST_POLICY_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_POLICY_MAX: u32 = 100;
pub const PROCESSOR_PERF_BOOST_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_BOOST_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE: u32 = 2;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_ENABLED: u32 = 3;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE: u32 = 4;
pub const PROCESSOR_PERF_BOOST_MODE_AGGRESSIVE_AT_GUARANTEED: u32 = 5;
pub const PROCESSOR_PERF_BOOST_MODE_EFFICIENT_AGGRESSIVE_AT_GUARANTEED: u32 = 6;
pub const PROCESSOR_PERF_BOOST_MODE_MAX: u32 = 6;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_DISABLED: u32 = 0;
pub const PROCESSOR_PERF_AUTONOMOUS_MODE_ENABLED: u32 = 1;
pub const PROCESSOR_PERF_PERFORMANCE_PREFERENCE: u32 = 255;
pub const PROCESSOR_PERF_ENERGY_PREFERENCE: u32 = 0;
pub const PROCESSOR_PERF_MINIMUM_ACTIVITY_WINDOW: u32 = 0;
pub const PROCESSOR_PERF_MAXIMUM_ACTIVITY_WINDOW: u32 = 1270000000;
pub const PROCESSOR_DUTY_CYCLING_DISABLED: u32 = 0;
pub const PROCESSOR_DUTY_CYCLING_ENABLED: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_IDEAL: u32 = 0;
pub const CORE_PARKING_POLICY_CHANGE_SINGLE: u32 = 1;
pub const CORE_PARKING_POLICY_CHANGE_ROCKET: u32 = 2;
pub const CORE_PARKING_POLICY_CHANGE_MULTISTEP: u32 = 3;
pub const CORE_PARKING_POLICY_CHANGE_MAX: u32 = 3;
pub const POWER_DEVICE_IDLE_POLICY_PERFORMANCE: u32 = 0;
pub const POWER_DEVICE_IDLE_POLICY_CONSERVATIVE: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_DISABLED: u32 = 0;
pub const POWER_CONNECTIVITY_IN_STANDBY_ENABLED: u32 = 1;
pub const POWER_CONNECTIVITY_IN_STANDBY_SYSTEM_MANAGED: u32 = 2;
pub const POWER_DISCONNECTED_STANDBY_MODE_NORMAL: u32 = 0;
pub const POWER_DISCONNECTED_STANDBY_MODE_AGGRESSIVE: u32 = 1;
pub const POWER_SYSTEM_MAXIMUM: u32 = 7;
pub const DIAGNOSTIC_REASON_VERSION: u32 = 0;
pub const DIAGNOSTIC_REASON_SIMPLE_STRING: u32 = 1;
pub const DIAGNOSTIC_REASON_DETAILED_STRING: u32 = 2;
pub const DIAGNOSTIC_REASON_NOT_SPECIFIED: u32 = 2147483648;
pub const DIAGNOSTIC_REASON_INVALID_FLAGS: i64 = -2147483656;
pub const POWER_REQUEST_CONTEXT_VERSION: u32 = 0;
pub const POWER_REQUEST_CONTEXT_SIMPLE_STRING: u32 = 1;
pub const POWER_REQUEST_CONTEXT_DETAILED_STRING: u32 = 2;
pub const PDCAP_D0_SUPPORTED: u32 = 1;
pub const PDCAP_D1_SUPPORTED: u32 = 2;
pub const PDCAP_D2_SUPPORTED: u32 = 4;
pub const PDCAP_D3_SUPPORTED: u32 = 8;
pub const PDCAP_WAKE_FROM_D0_SUPPORTED: u32 = 16;
pub const PDCAP_WAKE_FROM_D1_SUPPORTED: u32 = 32;
pub const PDCAP_WAKE_FROM_D2_SUPPORTED: u32 = 64;
pub const PDCAP_WAKE_FROM_D3_SUPPORTED: u32 = 128;
pub const PDCAP_WARM_EJECT_SUPPORTED: u32 = 256;
pub const POWER_SETTING_VALUE_VERSION: u32 = 1;
pub const POWER_PLATFORM_ROLE_V1: u32 = 1;
pub const POWER_PLATFORM_ROLE_V2: u32 = 2;
pub const POWER_PLATFORM_ROLE_VERSION: u32 = 2;
pub const PROC_IDLE_BUCKET_COUNT: u32 = 6;
pub const PROC_IDLE_BUCKET_COUNT_EX: u32 = 16;
pub const ACPI_PPM_SOFTWARE_ALL: u32 = 252;
pub const ACPI_PPM_SOFTWARE_ANY: u32 = 253;
pub const ACPI_PPM_HARDWARE_ALL: u32 = 254;
pub const MS_PPM_SOFTWARE_ALL: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C2: u32 = 1;
pub const PPM_FIRMWARE_ACPI1C3: u32 = 2;
pub const PPM_FIRMWARE_ACPI1TSTATES: u32 = 4;
pub const PPM_FIRMWARE_CST: u32 = 8;
pub const PPM_FIRMWARE_CSD: u32 = 16;
pub const PPM_FIRMWARE_PCT: u32 = 32;
pub const PPM_FIRMWARE_PSS: u32 = 64;
pub const PPM_FIRMWARE_XPSS: u32 = 128;
pub const PPM_FIRMWARE_PPC: u32 = 256;
pub const PPM_FIRMWARE_PSD: u32 = 512;
pub const PPM_FIRMWARE_PTC: u32 = 1024;
pub const PPM_FIRMWARE_TSS: u32 = 2048;
pub const PPM_FIRMWARE_TPC: u32 = 4096;
pub const PPM_FIRMWARE_TSD: u32 = 8192;
pub const PPM_FIRMWARE_PCCH: u32 = 16384;
pub const PPM_FIRMWARE_PCCP: u32 = 32768;
pub const PPM_FIRMWARE_OSC: u32 = 65536;
pub const PPM_FIRMWARE_PDC: u32 = 131072;
pub const PPM_FIRMWARE_CPC: u32 = 262144;
pub const PPM_FIRMWARE_LPI: u32 = 524288;
pub const PPM_PERFORMANCE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PSTATES: u32 = 1;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PCCV1: u32 = 2;
pub const PPM_PERFORMANCE_IMPLEMENTATION_CPPC: u32 = 3;
pub const PPM_PERFORMANCE_IMPLEMENTATION_PEP: u32 = 4;
pub const PPM_IDLE_IMPLEMENTATION_NONE: u32 = 0;
pub const PPM_IDLE_IMPLEMENTATION_CSTATES: u32 = 1;
pub const PPM_IDLE_IMPLEMENTATION_PEP: u32 = 2;
pub const PPM_IDLE_IMPLEMENTATION_MICROPEP: u32 = 3;
pub const PPM_IDLE_IMPLEMENTATION_LPISTATES: u32 = 4;
pub const POWER_ACTION_QUERY_ALLOWED: u32 = 1;
pub const POWER_ACTION_UI_ALLOWED: u32 = 2;
pub const POWER_ACTION_OVERRIDE_APPS: u32 = 4;
pub const POWER_ACTION_HIBERBOOT: u32 = 8;
pub const POWER_ACTION_USER_NOTIFY: u32 = 16;
pub const POWER_ACTION_DOZE_TO_HIBERNATE: u32 = 32;
pub const POWER_ACTION_ACPI_CRITICAL: u32 = 16777216;
pub const POWER_ACTION_ACPI_USER_NOTIFY: u32 = 33554432;
pub const POWER_ACTION_DIRECTED_DRIPS: u32 = 67108864;
pub const POWER_ACTION_PSEUDO_TRANSITION: u32 = 134217728;
pub const POWER_ACTION_LIGHTEST_FIRST: u32 = 268435456;
pub const POWER_ACTION_LOCK_CONSOLE: u32 = 536870912;
pub const POWER_ACTION_DISABLE_WAKES: u32 = 1073741824;
pub const POWER_ACTION_CRITICAL: u32 = 2147483648;
pub const POWER_LEVEL_USER_NOTIFY_TEXT: u32 = 1;
pub const POWER_LEVEL_USER_NOTIFY_SOUND: u32 = 2;
pub const POWER_LEVEL_USER_NOTIFY_EXEC: u32 = 4;
pub const POWER_USER_NOTIFY_BUTTON: u32 = 8;
pub const POWER_USER_NOTIFY_SHUTDOWN: u32 = 16;
pub const POWER_USER_NOTIFY_FORCED_SHUTDOWN: u32 = 32;
pub const POWER_FORCE_TRIGGER_RESET: u32 = 2147483648;
pub const BATTERY_DISCHARGE_FLAGS_EVENTCODE_MASK: u32 = 7;
pub const BATTERY_DISCHARGE_FLAGS_ENABLE: u32 = 2147483648;
pub const NUM_DISCHARGE_POLICIES: u32 = 4;
pub const DISCHARGE_POLICY_CRITICAL: u32 = 0;
pub const DISCHARGE_POLICY_LOW: u32 = 1;
pub const PROCESSOR_IDLESTATE_POLICY_COUNT: u32 = 3;
pub const PO_THROTTLE_NONE: u32 = 0;
pub const PO_THROTTLE_CONSTANT: u32 = 1;
pub const PO_THROTTLE_DEGRADE: u32 = 2;
pub const PO_THROTTLE_ADAPTIVE: u32 = 3;
pub const PO_THROTTLE_MAXIMUM: u32 = 4;
pub const HIBERFILE_TYPE_NONE: u32 = 0;
pub const HIBERFILE_TYPE_REDUCED: u32 = 1;
pub const HIBERFILE_TYPE_FULL: u32 = 2;
pub const HIBERFILE_TYPE_MAX: u32 = 3;
pub const IMAGE_DOS_SIGNATURE: u32 = 23117;
pub const IMAGE_OS2_SIGNATURE: u32 = 17742;
pub const IMAGE_OS2_SIGNATURE_LE: u32 = 17740;
pub const IMAGE_VXD_SIGNATURE: u32 = 17740;
pub const IMAGE_NT_SIGNATURE: u32 = 17744;
pub const IMAGE_SIZEOF_FILE_HEADER: u32 = 20;
pub const IMAGE_FILE_RELOCS_STRIPPED: u32 = 1;
pub const IMAGE_FILE_EXECUTABLE_IMAGE: u32 = 2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED: u32 = 4;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED: u32 = 8;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM: u32 = 16;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE: u32 = 32;
pub const IMAGE_FILE_BYTES_REVERSED_LO: u32 = 128;
pub const IMAGE_FILE_32BIT_MACHINE: u32 = 256;
pub const IMAGE_FILE_DEBUG_STRIPPED: u32 = 512;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP: u32 = 1024;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP: u32 = 2048;
pub const IMAGE_FILE_SYSTEM: u32 = 4096;
pub const IMAGE_FILE_DLL: u32 = 8192;
pub const IMAGE_FILE_UP_SYSTEM_ONLY: u32 = 16384;
pub const IMAGE_FILE_BYTES_REVERSED_HI: u32 = 32768;
pub const IMAGE_FILE_MACHINE_UNKNOWN: u32 = 0;
pub const IMAGE_FILE_MACHINE_TARGET_HOST: u32 = 1;
pub const IMAGE_FILE_MACHINE_I386: u32 = 332;
pub const IMAGE_FILE_MACHINE_R3000: u32 = 354;
pub const IMAGE_FILE_MACHINE_R4000: u32 = 358;
pub const IMAGE_FILE_MACHINE_R10000: u32 = 360;
pub const IMAGE_FILE_MACHINE_WCEMIPSV2: u32 = 361;
pub const IMAGE_FILE_MACHINE_ALPHA: u32 = 388;
pub const IMAGE_FILE_MACHINE_SH3: u32 = 418;
pub const IMAGE_FILE_MACHINE_SH3DSP: u32 = 419;
pub const IMAGE_FILE_MACHINE_SH3E: u32 = 420;
pub const IMAGE_FILE_MACHINE_SH4: u32 = 422;
pub const IMAGE_FILE_MACHINE_SH5: u32 = 424;
pub const IMAGE_FILE_MACHINE_ARM: u32 = 448;
pub const IMAGE_FILE_MACHINE_THUMB: u32 = 450;
pub const IMAGE_FILE_MACHINE_ARMNT: u32 = 452;
pub const IMAGE_FILE_MACHINE_AM33: u32 = 467;
pub const IMAGE_FILE_MACHINE_POWERPC: u32 = 496;
pub const IMAGE_FILE_MACHINE_POWERPCFP: u32 = 497;
pub const IMAGE_FILE_MACHINE_IA64: u32 = 512;
pub const IMAGE_FILE_MACHINE_MIPS16: u32 = 614;
pub const IMAGE_FILE_MACHINE_ALPHA64: u32 = 644;
pub const IMAGE_FILE_MACHINE_MIPSFPU: u32 = 870;
pub const IMAGE_FILE_MACHINE_MIPSFPU16: u32 = 1126;
pub const IMAGE_FILE_MACHINE_AXP64: u32 = 644;
pub const IMAGE_FILE_MACHINE_TRICORE: u32 = 1312;
pub const IMAGE_FILE_MACHINE_CEF: u32 = 3311;
pub const IMAGE_FILE_MACHINE_EBC: u32 = 3772;
pub const IMAGE_FILE_MACHINE_AMD64: u32 = 34404;
pub const IMAGE_FILE_MACHINE_M32R: u32 = 36929;
pub const IMAGE_FILE_MACHINE_ARM64: u32 = 43620;
pub const IMAGE_FILE_MACHINE_CEE: u32 = 49390;
pub const IMAGE_NUMBEROF_DIRECTORY_ENTRIES: u32 = 16;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC: u32 = 267;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC: u32 = 523;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC: u32 = 263;
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC: u32 = 523;
pub const IMAGE_SUBSYSTEM_UNKNOWN: u32 = 0;
pub const IMAGE_SUBSYSTEM_NATIVE: u32 = 1;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI: u32 = 2;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI: u32 = 3;
pub const IMAGE_SUBSYSTEM_OS2_CUI: u32 = 5;
pub const IMAGE_SUBSYSTEM_POSIX_CUI: u32 = 7;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS: u32 = 8;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI: u32 = 9;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION: u32 = 10;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER: u32 = 11;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER: u32 = 12;
pub const IMAGE_SUBSYSTEM_EFI_ROM: u32 = 13;
pub const IMAGE_SUBSYSTEM_XBOX: u32 = 14;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION: u32 = 16;
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG: u32 = 17;
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA: u32 = 32;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE: u32 = 64;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY: u32 = 128;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT: u32 = 256;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION: u32 = 512;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH: u32 = 1024;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND: u32 = 2048;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER: u32 = 4096;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER: u32 = 8192;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF: u32 = 16384;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE: u32 = 32768;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT: u32 = 0;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT: u32 = 1;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE: u32 = 2;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION: u32 = 3;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY: u32 = 4;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC: u32 = 5;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG: u32 = 6;
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE: u32 = 7;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR: u32 = 8;
pub const IMAGE_DIRECTORY_ENTRY_TLS: u32 = 9;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG: u32 = 10;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT: u32 = 11;
pub const IMAGE_DIRECTORY_ENTRY_IAT: u32 = 12;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT: u32 = 13;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR: u32 = 14;
pub const IMAGE_SIZEOF_SHORT_NAME: u32 = 8;
pub const IMAGE_SIZEOF_SECTION_HEADER: u32 = 40;
pub const IMAGE_SCN_TYPE_NO_PAD: u32 = 8;
pub const IMAGE_SCN_CNT_CODE: u32 = 32;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA: u32 = 64;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA: u32 = 128;
pub const IMAGE_SCN_LNK_OTHER: u32 = 256;
pub const IMAGE_SCN_LNK_INFO: u32 = 512;
pub const IMAGE_SCN_LNK_REMOVE: u32 = 2048;
pub const IMAGE_SCN_LNK_COMDAT: u32 = 4096;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC: u32 = 16384;
pub const IMAGE_SCN_GPREL: u32 = 32768;
pub const IMAGE_SCN_MEM_FARDATA: u32 = 32768;
pub const IMAGE_SCN_MEM_PURGEABLE: u32 = 131072;
pub const IMAGE_SCN_MEM_16BIT: u32 = 131072;
pub const IMAGE_SCN_MEM_LOCKED: u32 = 262144;
pub const IMAGE_SCN_MEM_PRELOAD: u32 = 524288;
pub const IMAGE_SCN_ALIGN_1BYTES: u32 = 1048576;
pub const IMAGE_SCN_ALIGN_2BYTES: u32 = 2097152;
pub const IMAGE_SCN_ALIGN_4BYTES: u32 = 3145728;
pub const IMAGE_SCN_ALIGN_8BYTES: u32 = 4194304;
pub const IMAGE_SCN_ALIGN_16BYTES: u32 = 5242880;
pub const IMAGE_SCN_ALIGN_32BYTES: u32 = 6291456;
pub const IMAGE_SCN_ALIGN_64BYTES: u32 = 7340032;
pub const IMAGE_SCN_ALIGN_128BYTES: u32 = 8388608;
pub const IMAGE_SCN_ALIGN_256BYTES: u32 = 9437184;
pub const IMAGE_SCN_ALIGN_512BYTES: u32 = 10485760;
pub const IMAGE_SCN_ALIGN_1024BYTES: u32 = 11534336;
pub const IMAGE_SCN_ALIGN_2048BYTES: u32 = 12582912;
pub const IMAGE_SCN_ALIGN_4096BYTES: u32 = 13631488;
pub const IMAGE_SCN_ALIGN_8192BYTES: u32 = 14680064;
pub const IMAGE_SCN_ALIGN_MASK: u32 = 15728640;
pub const IMAGE_SCN_LNK_NRELOC_OVFL: u32 = 16777216;
pub const IMAGE_SCN_MEM_DISCARDABLE: u32 = 33554432;
pub const IMAGE_SCN_MEM_NOT_CACHED: u32 = 67108864;
pub const IMAGE_SCN_MEM_NOT_PAGED: u32 = 134217728;
pub const IMAGE_SCN_MEM_SHARED: u32 = 268435456;
pub const IMAGE_SCN_MEM_EXECUTE: u32 = 536870912;
pub const IMAGE_SCN_MEM_READ: u32 = 1073741824;
pub const IMAGE_SCN_MEM_WRITE: u32 = 2147483648;
pub const IMAGE_SCN_SCALE_INDEX: u32 = 1;
pub const IMAGE_SIZEOF_SYMBOL: u32 = 18;
pub const IMAGE_SYM_SECTION_MAX: u32 = 65279;
pub const IMAGE_SYM_SECTION_MAX_EX: u32 = 2147483647;
pub const IMAGE_SYM_TYPE_NULL: u32 = 0;
pub const IMAGE_SYM_TYPE_VOID: u32 = 1;
pub const IMAGE_SYM_TYPE_CHAR: u32 = 2;
pub const IMAGE_SYM_TYPE_SHORT: u32 = 3;
pub const IMAGE_SYM_TYPE_INT: u32 = 4;
pub const IMAGE_SYM_TYPE_LONG: u32 = 5;
pub const IMAGE_SYM_TYPE_FLOAT: u32 = 6;
pub const IMAGE_SYM_TYPE_DOUBLE: u32 = 7;
pub const IMAGE_SYM_TYPE_STRUCT: u32 = 8;
pub const IMAGE_SYM_TYPE_UNION: u32 = 9;
pub const IMAGE_SYM_TYPE_ENUM: u32 = 10;
pub const IMAGE_SYM_TYPE_MOE: u32 = 11;
pub const IMAGE_SYM_TYPE_BYTE: u32 = 12;
pub const IMAGE_SYM_TYPE_WORD: u32 = 13;
pub const IMAGE_SYM_TYPE_UINT: u32 = 14;
pub const IMAGE_SYM_TYPE_DWORD: u32 = 15;
pub const IMAGE_SYM_TYPE_PCODE: u32 = 32768;
pub const IMAGE_SYM_DTYPE_NULL: u32 = 0;
pub const IMAGE_SYM_DTYPE_POINTER: u32 = 1;
pub const IMAGE_SYM_DTYPE_FUNCTION: u32 = 2;
pub const IMAGE_SYM_DTYPE_ARRAY: u32 = 3;
pub const IMAGE_SYM_CLASS_NULL: u32 = 0;
pub const IMAGE_SYM_CLASS_AUTOMATIC: u32 = 1;
pub const IMAGE_SYM_CLASS_EXTERNAL: u32 = 2;
pub const IMAGE_SYM_CLASS_STATIC: u32 = 3;
pub const IMAGE_SYM_CLASS_REGISTER: u32 = 4;
pub const IMAGE_SYM_CLASS_EXTERNAL_DEF: u32 = 5;
pub const IMAGE_SYM_CLASS_LABEL: u32 = 6;
pub const IMAGE_SYM_CLASS_UNDEFINED_LABEL: u32 = 7;
pub const IMAGE_SYM_CLASS_MEMBER_OF_STRUCT: u32 = 8;
pub const IMAGE_SYM_CLASS_ARGUMENT: u32 = 9;
pub const IMAGE_SYM_CLASS_STRUCT_TAG: u32 = 10;
pub const IMAGE_SYM_CLASS_MEMBER_OF_UNION: u32 = 11;
pub const IMAGE_SYM_CLASS_UNION_TAG: u32 = 12;
pub const IMAGE_SYM_CLASS_TYPE_DEFINITION: u32 = 13;
pub const IMAGE_SYM_CLASS_UNDEFINED_STATIC: u32 = 14;
pub const IMAGE_SYM_CLASS_ENUM_TAG: u32 = 15;
pub const IMAGE_SYM_CLASS_MEMBER_OF_ENUM: u32 = 16;
pub const IMAGE_SYM_CLASS_REGISTER_PARAM: u32 = 17;
pub const IMAGE_SYM_CLASS_BIT_FIELD: u32 = 18;
pub const IMAGE_SYM_CLASS_FAR_EXTERNAL: u32 = 68;
pub const IMAGE_SYM_CLASS_BLOCK: u32 = 100;
pub const IMAGE_SYM_CLASS_FUNCTION: u32 = 101;
pub const IMAGE_SYM_CLASS_END_OF_STRUCT: u32 = 102;
pub const IMAGE_SYM_CLASS_FILE: u32 = 103;
pub const IMAGE_SYM_CLASS_SECTION: u32 = 104;
pub const IMAGE_SYM_CLASS_WEAK_EXTERNAL: u32 = 105;
pub const IMAGE_SYM_CLASS_CLR_TOKEN: u32 = 107;
pub const N_BTMASK: u32 = 15;
pub const N_TMASK: u32 = 48;
pub const N_TMASK1: u32 = 192;
pub const N_TMASK2: u32 = 240;
pub const N_BTSHFT: u32 = 4;
pub const N_TSHIFT: u32 = 2;
pub const IMAGE_COMDAT_SELECT_NODUPLICATES: u32 = 1;
pub const IMAGE_COMDAT_SELECT_ANY: u32 = 2;
pub const IMAGE_COMDAT_SELECT_SAME_SIZE: u32 = 3;
pub const IMAGE_COMDAT_SELECT_EXACT_MATCH: u32 = 4;
pub const IMAGE_COMDAT_SELECT_ASSOCIATIVE: u32 = 5;
pub const IMAGE_COMDAT_SELECT_LARGEST: u32 = 6;
pub const IMAGE_COMDAT_SELECT_NEWEST: u32 = 7;
pub const IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY: u32 = 1;
pub const IMAGE_WEAK_EXTERN_SEARCH_LIBRARY: u32 = 2;
pub const IMAGE_WEAK_EXTERN_SEARCH_ALIAS: u32 = 3;
pub const IMAGE_WEAK_EXTERN_ANTI_DEPENDENCY: u32 = 4;
pub const IMAGE_REL_I386_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_I386_DIR16: u32 = 1;
pub const IMAGE_REL_I386_REL16: u32 = 2;
pub const IMAGE_REL_I386_DIR32: u32 = 6;
pub const IMAGE_REL_I386_DIR32NB: u32 = 7;
pub const IMAGE_REL_I386_SEG12: u32 = 9;
pub const IMAGE_REL_I386_SECTION: u32 = 10;
pub const IMAGE_REL_I386_SECREL: u32 = 11;
pub const IMAGE_REL_I386_TOKEN: u32 = 12;
pub const IMAGE_REL_I386_SECREL7: u32 = 13;
pub const IMAGE_REL_I386_REL32: u32 = 20;
pub const IMAGE_REL_MIPS_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_MIPS_REFHALF: u32 = 1;
pub const IMAGE_REL_MIPS_REFWORD: u32 = 2;
pub const IMAGE_REL_MIPS_JMPADDR: u32 = 3;
pub const IMAGE_REL_MIPS_REFHI: u32 = 4;
pub const IMAGE_REL_MIPS_REFLO: u32 = 5;
pub const IMAGE_REL_MIPS_GPREL: u32 = 6;
pub const IMAGE_REL_MIPS_LITERAL: u32 = 7;
pub const IMAGE_REL_MIPS_SECTION: u32 = 10;
pub const IMAGE_REL_MIPS_SECREL: u32 = 11;
pub const IMAGE_REL_MIPS_SECRELLO: u32 = 12;
pub const IMAGE_REL_MIPS_SECRELHI: u32 = 13;
pub const IMAGE_REL_MIPS_TOKEN: u32 = 14;
pub const IMAGE_REL_MIPS_JMPADDR16: u32 = 16;
pub const IMAGE_REL_MIPS_REFWORDNB: u32 = 34;
pub const IMAGE_REL_MIPS_PAIR: u32 = 37;
pub const IMAGE_REL_ALPHA_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ALPHA_REFLONG: u32 = 1;
pub const IMAGE_REL_ALPHA_REFQUAD: u32 = 2;
pub const IMAGE_REL_ALPHA_GPREL32: u32 = 3;
pub const IMAGE_REL_ALPHA_LITERAL: u32 = 4;
pub const IMAGE_REL_ALPHA_LITUSE: u32 = 5;
pub const IMAGE_REL_ALPHA_GPDISP: u32 = 6;
pub const IMAGE_REL_ALPHA_BRADDR: u32 = 7;
pub const IMAGE_REL_ALPHA_HINT: u32 = 8;
pub const IMAGE_REL_ALPHA_INLINE_REFLONG: u32 = 9;
pub const IMAGE_REL_ALPHA_REFHI: u32 = 10;
pub const IMAGE_REL_ALPHA_REFLO: u32 = 11;
pub const IMAGE_REL_ALPHA_PAIR: u32 = 12;
pub const IMAGE_REL_ALPHA_MATCH: u32 = 13;
pub const IMAGE_REL_ALPHA_SECTION: u32 = 14;
pub const IMAGE_REL_ALPHA_SECREL: u32 = 15;
pub const IMAGE_REL_ALPHA_REFLONGNB: u32 = 16;
pub const IMAGE_REL_ALPHA_SECRELLO: u32 = 17;
pub const IMAGE_REL_ALPHA_SECRELHI: u32 = 18;
pub const IMAGE_REL_ALPHA_REFQ3: u32 = 19;
pub const IMAGE_REL_ALPHA_REFQ2: u32 = 20;
pub const IMAGE_REL_ALPHA_REFQ1: u32 = 21;
pub const IMAGE_REL_ALPHA_GPRELLO: u32 = 22;
pub const IMAGE_REL_ALPHA_GPRELHI: u32 = 23;
pub const IMAGE_REL_PPC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_PPC_ADDR64: u32 = 1;
pub const IMAGE_REL_PPC_ADDR32: u32 = 2;
pub const IMAGE_REL_PPC_ADDR24: u32 = 3;
pub const IMAGE_REL_PPC_ADDR16: u32 = 4;
pub const IMAGE_REL_PPC_ADDR14: u32 = 5;
pub const IMAGE_REL_PPC_REL24: u32 = 6;
pub const IMAGE_REL_PPC_REL14: u32 = 7;
pub const IMAGE_REL_PPC_TOCREL16: u32 = 8;
pub const IMAGE_REL_PPC_TOCREL14: u32 = 9;
pub const IMAGE_REL_PPC_ADDR32NB: u32 = 10;
pub const IMAGE_REL_PPC_SECREL: u32 = 11;
pub const IMAGE_REL_PPC_SECTION: u32 = 12;
pub const IMAGE_REL_PPC_IFGLUE: u32 = 13;
pub const IMAGE_REL_PPC_IMGLUE: u32 = 14;
pub const IMAGE_REL_PPC_SECREL16: u32 = 15;
pub const IMAGE_REL_PPC_REFHI: u32 = 16;
pub const IMAGE_REL_PPC_REFLO: u32 = 17;
pub const IMAGE_REL_PPC_PAIR: u32 = 18;
pub const IMAGE_REL_PPC_SECRELLO: u32 = 19;
pub const IMAGE_REL_PPC_SECRELHI: u32 = 20;
pub const IMAGE_REL_PPC_GPREL: u32 = 21;
pub const IMAGE_REL_PPC_TOKEN: u32 = 22;
pub const IMAGE_REL_PPC_TYPEMASK: u32 = 255;
pub const IMAGE_REL_PPC_NEG: u32 = 256;
pub const IMAGE_REL_PPC_BRTAKEN: u32 = 512;
pub const IMAGE_REL_PPC_BRNTAKEN: u32 = 1024;
pub const IMAGE_REL_PPC_TOCDEFN: u32 = 2048;
pub const IMAGE_REL_SH3_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_SH3_DIRECT16: u32 = 1;
pub const IMAGE_REL_SH3_DIRECT32: u32 = 2;
pub const IMAGE_REL_SH3_DIRECT8: u32 = 3;
pub const IMAGE_REL_SH3_DIRECT8_WORD: u32 = 4;
pub const IMAGE_REL_SH3_DIRECT8_LONG: u32 = 5;
pub const IMAGE_REL_SH3_DIRECT4: u32 = 6;
pub const IMAGE_REL_SH3_DIRECT4_WORD: u32 = 7;
pub const IMAGE_REL_SH3_DIRECT4_LONG: u32 = 8;
pub const IMAGE_REL_SH3_PCREL8_WORD: u32 = 9;
pub const IMAGE_REL_SH3_PCREL8_LONG: u32 = 10;
pub const IMAGE_REL_SH3_PCREL12_WORD: u32 = 11;
pub const IMAGE_REL_SH3_STARTOF_SECTION: u32 = 12;
pub const IMAGE_REL_SH3_SIZEOF_SECTION: u32 = 13;
pub const IMAGE_REL_SH3_SECTION: u32 = 14;
pub const IMAGE_REL_SH3_SECREL: u32 = 15;
pub const IMAGE_REL_SH3_DIRECT32_NB: u32 = 16;
pub const IMAGE_REL_SH3_GPREL4_LONG: u32 = 17;
pub const IMAGE_REL_SH3_TOKEN: u32 = 18;
pub const IMAGE_REL_SHM_PCRELPT: u32 = 19;
pub const IMAGE_REL_SHM_REFLO: u32 = 20;
pub const IMAGE_REL_SHM_REFHALF: u32 = 21;
pub const IMAGE_REL_SHM_RELLO: u32 = 22;
pub const IMAGE_REL_SHM_RELHALF: u32 = 23;
pub const IMAGE_REL_SHM_PAIR: u32 = 24;
pub const IMAGE_REL_SH_NOMODE: u32 = 32768;
pub const IMAGE_REL_ARM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM_BRANCH24: u32 = 3;
pub const IMAGE_REL_ARM_BRANCH11: u32 = 4;
pub const IMAGE_REL_ARM_TOKEN: u32 = 5;
pub const IMAGE_REL_ARM_GPREL12: u32 = 6;
pub const IMAGE_REL_ARM_GPREL7: u32 = 7;
pub const IMAGE_REL_ARM_BLX24: u32 = 8;
pub const IMAGE_REL_ARM_BLX11: u32 = 9;
pub const IMAGE_REL_ARM_SECTION: u32 = 14;
pub const IMAGE_REL_ARM_SECREL: u32 = 15;
pub const IMAGE_REL_ARM_MOV32A: u32 = 16;
pub const IMAGE_REL_ARM_MOV32: u32 = 16;
pub const IMAGE_REL_ARM_MOV32T: u32 = 17;
pub const IMAGE_REL_THUMB_MOV32: u32 = 17;
pub const IMAGE_REL_ARM_BRANCH20T: u32 = 18;
pub const IMAGE_REL_THUMB_BRANCH20: u32 = 18;
pub const IMAGE_REL_ARM_BRANCH24T: u32 = 20;
pub const IMAGE_REL_THUMB_BRANCH24: u32 = 20;
pub const IMAGE_REL_ARM_BLX23T: u32 = 21;
pub const IMAGE_REL_THUMB_BLX23: u32 = 21;
pub const IMAGE_REL_AM_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AM_ADDR32: u32 = 1;
pub const IMAGE_REL_AM_ADDR32NB: u32 = 2;
pub const IMAGE_REL_AM_CALL32: u32 = 3;
pub const IMAGE_REL_AM_FUNCINFO: u32 = 4;
pub const IMAGE_REL_AM_REL32_1: u32 = 5;
pub const IMAGE_REL_AM_REL32_2: u32 = 6;
pub const IMAGE_REL_AM_SECREL: u32 = 7;
pub const IMAGE_REL_AM_SECTION: u32 = 8;
pub const IMAGE_REL_AM_TOKEN: u32 = 9;
pub const IMAGE_REL_ARM64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_ARM64_ADDR32: u32 = 1;
pub const IMAGE_REL_ARM64_ADDR32NB: u32 = 2;
pub const IMAGE_REL_ARM64_BRANCH26: u32 = 3;
pub const IMAGE_REL_ARM64_PAGEBASE_REL21: u32 = 4;
pub const IMAGE_REL_ARM64_REL21: u32 = 5;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12A: u32 = 6;
pub const IMAGE_REL_ARM64_PAGEOFFSET_12L: u32 = 7;
pub const IMAGE_REL_ARM64_SECREL: u32 = 8;
pub const IMAGE_REL_ARM64_SECREL_LOW12A: u32 = 9;
pub const IMAGE_REL_ARM64_SECREL_HIGH12A: u32 = 10;
pub const IMAGE_REL_ARM64_SECREL_LOW12L: u32 = 11;
pub const IMAGE_REL_ARM64_TOKEN: u32 = 12;
pub const IMAGE_REL_ARM64_SECTION: u32 = 13;
pub const IMAGE_REL_ARM64_ADDR64: u32 = 14;
pub const IMAGE_REL_ARM64_BRANCH19: u32 = 15;
pub const IMAGE_REL_AMD64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_AMD64_ADDR64: u32 = 1;
pub const IMAGE_REL_AMD64_ADDR32: u32 = 2;
pub const IMAGE_REL_AMD64_ADDR32NB: u32 = 3;
pub const IMAGE_REL_AMD64_REL32: u32 = 4;
pub const IMAGE_REL_AMD64_REL32_1: u32 = 5;
pub const IMAGE_REL_AMD64_REL32_2: u32 = 6;
pub const IMAGE_REL_AMD64_REL32_3: u32 = 7;
pub const IMAGE_REL_AMD64_REL32_4: u32 = 8;
pub const IMAGE_REL_AMD64_REL32_5: u32 = 9;
pub const IMAGE_REL_AMD64_SECTION: u32 = 10;
pub const IMAGE_REL_AMD64_SECREL: u32 = 11;
pub const IMAGE_REL_AMD64_SECREL7: u32 = 12;
pub const IMAGE_REL_AMD64_TOKEN: u32 = 13;
pub const IMAGE_REL_AMD64_SREL32: u32 = 14;
pub const IMAGE_REL_AMD64_PAIR: u32 = 15;
pub const IMAGE_REL_AMD64_SSPAN32: u32 = 16;
pub const IMAGE_REL_AMD64_EHANDLER: u32 = 17;
pub const IMAGE_REL_AMD64_IMPORT_BR: u32 = 18;
pub const IMAGE_REL_AMD64_IMPORT_CALL: u32 = 19;
pub const IMAGE_REL_AMD64_CFG_BR: u32 = 20;
pub const IMAGE_REL_AMD64_CFG_BR_REX: u32 = 21;
pub const IMAGE_REL_AMD64_CFG_CALL: u32 = 22;
pub const IMAGE_REL_AMD64_INDIR_BR: u32 = 23;
pub const IMAGE_REL_AMD64_INDIR_BR_REX: u32 = 24;
pub const IMAGE_REL_AMD64_INDIR_CALL: u32 = 25;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_FIRST: u32 = 32;
pub const IMAGE_REL_AMD64_INDIR_BR_SWITCHTABLE_LAST: u32 = 47;
pub const IMAGE_REL_IA64_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_IA64_IMM14: u32 = 1;
pub const IMAGE_REL_IA64_IMM22: u32 = 2;
pub const IMAGE_REL_IA64_IMM64: u32 = 3;
pub const IMAGE_REL_IA64_DIR32: u32 = 4;
pub const IMAGE_REL_IA64_DIR64: u32 = 5;
pub const IMAGE_REL_IA64_PCREL21B: u32 = 6;
pub const IMAGE_REL_IA64_PCREL21M: u32 = 7;
pub const IMAGE_REL_IA64_PCREL21F: u32 = 8;
pub const IMAGE_REL_IA64_GPREL22: u32 = 9;
pub const IMAGE_REL_IA64_LTOFF22: u32 = 10;
pub const IMAGE_REL_IA64_SECTION: u32 = 11;
pub const IMAGE_REL_IA64_SECREL22: u32 = 12;
pub const IMAGE_REL_IA64_SECREL64I: u32 = 13;
pub const IMAGE_REL_IA64_SECREL32: u32 = 14;
pub const IMAGE_REL_IA64_DIR32NB: u32 = 16;
pub const IMAGE_REL_IA64_SREL14: u32 = 17;
pub const IMAGE_REL_IA64_SREL22: u32 = 18;
pub const IMAGE_REL_IA64_SREL32: u32 = 19;
pub const IMAGE_REL_IA64_UREL32: u32 = 20;
pub const IMAGE_REL_IA64_PCREL60X: u32 = 21;
pub const IMAGE_REL_IA64_PCREL60B: u32 = 22;
pub const IMAGE_REL_IA64_PCREL60F: u32 = 23;
pub const IMAGE_REL_IA64_PCREL60I: u32 = 24;
pub const IMAGE_REL_IA64_PCREL60M: u32 = 25;
pub const IMAGE_REL_IA64_IMMGPREL64: u32 = 26;
pub const IMAGE_REL_IA64_TOKEN: u32 = 27;
pub const IMAGE_REL_IA64_GPREL32: u32 = 28;
pub const IMAGE_REL_IA64_ADDEND: u32 = 31;
pub const IMAGE_REL_CEF_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEF_ADDR32: u32 = 1;
pub const IMAGE_REL_CEF_ADDR64: u32 = 2;
pub const IMAGE_REL_CEF_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEF_SECTION: u32 = 4;
pub const IMAGE_REL_CEF_SECREL: u32 = 5;
pub const IMAGE_REL_CEF_TOKEN: u32 = 6;
pub const IMAGE_REL_CEE_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_CEE_ADDR32: u32 = 1;
pub const IMAGE_REL_CEE_ADDR64: u32 = 2;
pub const IMAGE_REL_CEE_ADDR32NB: u32 = 3;
pub const IMAGE_REL_CEE_SECTION: u32 = 4;
pub const IMAGE_REL_CEE_SECREL: u32 = 5;
pub const IMAGE_REL_CEE_TOKEN: u32 = 6;
pub const IMAGE_REL_M32R_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_M32R_ADDR32: u32 = 1;
pub const IMAGE_REL_M32R_ADDR32NB: u32 = 2;
pub const IMAGE_REL_M32R_ADDR24: u32 = 3;
pub const IMAGE_REL_M32R_GPREL16: u32 = 4;
pub const IMAGE_REL_M32R_PCREL24: u32 = 5;
pub const IMAGE_REL_M32R_PCREL16: u32 = 6;
pub const IMAGE_REL_M32R_PCREL8: u32 = 7;
pub const IMAGE_REL_M32R_REFHALF: u32 = 8;
pub const IMAGE_REL_M32R_REFHI: u32 = 9;
pub const IMAGE_REL_M32R_REFLO: u32 = 10;
pub const IMAGE_REL_M32R_PAIR: u32 = 11;
pub const IMAGE_REL_M32R_SECTION: u32 = 12;
pub const IMAGE_REL_M32R_SECREL32: u32 = 13;
pub const IMAGE_REL_M32R_TOKEN: u32 = 14;
pub const IMAGE_REL_EBC_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_EBC_ADDR32NB: u32 = 1;
pub const IMAGE_REL_EBC_REL32: u32 = 2;
pub const IMAGE_REL_EBC_SECTION: u32 = 3;
pub const IMAGE_REL_EBC_SECREL: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM7B_SIZE_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM7B_INST_WORD_POS_X: u32 = 4;
pub const EMARCH_ENC_I17_IMM7B_VAL_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM9D_SIZE_X: u32 = 9;
pub const EMARCH_ENC_I17_IMM9D_INST_WORD_POS_X: u32 = 18;
pub const EMARCH_ENC_I17_IMM9D_VAL_POS_X: u32 = 7;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IMM5C_SIZE_X: u32 = 5;
pub const EMARCH_ENC_I17_IMM5C_INST_WORD_POS_X: u32 = 13;
pub const EMARCH_ENC_I17_IMM5C_VAL_POS_X: u32 = 16;
pub const EMARCH_ENC_I17_IC_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_IC_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_IC_INST_WORD_POS_X: u32 = 12;
pub const EMARCH_ENC_I17_IC_VAL_POS_X: u32 = 21;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41a_SIZE_X: u32 = 10;
pub const EMARCH_ENC_I17_IMM41a_INST_WORD_POS_X: u32 = 14;
pub const EMARCH_ENC_I17_IMM41a_VAL_POS_X: u32 = 22;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_X: u32 = 1;
pub const EMARCH_ENC_I17_IMM41b_SIZE_X: u32 = 8;
pub const EMARCH_ENC_I17_IMM41b_INST_WORD_POS_X: u32 = 24;
pub const EMARCH_ENC_I17_IMM41b_VAL_POS_X: u32 = 32;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_X: u32 = 2;
pub const EMARCH_ENC_I17_IMM41c_SIZE_X: u32 = 23;
pub const EMARCH_ENC_I17_IMM41c_INST_WORD_POS_X: u32 = 0;
pub const EMARCH_ENC_I17_IMM41c_VAL_POS_X: u32 = 40;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_X: u32 = 3;
pub const EMARCH_ENC_I17_SIGN_SIZE_X: u32 = 1;
pub const EMARCH_ENC_I17_SIGN_INST_WORD_POS_X: u32 = 27;
pub const EMARCH_ENC_I17_SIGN_VAL_POS_X: u32 = 63;
pub const X3_OPCODE_INST_WORD_X: u32 = 3;
pub const X3_OPCODE_SIZE_X: u32 = 4;
pub const X3_OPCODE_INST_WORD_POS_X: u32 = 28;
pub const X3_OPCODE_SIGN_VAL_POS_X: u32 = 0;
pub const X3_I_INST_WORD_X: u32 = 3;
pub const X3_I_SIZE_X: u32 = 1;
pub const X3_I_INST_WORD_POS_X: u32 = 27;
pub const X3_I_SIGN_VAL_POS_X: u32 = 59;
pub const X3_D_WH_INST_WORD_X: u32 = 3;
pub const X3_D_WH_SIZE_X: u32 = 3;
pub const X3_D_WH_INST_WORD_POS_X: u32 = 24;
pub const X3_D_WH_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM20_INST_WORD_X: u32 = 3;
pub const X3_IMM20_SIZE_X: u32 = 20;
pub const X3_IMM20_INST_WORD_POS_X: u32 = 4;
pub const X3_IMM20_SIGN_VAL_POS_X: u32 = 0;
pub const X3_IMM39_1_INST_WORD_X: u32 = 2;
pub const X3_IMM39_1_SIZE_X: u32 = 23;
pub const X3_IMM39_1_INST_WORD_POS_X: u32 = 0;
pub const X3_IMM39_1_SIGN_VAL_POS_X: u32 = 36;
pub const X3_IMM39_2_INST_WORD_X: u32 = 1;
pub const X3_IMM39_2_SIZE_X: u32 = 16;
pub const X3_IMM39_2_INST_WORD_POS_X: u32 = 16;
pub const X3_IMM39_2_SIGN_VAL_POS_X: u32 = 20;
pub const X3_P_INST_WORD_X: u32 = 3;
pub const X3_P_SIZE_X: u32 = 4;
pub const X3_P_INST_WORD_POS_X: u32 = 0;
pub const X3_P_SIGN_VAL_POS_X: u32 = 0;
pub const X3_TMPLT_INST_WORD_X: u32 = 0;
pub const X3_TMPLT_SIZE_X: u32 = 4;
pub const X3_TMPLT_INST_WORD_POS_X: u32 = 0;
pub const X3_TMPLT_SIGN_VAL_POS_X: u32 = 0;
pub const X3_BTYPE_QP_INST_WORD_X: u32 = 2;
pub const X3_BTYPE_QP_SIZE_X: u32 = 9;
pub const X3_BTYPE_QP_INST_WORD_POS_X: u32 = 23;
pub const X3_BTYPE_QP_INST_VAL_POS_X: u32 = 0;
pub const X3_EMPTY_INST_WORD_X: u32 = 1;
pub const X3_EMPTY_SIZE_X: u32 = 2;
pub const X3_EMPTY_INST_WORD_POS_X: u32 = 14;
pub const X3_EMPTY_INST_VAL_POS_X: u32 = 0;
pub const IMAGE_REL_BASED_ABSOLUTE: u32 = 0;
pub const IMAGE_REL_BASED_HIGH: u32 = 1;
pub const IMAGE_REL_BASED_LOW: u32 = 2;
pub const IMAGE_REL_BASED_HIGHLOW: u32 = 3;
pub const IMAGE_REL_BASED_HIGHADJ: u32 = 4;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_5: u32 = 5;
pub const IMAGE_REL_BASED_RESERVED: u32 = 6;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_7: u32 = 7;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_8: u32 = 8;
pub const IMAGE_REL_BASED_MACHINE_SPECIFIC_9: u32 = 9;
pub const IMAGE_REL_BASED_DIR64: u32 = 10;
pub const IMAGE_REL_BASED_IA64_IMM64: u32 = 9;
pub const IMAGE_REL_BASED_MIPS_JMPADDR: u32 = 5;
pub const IMAGE_REL_BASED_MIPS_JMPADDR16: u32 = 9;
pub const IMAGE_REL_BASED_ARM_MOV32: u32 = 5;
pub const IMAGE_REL_BASED_THUMB_MOV32: u32 = 7;
pub const IMAGE_ARCHIVE_START_SIZE: u32 = 8;
pub const IMAGE_ARCHIVE_START: &'static [u8; 10usize] = b"!<arch>\\n\0";
pub const IMAGE_ARCHIVE_END: &'static [u8; 4usize] = b"`\\n\0";
pub const IMAGE_ARCHIVE_PAD: &'static [u8; 2usize] = b"\n\0";
pub const IMAGE_ARCHIVE_LINKER_MEMBER: &'static [u8; 17usize] = b"/               \0";
pub const IMAGE_ARCHIVE_LONGNAMES_MEMBER: &'static [u8; 17usize] = b"//              \0";
pub const IMAGE_ARCHIVE_HYBRIDMAP_MEMBER: &'static [u8; 17usize] = b"/<HYBRIDMAP>/   \0";
pub const IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR: u32 = 60;
pub const IMAGE_ORDINAL_FLAG64: i64 = -9223372036854775808;
pub const IMAGE_ORDINAL_FLAG32: u32 = 2147483648;
pub const IMAGE_ORDINAL_FLAG: i64 = -9223372036854775808;
pub const IMAGE_RESOURCE_NAME_IS_STRING: u32 = 2147483648;
pub const IMAGE_RESOURCE_DATA_IS_DIRECTORY: u32 = 2147483648;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_PROLOGUE: u32 = 1;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_RF_EPILOGUE: u32 = 2;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_IMPORT_CONTROL_TRANSFER: u32 = 3;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_INDIR_CONTROL_TRANSFER: u32 = 4;
pub const IMAGE_DYNAMIC_RELOCATION_GUARD_SWITCHTABLE_BRANCH: u32 = 5;
pub const IMAGE_HOT_PATCH_BASE_OBLIGATORY: u32 = 1;
pub const IMAGE_HOT_PATCH_BASE_CAN_ROLL_BACK: u32 = 2;
pub const IMAGE_HOT_PATCH_CHUNK_INVERSE: u32 = 2147483648;
pub const IMAGE_HOT_PATCH_CHUNK_OBLIGATORY: u32 = 1073741824;
pub const IMAGE_HOT_PATCH_CHUNK_RESERVED: u32 = 1072705536;
pub const IMAGE_HOT_PATCH_CHUNK_TYPE: u32 = 1032192;
pub const IMAGE_HOT_PATCH_CHUNK_SOURCE_RVA: u32 = 32768;
pub const IMAGE_HOT_PATCH_CHUNK_TARGET_RVA: u32 = 16384;
pub const IMAGE_HOT_PATCH_CHUNK_SIZE: u32 = 4095;
pub const IMAGE_HOT_PATCH_NONE: u32 = 0;
pub const IMAGE_HOT_PATCH_FUNCTION: u32 = 114688;
pub const IMAGE_HOT_PATCH_ABSOLUTE: u32 = 180224;
pub const IMAGE_HOT_PATCH_REL32: u32 = 245760;
pub const IMAGE_HOT_PATCH_CALL_TARGET: u32 = 278528;
pub const IMAGE_HOT_PATCH_INDIRECT: u32 = 376832;
pub const IMAGE_HOT_PATCH_NO_CALL_TARGET: u32 = 409600;
pub const IMAGE_HOT_PATCH_DYNAMIC_VALUE: u32 = 491520;
pub const IMAGE_GUARD_CF_INSTRUMENTED: u32 = 256;
pub const IMAGE_GUARD_CFW_INSTRUMENTED: u32 = 512;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT: u32 = 1024;
pub const IMAGE_GUARD_SECURITY_COOKIE_UNUSED: u32 = 2048;
pub const IMAGE_GUARD_PROTECT_DELAYLOAD_IAT: u32 = 4096;
pub const IMAGE_GUARD_DELAYLOAD_IAT_IN_ITS_OWN_SECTION: u32 = 8192;
pub const IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT: u32 = 16384;
pub const IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION: u32 = 32768;
pub const IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT: u32 = 65536;
pub const IMAGE_GUARD_RF_INSTRUMENTED: u32 = 131072;
pub const IMAGE_GUARD_RF_ENABLE: u32 = 262144;
pub const IMAGE_GUARD_RF_STRICT: u32 = 524288;
pub const IMAGE_GUARD_RETPOLINE_PRESENT: u32 = 1048576;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK: u32 = 4026531840;
pub const IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT: u32 = 28;
pub const IMAGE_GUARD_FLAG_FID_SUPPRESSED: u32 = 1;
pub const IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED: u32 = 2;
pub const IMAGE_ENCLAVE_LONG_ID_LENGTH: u32 = 32;
pub const IMAGE_ENCLAVE_SHORT_ID_LENGTH: u32 = 16;
pub const IMAGE_ENCLAVE_POLICY_DEBUGGABLE: u32 = 1;
pub const IMAGE_ENCLAVE_FLAG_PRIMARY_IMAGE: u32 = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_NONE: u32 = 0;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_UNIQUE_ID: u32 = 1;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_AUTHOR_ID: u32 = 2;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_FAMILY_ID: u32 = 3;
pub const IMAGE_ENCLAVE_IMPORT_MATCH_IMAGE_ID: u32 = 4;
pub const IMAGE_DEBUG_TYPE_UNKNOWN: u32 = 0;
pub const IMAGE_DEBUG_TYPE_COFF: u32 = 1;
pub const IMAGE_DEBUG_TYPE_CODEVIEW: u32 = 2;
pub const IMAGE_DEBUG_TYPE_FPO: u32 = 3;
pub const IMAGE_DEBUG_TYPE_MISC: u32 = 4;
pub const IMAGE_DEBUG_TYPE_EXCEPTION: u32 = 5;
pub const IMAGE_DEBUG_TYPE_FIXUP: u32 = 6;
pub const IMAGE_DEBUG_TYPE_OMAP_TO_SRC: u32 = 7;
pub const IMAGE_DEBUG_TYPE_OMAP_FROM_SRC: u32 = 8;
pub const IMAGE_DEBUG_TYPE_BORLAND: u32 = 9;
pub const IMAGE_DEBUG_TYPE_RESERVED10: u32 = 10;
pub const IMAGE_DEBUG_TYPE_CLSID: u32 = 11;
pub const IMAGE_DEBUG_TYPE_VC_FEATURE: u32 = 12;
pub const IMAGE_DEBUG_TYPE_POGO: u32 = 13;
pub const IMAGE_DEBUG_TYPE_ILTCG: u32 = 14;
pub const IMAGE_DEBUG_TYPE_MPX: u32 = 15;
pub const IMAGE_DEBUG_TYPE_REPRO: u32 = 16;
pub const FRAME_FPO: u32 = 0;
pub const FRAME_TRAP: u32 = 1;
pub const FRAME_TSS: u32 = 2;
pub const FRAME_NONFPO: u32 = 3;
pub const SIZEOF_RFPO_DATA: u32 = 16;
pub const IMAGE_DEBUG_MISC_EXENAME: u32 = 1;
pub const IMAGE_SEPARATE_DEBUG_SIGNATURE: u32 = 18756;
pub const NON_PAGED_DEBUG_SIGNATURE: u32 = 18766;
pub const IMAGE_SEPARATE_DEBUG_FLAGS_MASK: u32 = 32768;
pub const IMAGE_SEPARATE_DEBUG_MISMATCH: u32 = 32768;
pub const IMPORT_OBJECT_HDR_SIG2: u32 = 65535;
pub const RTL_RUN_ONCE_CHECK_ONLY: u32 = 1;
pub const RTL_RUN_ONCE_ASYNC: u32 = 2;
pub const RTL_RUN_ONCE_INIT_FAILED: u32 = 4;
pub const RTL_RUN_ONCE_CTX_RESERVED_BITS: u32 = 2;
pub const FAST_FAIL_LEGACY_GS_VIOLATION: u32 = 0;
pub const FAST_FAIL_VTGUARD_CHECK_FAILURE: u32 = 1;
pub const FAST_FAIL_STACK_COOKIE_CHECK_FAILURE: u32 = 2;
pub const FAST_FAIL_CORRUPT_LIST_ENTRY: u32 = 3;
pub const FAST_FAIL_INCORRECT_STACK: u32 = 4;
pub const FAST_FAIL_INVALID_ARG: u32 = 5;
pub const FAST_FAIL_GS_COOKIE_INIT: u32 = 6;
pub const FAST_FAIL_FATAL_APP_EXIT: u32 = 7;
pub const FAST_FAIL_RANGE_CHECK_FAILURE: u32 = 8;
pub const FAST_FAIL_UNSAFE_REGISTRY_ACCESS: u32 = 9;
pub const FAST_FAIL_GUARD_ICALL_CHECK_FAILURE: u32 = 10;
pub const FAST_FAIL_GUARD_WRITE_CHECK_FAILURE: u32 = 11;
pub const FAST_FAIL_INVALID_FIBER_SWITCH: u32 = 12;
pub const FAST_FAIL_INVALID_SET_OF_CONTEXT: u32 = 13;
pub const FAST_FAIL_INVALID_REFERENCE_COUNT: u32 = 14;
pub const FAST_FAIL_INVALID_JUMP_BUFFER: u32 = 18;
pub const FAST_FAIL_MRDATA_MODIFIED: u32 = 19;
pub const FAST_FAIL_CERTIFICATION_FAILURE: u32 = 20;
pub const FAST_FAIL_INVALID_EXCEPTION_CHAIN: u32 = 21;
pub const FAST_FAIL_CRYPTO_LIBRARY: u32 = 22;
pub const FAST_FAIL_INVALID_CALL_IN_DLL_CALLOUT: u32 = 23;
pub const FAST_FAIL_INVALID_IMAGE_BASE: u32 = 24;
pub const FAST_FAIL_DLOAD_PROTECTION_FAILURE: u32 = 25;
pub const FAST_FAIL_UNSAFE_EXTENSION_CALL: u32 = 26;
pub const FAST_FAIL_DEPRECATED_SERVICE_INVOKED: u32 = 27;
pub const FAST_FAIL_INVALID_BUFFER_ACCESS: u32 = 28;
pub const FAST_FAIL_INVALID_BALANCED_TREE: u32 = 29;
pub const FAST_FAIL_INVALID_NEXT_THREAD: u32 = 30;
pub const FAST_FAIL_GUARD_ICALL_CHECK_SUPPRESSED: u32 = 31;
pub const FAST_FAIL_APCS_DISABLED: u32 = 32;
pub const FAST_FAIL_INVALID_IDLE_STATE: u32 = 33;
pub const FAST_FAIL_MRDATA_PROTECTION_FAILURE: u32 = 34;
pub const FAST_FAIL_UNEXPECTED_HEAP_EXCEPTION: u32 = 35;
pub const FAST_FAIL_INVALID_LOCK_STATE: u32 = 36;
pub const FAST_FAIL_GUARD_JUMPTABLE: u32 = 37;
pub const FAST_FAIL_INVALID_LONGJUMP_TARGET: u32 = 38;
pub const FAST_FAIL_INVALID_DISPATCH_CONTEXT: u32 = 39;
pub const FAST_FAIL_INVALID_THREAD: u32 = 40;
pub const FAST_FAIL_INVALID_SYSCALL_NUMBER: u32 = 41;
pub const FAST_FAIL_INVALID_FILE_OPERATION: u32 = 42;
pub const FAST_FAIL_LPAC_ACCESS_DENIED: u32 = 43;
pub const FAST_FAIL_GUARD_SS_FAILURE: u32 = 44;
pub const FAST_FAIL_LOADER_CONTINUITY_FAILURE: u32 = 45;
pub const FAST_FAIL_GUARD_EXPORT_SUPPRESSION_FAILURE: u32 = 46;
pub const FAST_FAIL_INVALID_CONTROL_STACK: u32 = 47;
pub const FAST_FAIL_SET_CONTEXT_DENIED: u32 = 48;
pub const FAST_FAIL_INVALID_IAT: u32 = 49;
pub const FAST_FAIL_HEAP_METADATA_CORRUPTION: u32 = 50;
pub const FAST_FAIL_PAYLOAD_RESTRICTION_VIOLATION: u32 = 51;
pub const FAST_FAIL_LOW_LABEL_ACCESS_DENIED: u32 = 52;
pub const FAST_FAIL_ENCLAVE_CALL_FAILURE: u32 = 53;
pub const FAST_FAIL_UNHANDLED_LSS_EXCEPTON: u32 = 54;
pub const FAST_FAIL_ADMINLESS_ACCESS_DENIED: u32 = 55;
pub const FAST_FAIL_UNEXPECTED_CALL: u32 = 56;
pub const FAST_FAIL_CONTROL_INVALID_RETURN_ADDRESS: u32 = 57;
pub const FAST_FAIL_INVALID_FAST_FAIL_CODE: u32 = 4294967295;
pub const HEAP_NO_SERIALIZE: u32 = 1;
pub const HEAP_GROWABLE: u32 = 2;
pub const HEAP_GENERATE_EXCEPTIONS: u32 = 4;
pub const HEAP_ZERO_MEMORY: u32 = 8;
pub const HEAP_REALLOC_IN_PLACE_ONLY: u32 = 16;
pub const HEAP_TAIL_CHECKING_ENABLED: u32 = 32;
pub const HEAP_FREE_CHECKING_ENABLED: u32 = 64;
pub const HEAP_DISABLE_COALESCE_ON_FREE: u32 = 128;
pub const HEAP_CREATE_ALIGN_16: u32 = 65536;
pub const HEAP_CREATE_ENABLE_TRACING: u32 = 131072;
pub const HEAP_CREATE_ENABLE_EXECUTE: u32 = 262144;
pub const HEAP_MAXIMUM_TAG: u32 = 4095;
pub const HEAP_PSEUDO_TAG_FLAG: u32 = 32768;
pub const HEAP_TAG_SHIFT: u32 = 18;
pub const HEAP_CREATE_SEGMENT_HEAP: u32 = 256;
pub const HEAP_CREATE_HARDENED: u32 = 512;
pub const IS_TEXT_UNICODE_ASCII16: u32 = 1;
pub const IS_TEXT_UNICODE_REVERSE_ASCII16: u32 = 16;
pub const IS_TEXT_UNICODE_STATISTICS: u32 = 2;
pub const IS_TEXT_UNICODE_REVERSE_STATISTICS: u32 = 32;
pub const IS_TEXT_UNICODE_CONTROLS: u32 = 4;
pub const IS_TEXT_UNICODE_REVERSE_CONTROLS: u32 = 64;
pub const IS_TEXT_UNICODE_SIGNATURE: u32 = 8;
pub const IS_TEXT_UNICODE_REVERSE_SIGNATURE: u32 = 128;
pub const IS_TEXT_UNICODE_ILLEGAL_CHARS: u32 = 256;
pub const IS_TEXT_UNICODE_ODD_LENGTH: u32 = 512;
pub const IS_TEXT_UNICODE_DBCS_LEADBYTE: u32 = 1024;
pub const IS_TEXT_UNICODE_NULL_BYTES: u32 = 4096;
pub const IS_TEXT_UNICODE_UNICODE_MASK: u32 = 15;
pub const IS_TEXT_UNICODE_REVERSE_MASK: u32 = 240;
pub const IS_TEXT_UNICODE_NOT_UNICODE_MASK: u32 = 3840;
pub const IS_TEXT_UNICODE_NOT_ASCII_MASK: u32 = 61440;
pub const COMPRESSION_FORMAT_NONE: u32 = 0;
pub const COMPRESSION_FORMAT_DEFAULT: u32 = 1;
pub const COMPRESSION_FORMAT_LZNT1: u32 = 2;
pub const COMPRESSION_FORMAT_XPRESS: u32 = 3;
pub const COMPRESSION_FORMAT_XPRESS_HUFF: u32 = 4;
pub const COMPRESSION_ENGINE_STANDARD: u32 = 0;
pub const COMPRESSION_ENGINE_MAXIMUM: u32 = 256;
pub const COMPRESSION_ENGINE_HIBER: u32 = 512;
pub const SEF_DACL_AUTO_INHERIT: u32 = 1;
pub const SEF_SACL_AUTO_INHERIT: u32 = 2;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT: u32 = 4;
pub const SEF_AVOID_PRIVILEGE_CHECK: u32 = 8;
pub const SEF_AVOID_OWNER_CHECK: u32 = 16;
pub const SEF_DEFAULT_OWNER_FROM_PARENT: u32 = 32;
pub const SEF_DEFAULT_GROUP_FROM_PARENT: u32 = 64;
pub const SEF_MACL_NO_WRITE_UP: u32 = 256;
pub const SEF_MACL_NO_READ_UP: u32 = 512;
pub const SEF_MACL_NO_EXECUTE_UP: u32 = 1024;
pub const SEF_AI_USE_EXTRA_PARAMS: u32 = 2048;
pub const SEF_AVOID_OWNER_RESTRICTION: u32 = 4096;
pub const SEF_FORCE_USER_MODE: u32 = 8192;
pub const SEF_MACL_VALID_FLAGS: u32 = 1792;
pub const MESSAGE_RESOURCE_UNICODE: u32 = 1;
pub const VER_EQUAL: u32 = 1;
pub const VER_GREATER: u32 = 2;
pub const VER_GREATER_EQUAL: u32 = 3;
pub const VER_LESS: u32 = 4;
pub const VER_LESS_EQUAL: u32 = 5;
pub const VER_AND: u32 = 6;
pub const VER_OR: u32 = 7;
pub const VER_CONDITION_MASK: u32 = 7;
pub const VER_NUM_BITS_PER_CONDITION_MASK: u32 = 3;
pub const VER_MINORVERSION: u32 = 1;
pub const VER_MAJORVERSION: u32 = 2;
pub const VER_BUILDNUMBER: u32 = 4;
pub const VER_PLATFORMID: u32 = 8;
pub const VER_SERVICEPACKMINOR: u32 = 16;
pub const VER_SERVICEPACKMAJOR: u32 = 32;
pub const VER_SUITENAME: u32 = 64;
pub const VER_PRODUCT_TYPE: u32 = 128;
pub const VER_NT_WORKSTATION: u32 = 1;
pub const VER_NT_DOMAIN_CONTROLLER: u32 = 2;
pub const VER_NT_SERVER: u32 = 3;
pub const VER_PLATFORM_WIN32s: u32 = 0;
pub const VER_PLATFORM_WIN32_WINDOWS: u32 = 1;
pub const VER_PLATFORM_WIN32_NT: u32 = 2;
pub const RTL_UMS_VERSION: u32 = 256;
pub const VRL_PREDEFINED_CLASS_BEGIN: u32 = 1;
pub const VRL_CUSTOM_CLASS_BEGIN: u32 = 256;
pub const VRL_CLASS_CONSISTENCY: u32 = 1;
pub const VRL_ENABLE_KERNEL_BREAKS: u32 = 2147483648;
pub const CTMF_INCLUDE_APPCONTAINER: u32 = 1;
pub const CTMF_INCLUDE_LPAC: u32 = 2;
pub const CTMF_VALID_FLAGS: u32 = 3;
pub const FLUSH_NV_MEMORY_IN_FLAG_NO_DRAIN: u32 = 1;
pub const WRITE_NV_MEMORY_FLAG_FLUSH: u32 = 1;
pub const WRITE_NV_MEMORY_FLAG_NON_TEMPORAL: u32 = 2;
pub const WRITE_NV_MEMORY_FLAG_PERSIST: u32 = 3;
pub const WRITE_NV_MEMORY_FLAG_NO_DRAIN: u32 = 256;
pub const RTL_CORRELATION_VECTOR_STRING_LENGTH: u32 = 129;
pub const RTL_CORRELATION_VECTOR_V1_PREFIX_LENGTH: u32 = 16;
pub const RTL_CORRELATION_VECTOR_V1_LENGTH: u32 = 64;
pub const RTL_CORRELATION_VECTOR_V2_PREFIX_LENGTH: u32 = 22;
pub const RTL_CORRELATION_VECTOR_V2_LENGTH: u32 = 128;
pub const IMAGE_POLICY_METADATA_VERSION: u32 = 1;
pub const IMAGE_POLICY_SECTION_NAME: &'static [u8; 9usize] = b".tPolicy\0";
pub const RTL_CRITICAL_SECTION_FLAG_NO_DEBUG_INFO: u32 = 16777216;
pub const RTL_CRITICAL_SECTION_FLAG_DYNAMIC_SPIN: u32 = 33554432;
pub const RTL_CRITICAL_SECTION_FLAG_STATIC_INIT: u32 = 67108864;
pub const RTL_CRITICAL_SECTION_FLAG_RESOURCE_TYPE: u32 = 134217728;
pub const RTL_CRITICAL_SECTION_FLAG_FORCE_DEBUG_INFO: u32 = 268435456;
pub const RTL_CRITICAL_SECTION_ALL_FLAG_BITS: u32 = 4278190080;
pub const RTL_CRITICAL_SECTION_FLAG_RESERVED: u32 = 3758096384;
pub const RTL_CRITICAL_SECTION_DEBUG_FLAG_STATIC_INIT: u32 = 1;
pub const RTL_CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;
pub const HEAP_OPTIMIZE_RESOURCES_CURRENT_VERSION: u32 = 1;
pub const WT_EXECUTEDEFAULT: u32 = 0;
pub const WT_EXECUTEINIOTHREAD: u32 = 1;
pub const WT_EXECUTEINUITHREAD: u32 = 2;
pub const WT_EXECUTEINWAITTHREAD: u32 = 4;
pub const WT_EXECUTEONLYONCE: u32 = 8;
pub const WT_EXECUTEINTIMERTHREAD: u32 = 32;
pub const WT_EXECUTELONGFUNCTION: u32 = 16;
pub const WT_EXECUTEINPERSISTENTIOTHREAD: u32 = 64;
pub const WT_EXECUTEINPERSISTENTTHREAD: u32 = 128;
pub const WT_TRANSFER_IMPERSONATION: u32 = 256;
pub const WT_EXECUTEINLONGTHREAD: u32 = 16;
pub const WT_EXECUTEDELETEWAIT: u32 = 8;
pub const ACTIVATION_CONTEXT_PATH_TYPE_NONE: u32 = 1;
pub const ACTIVATION_CONTEXT_PATH_TYPE_WIN32_FILE: u32 = 2;
pub const ACTIVATION_CONTEXT_PATH_TYPE_URL: u32 = 3;
pub const ACTIVATION_CONTEXT_PATH_TYPE_ASSEMBLYREF: u32 = 4;
pub const CREATE_BOUNDARY_DESCRIPTOR_ADD_APPCONTAINER_SID: u32 = 1;
pub const PERFORMANCE_DATA_VERSION: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_DISPATCHING: u32 = 1;
pub const READ_THREAD_PROFILING_FLAG_HARDWARE_COUNTERS: u32 = 2;
pub const UNIFIEDBUILDREVISION_KEY: &'static [u8; 68usize] =
    b"\\Registry\\\\Machine\\\\Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\0";
pub const UNIFIEDBUILDREVISION_VALUE: &'static [u8; 4usize] = b"UBR\0";
pub const UNIFIEDBUILDREVISION_MIN: u32 = 0;
pub const DEVICEFAMILYDEVICEFORM_KEY: &'static [u8; 73usize] =
    b"\\Registry\\\\Machine\\\\Software\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\OEM\0";
pub const DEVICEFAMILYDEVICEFORM_VALUE: &'static [u8; 11usize] = b"DeviceForm\0";
pub const DEVICEFAMILYINFOENUM_UAP: u32 = 0;
pub const DEVICEFAMILYINFOENUM_WINDOWS_8X: u32 = 1;
pub const DEVICEFAMILYINFOENUM_WINDOWS_PHONE_8X: u32 = 2;
pub const DEVICEFAMILYINFOENUM_DESKTOP: u32 = 3;
pub const DEVICEFAMILYINFOENUM_MOBILE: u32 = 4;
pub const DEVICEFAMILYINFOENUM_XBOX: u32 = 5;
pub const DEVICEFAMILYINFOENUM_TEAM: u32 = 6;
pub const DEVICEFAMILYINFOENUM_IOT: u32 = 7;
pub const DEVICEFAMILYINFOENUM_IOT_HEADLESS: u32 = 8;
pub const DEVICEFAMILYINFOENUM_SERVER: u32 = 9;
pub const DEVICEFAMILYINFOENUM_HOLOGRAPHIC: u32 = 10;
pub const DEVICEFAMILYINFOENUM_XBOXSRA: u32 = 11;
pub const DEVICEFAMILYINFOENUM_XBOXERA: u32 = 12;
pub const DEVICEFAMILYINFOENUM_SERVER_NANO: u32 = 13;
pub const DEVICEFAMILYINFOENUM_8828080: u32 = 14;
pub const DEVICEFAMILYINFOENUM_7067329: u32 = 15;
pub const DEVICEFAMILYINFOENUM_WINDOWS_CORE: u32 = 16;
pub const DEVICEFAMILYINFOENUM_MAX: u32 = 16;
pub const DEVICEFAMILYDEVICEFORM_UNKNOWN: u32 = 0;
pub const DEVICEFAMILYDEVICEFORM_PHONE: u32 = 1;
pub const DEVICEFAMILYDEVICEFORM_TABLET: u32 = 2;
pub const DEVICEFAMILYDEVICEFORM_DESKTOP: u32 = 3;
pub const DEVICEFAMILYDEVICEFORM_NOTEBOOK: u32 = 4;
pub const DEVICEFAMILYDEVICEFORM_CONVERTIBLE: u32 = 5;
pub const DEVICEFAMILYDEVICEFORM_DETACHABLE: u32 = 6;
pub const DEVICEFAMILYDEVICEFORM_ALLINONE: u32 = 7;
pub const DEVICEFAMILYDEVICEFORM_STICKPC: u32 = 8;
pub const DEVICEFAMILYDEVICEFORM_PUCK: u32 = 9;
pub const DEVICEFAMILYDEVICEFORM_LARGESCREEN: u32 = 10;
pub const DEVICEFAMILYDEVICEFORM_HMD: u32 = 11;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_HANDHELD: u32 = 12;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_TABLET: u32 = 13;
pub const DEVICEFAMILYDEVICEFORM_BANKING: u32 = 14;
pub const DEVICEFAMILYDEVICEFORM_BUILDING_AUTOMATION: u32 = 15;
pub const DEVICEFAMILYDEVICEFORM_DIGITAL_SIGNAGE: u32 = 16;
pub const DEVICEFAMILYDEVICEFORM_GAMING: u32 = 17;
pub const DEVICEFAMILYDEVICEFORM_HOME_AUTOMATION: u32 = 18;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRIAL_AUTOMATION: u32 = 19;
pub const DEVICEFAMILYDEVICEFORM_KIOSK: u32 = 20;
pub const DEVICEFAMILYDEVICEFORM_MAKER_BOARD: u32 = 21;
pub const DEVICEFAMILYDEVICEFORM_MEDICAL: u32 = 22;
pub const DEVICEFAMILYDEVICEFORM_NETWORKING: u32 = 23;
pub const DEVICEFAMILYDEVICEFORM_POINT_OF_SERVICE: u32 = 24;
pub const DEVICEFAMILYDEVICEFORM_PRINTING: u32 = 25;
pub const DEVICEFAMILYDEVICEFORM_THIN_CLIENT: u32 = 26;
pub const DEVICEFAMILYDEVICEFORM_TOY: u32 = 27;
pub const DEVICEFAMILYDEVICEFORM_VENDING: u32 = 28;
pub const DEVICEFAMILYDEVICEFORM_INDUSTRY_OTHER: u32 = 29;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE: u32 = 30;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_S: u32 = 31;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X: u32 = 32;
pub const DEVICEFAMILYDEVICEFORM_XBOX_ONE_X_DEVKIT: u32 = 33;
pub const DEVICEFAMILYDEVICEFORM_MAX: u32 = 33;
pub const DLL_PROCESS_ATTACH: u32 = 1;
pub const DLL_THREAD_ATTACH: u32 = 2;
pub const DLL_THREAD_DETACH: u32 = 3;
pub const DLL_PROCESS_DETACH: u32 = 0;
pub const EVENTLOG_SEQUENTIAL_READ: u32 = 1;
pub const EVENTLOG_SEEK_READ: u32 = 2;
pub const EVENTLOG_FORWARDS_READ: u32 = 4;
pub const EVENTLOG_BACKWARDS_READ: u32 = 8;
pub const EVENTLOG_SUCCESS: u32 = 0;
pub const EVENTLOG_ERROR_TYPE: u32 = 1;
pub const EVENTLOG_WARNING_TYPE: u32 = 2;
pub const EVENTLOG_INFORMATION_TYPE: u32 = 4;
pub const EVENTLOG_AUDIT_SUCCESS: u32 = 8;
pub const EVENTLOG_AUDIT_FAILURE: u32 = 16;
pub const EVENTLOG_START_PAIRED_EVENT: u32 = 1;
pub const EVENTLOG_END_PAIRED_EVENT: u32 = 2;
pub const EVENTLOG_END_ALL_PAIRED_EVENTS: u32 = 4;
pub const EVENTLOG_PAIRED_EVENT_ACTIVE: u32 = 8;
pub const EVENTLOG_PAIRED_EVENT_INACTIVE: u32 = 16;
pub const MAXLOGICALLOGNAMESIZE: u32 = 256;
pub const KEY_QUERY_VALUE: u32 = 1;
pub const KEY_SET_VALUE: u32 = 2;
pub const KEY_CREATE_SUB_KEY: u32 = 4;
pub const KEY_ENUMERATE_SUB_KEYS: u32 = 8;
pub const KEY_NOTIFY: u32 = 16;
pub const KEY_CREATE_LINK: u32 = 32;
pub const KEY_WOW64_32KEY: u32 = 512;
pub const KEY_WOW64_64KEY: u32 = 256;
pub const KEY_WOW64_RES: u32 = 768;
pub const KEY_READ: u32 = 131097;
pub const KEY_WRITE: u32 = 131078;
pub const KEY_EXECUTE: u32 = 131097;
pub const KEY_ALL_ACCESS: u32 = 983103;
pub const REG_OPTION_RESERVED: u32 = 0;
pub const REG_OPTION_NON_VOLATILE: u32 = 0;
pub const REG_OPTION_VOLATILE: u32 = 1;
pub const REG_OPTION_CREATE_LINK: u32 = 2;
pub const REG_OPTION_BACKUP_RESTORE: u32 = 4;
pub const REG_OPTION_OPEN_LINK: u32 = 8;
pub const REG_OPTION_DONT_VIRTUALIZE: u32 = 16;
pub const REG_LEGAL_OPTION: u32 = 31;
pub const REG_OPEN_LEGAL_OPTION: u32 = 28;
pub const REG_CREATED_NEW_KEY: u32 = 1;
pub const REG_OPENED_EXISTING_KEY: u32 = 2;
pub const REG_STANDARD_FORMAT: u32 = 1;
pub const REG_LATEST_FORMAT: u32 = 2;
pub const REG_NO_COMPRESSION: u32 = 4;
pub const REG_WHOLE_HIVE_VOLATILE: u32 = 1;
pub const REG_REFRESH_HIVE: u32 = 2;
pub const REG_NO_LAZY_FLUSH: u32 = 4;
pub const REG_FORCE_RESTORE: u32 = 8;
pub const REG_APP_HIVE: u32 = 16;
pub const REG_PROCESS_PRIVATE: u32 = 32;
pub const REG_START_JOURNAL: u32 = 64;
pub const REG_HIVE_EXACT_FILE_GROWTH: u32 = 128;
pub const REG_HIVE_NO_RM: u32 = 256;
pub const REG_HIVE_SINGLE_LOG: u32 = 512;
pub const REG_BOOT_HIVE: u32 = 1024;
pub const REG_LOAD_HIVE_OPEN_HANDLE: u32 = 2048;
pub const REG_FLUSH_HIVE_FILE_GROWTH: u32 = 4096;
pub const REG_OPEN_READ_ONLY: u32 = 8192;
pub const REG_IMMUTABLE: u32 = 16384;
pub const REG_APP_HIVE_OPEN_READ_ONLY: u32 = 8192;
pub const REG_FORCE_UNLOAD: u32 = 1;
pub const REG_UNLOAD_LEGAL_FLAGS: u32 = 1;
pub const REG_NOTIFY_CHANGE_NAME: u32 = 1;
pub const REG_NOTIFY_CHANGE_ATTRIBUTES: u32 = 2;
pub const REG_NOTIFY_CHANGE_LAST_SET: u32 = 4;
pub const REG_NOTIFY_CHANGE_SECURITY: u32 = 8;
pub const REG_NOTIFY_THREAD_AGNOSTIC: u32 = 268435456;
pub const REG_LEGAL_CHANGE_FILTER: u32 = 268435471;
pub const REG_NONE: u32 = 0;
pub const REG_SZ: u32 = 1;
pub const REG_EXPAND_SZ: u32 = 2;
pub const REG_BINARY: u32 = 3;
pub const REG_DWORD: u32 = 4;
pub const REG_DWORD_LITTLE_ENDIAN: u32 = 4;
pub const REG_DWORD_BIG_ENDIAN: u32 = 5;
pub const REG_LINK: u32 = 6;
pub const REG_MULTI_SZ: u32 = 7;
pub const REG_RESOURCE_LIST: u32 = 8;
pub const REG_FULL_RESOURCE_DESCRIPTOR: u32 = 9;
pub const REG_RESOURCE_REQUIREMENTS_LIST: u32 = 10;
pub const REG_QWORD: u32 = 11;
pub const REG_QWORD_LITTLE_ENDIAN: u32 = 11;
pub const SERVICE_KERNEL_DRIVER: u32 = 1;
pub const SERVICE_FILE_SYSTEM_DRIVER: u32 = 2;
pub const SERVICE_ADAPTER: u32 = 4;
pub const SERVICE_RECOGNIZER_DRIVER: u32 = 8;
pub const SERVICE_DRIVER: u32 = 11;
pub const SERVICE_WIN32_OWN_PROCESS: u32 = 16;
pub const SERVICE_WIN32_SHARE_PROCESS: u32 = 32;
pub const SERVICE_WIN32: u32 = 48;
pub const SERVICE_USER_SERVICE: u32 = 64;
pub const SERVICE_USERSERVICE_INSTANCE: u32 = 128;
pub const SERVICE_USER_SHARE_PROCESS: u32 = 96;
pub const SERVICE_USER_OWN_PROCESS: u32 = 80;
pub const SERVICE_INTERACTIVE_PROCESS: u32 = 256;
pub const SERVICE_PKG_SERVICE: u32 = 512;
pub const SERVICE_TYPE_ALL: u32 = 1023;
pub const SERVICE_BOOT_START: u32 = 0;
pub const SERVICE_SYSTEM_START: u32 = 1;
pub const SERVICE_AUTO_START: u32 = 2;
pub const SERVICE_DEMAND_START: u32 = 3;
pub const SERVICE_DISABLED: u32 = 4;
pub const SERVICE_ERROR_IGNORE: u32 = 0;
pub const SERVICE_ERROR_NORMAL: u32 = 1;
pub const SERVICE_ERROR_SEVERE: u32 = 2;
pub const SERVICE_ERROR_CRITICAL: u32 = 3;
pub const CM_SERVICE_NETWORK_BOOT_LOAD: u32 = 1;
pub const CM_SERVICE_VIRTUAL_DISK_BOOT_LOAD: u32 = 2;
pub const CM_SERVICE_USB_DISK_BOOT_LOAD: u32 = 4;
pub const CM_SERVICE_SD_DISK_BOOT_LOAD: u32 = 8;
pub const CM_SERVICE_USB3_DISK_BOOT_LOAD: u32 = 16;
pub const CM_SERVICE_MEASURED_BOOT_LOAD: u32 = 32;
pub const CM_SERVICE_VERIFIER_BOOT_LOAD: u32 = 64;
pub const CM_SERVICE_WINPE_BOOT_LOAD: u32 = 128;
pub const CM_SERVICE_RAM_DISK_BOOT_LOAD: u32 = 256;
pub const CM_SERVICE_VALID_PROMOTION_MASK: u32 = 511;
pub const TAPE_ERASE_SHORT: u32 = 0;
pub const TAPE_ERASE_LONG: u32 = 1;
pub const TAPE_LOAD: u32 = 0;
pub const TAPE_UNLOAD: u32 = 1;
pub const TAPE_TENSION: u32 = 2;
pub const TAPE_LOCK: u32 = 3;
pub const TAPE_UNLOCK: u32 = 4;
pub const TAPE_FORMAT: u32 = 5;
pub const TAPE_SETMARKS: u32 = 0;
pub const TAPE_FILEMARKS: u32 = 1;
pub const TAPE_SHORT_FILEMARKS: u32 = 2;
pub const TAPE_LONG_FILEMARKS: u32 = 3;
pub const TAPE_ABSOLUTE_POSITION: u32 = 0;
pub const TAPE_LOGICAL_POSITION: u32 = 1;
pub const TAPE_PSEUDO_LOGICAL_POSITION: u32 = 2;
pub const TAPE_REWIND: u32 = 0;
pub const TAPE_ABSOLUTE_BLOCK: u32 = 1;
pub const TAPE_LOGICAL_BLOCK: u32 = 2;
pub const TAPE_PSEUDO_LOGICAL_BLOCK: u32 = 3;
pub const TAPE_SPACE_END_OF_DATA: u32 = 4;
pub const TAPE_SPACE_RELATIVE_BLOCKS: u32 = 5;
pub const TAPE_SPACE_FILEMARKS: u32 = 6;
pub const TAPE_SPACE_SEQUENTIAL_FMKS: u32 = 7;
pub const TAPE_SPACE_SETMARKS: u32 = 8;
pub const TAPE_SPACE_SEQUENTIAL_SMKS: u32 = 9;
pub const TAPE_DRIVE_FIXED: u32 = 1;
pub const TAPE_DRIVE_SELECT: u32 = 2;
pub const TAPE_DRIVE_INITIATOR: u32 = 4;
pub const TAPE_DRIVE_ERASE_SHORT: u32 = 16;
pub const TAPE_DRIVE_ERASE_LONG: u32 = 32;
pub const TAPE_DRIVE_ERASE_BOP_ONLY: u32 = 64;
pub const TAPE_DRIVE_ERASE_IMMEDIATE: u32 = 128;
pub const TAPE_DRIVE_TAPE_CAPACITY: u32 = 256;
pub const TAPE_DRIVE_TAPE_REMAINING: u32 = 512;
pub const TAPE_DRIVE_FIXED_BLOCK: u32 = 1024;
pub const TAPE_DRIVE_VARIABLE_BLOCK: u32 = 2048;
pub const TAPE_DRIVE_WRITE_PROTECT: u32 = 4096;
pub const TAPE_DRIVE_EOT_WZ_SIZE: u32 = 8192;
pub const TAPE_DRIVE_ECC: u32 = 65536;
pub const TAPE_DRIVE_COMPRESSION: u32 = 131072;
pub const TAPE_DRIVE_PADDING: u32 = 262144;
pub const TAPE_DRIVE_REPORT_SMKS: u32 = 524288;
pub const TAPE_DRIVE_GET_ABSOLUTE_BLK: u32 = 1048576;
pub const TAPE_DRIVE_GET_LOGICAL_BLK: u32 = 2097152;
pub const TAPE_DRIVE_SET_EOT_WZ_SIZE: u32 = 4194304;
pub const TAPE_DRIVE_EJECT_MEDIA: u32 = 16777216;
pub const TAPE_DRIVE_CLEAN_REQUESTS: u32 = 33554432;
pub const TAPE_DRIVE_SET_CMP_BOP_ONLY: u32 = 67108864;
pub const TAPE_DRIVE_RESERVED_BIT: u32 = 2147483648;
pub const TAPE_DRIVE_LOAD_UNLOAD: u32 = 2147483649;
pub const TAPE_DRIVE_TENSION: u32 = 2147483650;
pub const TAPE_DRIVE_LOCK_UNLOCK: u32 = 2147483652;
pub const TAPE_DRIVE_REWIND_IMMEDIATE: u32 = 2147483656;
pub const TAPE_DRIVE_SET_BLOCK_SIZE: u32 = 2147483664;
pub const TAPE_DRIVE_LOAD_UNLD_IMMED: u32 = 2147483680;
pub const TAPE_DRIVE_TENSION_IMMED: u32 = 2147483712;
pub const TAPE_DRIVE_LOCK_UNLK_IMMED: u32 = 2147483776;
pub const TAPE_DRIVE_SET_ECC: u32 = 2147483904;
pub const TAPE_DRIVE_SET_COMPRESSION: u32 = 2147484160;
pub const TAPE_DRIVE_SET_PADDING: u32 = 2147484672;
pub const TAPE_DRIVE_SET_REPORT_SMKS: u32 = 2147485696;
pub const TAPE_DRIVE_ABSOLUTE_BLK: u32 = 2147487744;
pub const TAPE_DRIVE_ABS_BLK_IMMED: u32 = 2147491840;
pub const TAPE_DRIVE_LOGICAL_BLK: u32 = 2147500032;
pub const TAPE_DRIVE_LOG_BLK_IMMED: u32 = 2147516416;
pub const TAPE_DRIVE_END_OF_DATA: u32 = 2147549184;
pub const TAPE_DRIVE_RELATIVE_BLKS: u32 = 2147614720;
pub const TAPE_DRIVE_FILEMARKS: u32 = 2147745792;
pub const TAPE_DRIVE_SEQUENTIAL_FMKS: u32 = 2148007936;
pub const TAPE_DRIVE_SETMARKS: u32 = 2148532224;
pub const TAPE_DRIVE_SEQUENTIAL_SMKS: u32 = 2149580800;
pub const TAPE_DRIVE_REVERSE_POSITION: u32 = 2151677952;
pub const TAPE_DRIVE_SPACE_IMMEDIATE: u32 = 2155872256;
pub const TAPE_DRIVE_WRITE_SETMARKS: u32 = 2164260864;
pub const TAPE_DRIVE_WRITE_FILEMARKS: u32 = 2181038080;
pub const TAPE_DRIVE_WRITE_SHORT_FMKS: u32 = 2214592512;
pub const TAPE_DRIVE_WRITE_LONG_FMKS: u32 = 2281701376;
pub const TAPE_DRIVE_WRITE_MARK_IMMED: u32 = 2415919104;
pub const TAPE_DRIVE_FORMAT: u32 = 2684354560;
pub const TAPE_DRIVE_FORMAT_IMMEDIATE: u32 = 3221225472;
pub const TAPE_DRIVE_HIGH_FEATURES: u32 = 2147483648;
pub const TAPE_FIXED_PARTITIONS: u32 = 0;
pub const TAPE_SELECT_PARTITIONS: u32 = 1;
pub const TAPE_INITIATOR_PARTITIONS: u32 = 2;
pub const TAPE_QUERY_DRIVE_PARAMETERS: u32 = 0;
pub const TAPE_QUERY_MEDIA_CAPACITY: u32 = 1;
pub const TAPE_CHECK_FOR_DRIVE_PROBLEM: u32 = 2;
pub const TAPE_QUERY_IO_ERROR_DATA: u32 = 3;
pub const TAPE_QUERY_DEVICE_ERROR_DATA: u32 = 4;
pub const TRANSACTION_MANAGER_VOLATILE: u32 = 1;
pub const TRANSACTION_MANAGER_COMMIT_DEFAULT: u32 = 0;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME: u32 = 2;
pub const TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES: u32 = 4;
pub const TRANSACTION_MANAGER_COMMIT_LOWEST: u32 = 8;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY: u32 = 16;
pub const TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS: u32 = 32;
pub const TRANSACTION_MANAGER_MAXIMUM_OPTION: u32 = 63;
pub const TRANSACTION_DO_NOT_PROMOTE: u32 = 1;
pub const TRANSACTION_MAXIMUM_OPTION: u32 = 1;
pub const RESOURCE_MANAGER_VOLATILE: u32 = 1;
pub const RESOURCE_MANAGER_COMMUNICATION: u32 = 2;
pub const RESOURCE_MANAGER_MAXIMUM_OPTION: u32 = 3;
pub const CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY: u32 = 1;
pub const CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO: u32 = 2;
pub const CRM_PROTOCOL_MAXIMUM_OPTION: u32 = 3;
pub const ENLISTMENT_SUPERIOR: u32 = 1;
pub const ENLISTMENT_MAXIMUM_OPTION: u32 = 1;
pub const TRANSACTION_NOTIFY_MASK: u32 = 1073741823;
pub const TRANSACTION_NOTIFY_PREPREPARE: u32 = 1;
pub const TRANSACTION_NOTIFY_PREPARE: u32 = 2;
pub const TRANSACTION_NOTIFY_COMMIT: u32 = 4;
pub const TRANSACTION_NOTIFY_ROLLBACK: u32 = 8;
pub const TRANSACTION_NOTIFY_PREPREPARE_COMPLETE: u32 = 16;
pub const TRANSACTION_NOTIFY_PREPARE_COMPLETE: u32 = 32;
pub const TRANSACTION_NOTIFY_COMMIT_COMPLETE: u32 = 64;
pub const TRANSACTION_NOTIFY_ROLLBACK_COMPLETE: u32 = 128;
pub const TRANSACTION_NOTIFY_RECOVER: u32 = 256;
pub const TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT: u32 = 512;
pub const TRANSACTION_NOTIFY_DELEGATE_COMMIT: u32 = 1024;
pub const TRANSACTION_NOTIFY_RECOVER_QUERY: u32 = 2048;
pub const TRANSACTION_NOTIFY_ENLIST_PREPREPARE: u32 = 4096;
pub const TRANSACTION_NOTIFY_LAST_RECOVER: u32 = 8192;
pub const TRANSACTION_NOTIFY_INDOUBT: u32 = 16384;
pub const TRANSACTION_NOTIFY_PROPAGATE_PULL: u32 = 32768;
pub const TRANSACTION_NOTIFY_PROPAGATE_PUSH: u32 = 65536;
pub const TRANSACTION_NOTIFY_MARSHAL: u32 = 131072;
pub const TRANSACTION_NOTIFY_ENLIST_MASK: u32 = 262144;
pub const TRANSACTION_NOTIFY_RM_DISCONNECTED: u32 = 16777216;
pub const TRANSACTION_NOTIFY_TM_ONLINE: u32 = 33554432;
pub const TRANSACTION_NOTIFY_COMMIT_REQUEST: u32 = 67108864;
pub const TRANSACTION_NOTIFY_PROMOTE: u32 = 134217728;
pub const TRANSACTION_NOTIFY_PROMOTE_NEW: u32 = 268435456;
pub const TRANSACTION_NOTIFY_REQUEST_OUTCOME: u32 = 536870912;
pub const TRANSACTION_NOTIFY_COMMIT_FINALIZE: u32 = 1073741824;
pub const TRANSACTIONMANAGER_OBJECT_PATH: &'static [u8; 22usize] = b"\\TransactionManager\\\\\0";
pub const TRANSACTION_OBJECT_PATH: &'static [u8; 15usize] = b"\\Transaction\\\\\0";
pub const ENLISTMENT_OBJECT_PATH: &'static [u8; 14usize] = b"\\Enlistment\\\\\0";
pub const RESOURCE_MANAGER_OBJECT_PATH: &'static [u8; 19usize] = b"\\ResourceManager\\\\\0";
pub const TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MAJOR: u32 = 1;
pub const KTM_MARSHAL_BLOB_VERSION_MINOR: u32 = 1;
pub const MAX_TRANSACTION_DESCRIPTION_LENGTH: u32 = 64;
pub const MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH: u32 = 64;
pub const TRANSACTIONMANAGER_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTIONMANAGER_SET_INFORMATION: u32 = 2;
pub const TRANSACTIONMANAGER_RECOVER: u32 = 4;
pub const TRANSACTIONMANAGER_RENAME: u32 = 8;
pub const TRANSACTIONMANAGER_CREATE_RM: u32 = 16;
pub const TRANSACTIONMANAGER_BIND_TRANSACTION: u32 = 32;
pub const TRANSACTIONMANAGER_GENERIC_READ: u32 = 131073;
pub const TRANSACTIONMANAGER_GENERIC_WRITE: u32 = 131102;
pub const TRANSACTIONMANAGER_GENERIC_EXECUTE: u32 = 131072;
pub const TRANSACTIONMANAGER_ALL_ACCESS: u32 = 983103;
pub const TRANSACTION_QUERY_INFORMATION: u32 = 1;
pub const TRANSACTION_SET_INFORMATION: u32 = 2;
pub const TRANSACTION_ENLIST: u32 = 4;
pub const TRANSACTION_COMMIT: u32 = 8;
pub const TRANSACTION_ROLLBACK: u32 = 16;
pub const TRANSACTION_PROPAGATE: u32 = 32;
pub const TRANSACTION_RIGHT_RESERVED1: u32 = 64;
pub const TRANSACTION_GENERIC_READ: u32 = 1179649;
pub const TRANSACTION_GENERIC_WRITE: u32 = 1179710;
pub const TRANSACTION_GENERIC_EXECUTE: u32 = 1179672;
pub const TRANSACTION_ALL_ACCESS: u32 = 2031679;
pub const TRANSACTION_RESOURCE_MANAGER_RIGHTS: u32 = 1179703;
pub const RESOURCEMANAGER_QUERY_INFORMATION: u32 = 1;
pub const RESOURCEMANAGER_SET_INFORMATION: u32 = 2;
pub const RESOURCEMANAGER_RECOVER: u32 = 4;
pub const RESOURCEMANAGER_ENLIST: u32 = 8;
pub const RESOURCEMANAGER_GET_NOTIFICATION: u32 = 16;
pub const RESOURCEMANAGER_REGISTER_PROTOCOL: u32 = 32;
pub const RESOURCEMANAGER_COMPLETE_PROPAGATION: u32 = 64;
pub const RESOURCEMANAGER_GENERIC_READ: u32 = 1179649;
pub const RESOURCEMANAGER_GENERIC_WRITE: u32 = 1179774;
pub const RESOURCEMANAGER_GENERIC_EXECUTE: u32 = 1179740;
pub const RESOURCEMANAGER_ALL_ACCESS: u32 = 2031743;
pub const ENLISTMENT_QUERY_INFORMATION: u32 = 1;
pub const ENLISTMENT_SET_INFORMATION: u32 = 2;
pub const ENLISTMENT_RECOVER: u32 = 4;
pub const ENLISTMENT_SUBORDINATE_RIGHTS: u32 = 8;
pub const ENLISTMENT_SUPERIOR_RIGHTS: u32 = 16;
pub const ENLISTMENT_GENERIC_READ: u32 = 131073;
pub const ENLISTMENT_GENERIC_WRITE: u32 = 131102;
pub const ENLISTMENT_GENERIC_EXECUTE: u32 = 131100;
pub const ENLISTMENT_ALL_ACCESS: u32 = 983071;
pub const ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION: u32 = 1;
pub const ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION: u32 = 2;
pub const ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION: u32 = 3;
pub const ACTIVATION_CONTEXT_SECTION_COM_SERVER_REDIRECTION: u32 = 4;
pub const ACTIVATION_CONTEXT_SECTION_COM_INTERFACE_REDIRECTION: u32 = 5;
pub const ACTIVATION_CONTEXT_SECTION_COM_TYPE_LIBRARY_REDIRECTION: u32 = 6;
pub const ACTIVATION_CONTEXT_SECTION_COM_PROGID_REDIRECTION: u32 = 7;
pub const ACTIVATION_CONTEXT_SECTION_GLOBAL_OBJECT_RENAME_TABLE: u32 = 8;
pub const ACTIVATION_CONTEXT_SECTION_CLR_SURROGATES: u32 = 9;
pub const ACTIVATION_CONTEXT_SECTION_APPLICATION_SETTINGS: u32 = 10;
pub const ACTIVATION_CONTEXT_SECTION_COMPATIBILITY_INFO: u32 = 11;
pub type ULONG = ::std::os::raw::c_ulong;
pub type PULONG = *mut ULONG;
pub type USHORT = ::std::os::raw::c_ushort;
pub type PUSHORT = *mut USHORT;
pub type UCHAR = ::std::os::raw::c_uchar;
pub type PUCHAR = *mut UCHAR;
pub type PSZ = *mut ::std::os::raw::c_char;
pub type DWORD = ::std::os::raw::c_ulong;
pub type BOOL = ::std::os::raw::c_int;
pub type BYTE = ::std::os::raw::c_uchar;
pub type WORD = ::std::os::raw::c_ushort;
pub type FLOAT = f32;
pub type PFLOAT = *mut FLOAT;
pub type PBOOL = *mut BOOL;
pub type LPBOOL = *mut BOOL;
pub type PBYTE = *mut BYTE;
pub type LPBYTE = *mut BYTE;
pub type PINT = *mut ::std::os::raw::c_int;
pub type LPINT = *mut ::std::os::raw::c_int;
pub type PWORD = *mut WORD;
pub type LPWORD = *mut WORD;
pub type LPLONG = *mut ::std::os::raw::c_long;
pub type PDWORD = *mut DWORD;
pub type LPDWORD = *mut DWORD;
pub type LPVOID = *mut ::std::os::raw::c_void;
pub type LPCVOID = *const ::std::os::raw::c_void;
pub type INT = ::std::os::raw::c_int;
pub type UINT = ::std::os::raw::c_uint;
pub type PUINT = *mut ::std::os::raw::c_uint;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    #[link_name = "\u{1}__security_cookie"]
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_pctype as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_mb_cur_max as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__crt_locale_data_public>()))._locale_lc_codepage as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__crt_locale_pointers>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Wchar as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._Byte as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_Mbstatet>()))._State as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn __pctype_func() -> *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __pwctype_func() -> *const wctype_t;
}
extern "C" {
    pub fn iswalnum(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswascii(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsymf(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iswcsym(_C: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalnum_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswalpha_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswblank_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcntrl_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswgraph_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswlower_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswprint_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswpunct_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswspace_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswupper_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswxdigit_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsymf_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iswcsym_l(_C: wint_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towupper(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn towlower(_C: wint_t) -> wint_t;
}
extern "C" {
    pub fn iswctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _towupper_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _towlower_l(_C: wint_t, _Locale: _locale_t) -> wint_t;
}
extern "C" {
    pub fn _iswctype_l(_C: wint_t, _Type: wctype_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isleadbyte(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isleadbyte_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn is_wctype(_C: wint_t, _Type: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isctype_l(
        _C: ::std::os::raw::c_int,
        _Type: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalpha_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _islower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isxdigit_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isspace_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _ispunct_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isblank_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isalnum_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isprint_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _isgraph_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _iscntrl_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper_l(_C: ::std::os::raw::c_int, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toascii(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsymf(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iscsym(_C: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
pub type POINTER_64_INT = ::std::os::raw::c_ulonglong;
pub type INT8 = ::std::os::raw::c_schar;
pub type PINT8 = *mut ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type PINT16 = *mut ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type PINT32 = *mut ::std::os::raw::c_int;
pub type INT64 = ::std::os::raw::c_longlong;
pub type PINT64 = *mut ::std::os::raw::c_longlong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type PUINT8 = *mut ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type PUINT16 = *mut ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type PUINT64 = *mut ::std::os::raw::c_ulonglong;
pub type LONG32 = ::std::os::raw::c_int;
pub type PLONG32 = *mut ::std::os::raw::c_int;
pub type ULONG32 = ::std::os::raw::c_uint;
pub type PULONG32 = *mut ::std::os::raw::c_uint;
pub type DWORD32 = ::std::os::raw::c_uint;
pub type PDWORD32 = *mut ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type PINT_PTR = *mut ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type PUINT_PTR = *mut ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type PLONG_PTR = *mut ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type PULONG_PTR = *mut ::std::os::raw::c_ulonglong;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type HANDLE_PTR = ::std::os::raw::c_ulonglong;
pub type UHALF_PTR = ::std::os::raw::c_uint;
pub type PUHALF_PTR = *mut ::std::os::raw::c_uint;
pub type HALF_PTR = ::std::os::raw::c_int;
pub type PHALF_PTR = *mut ::std::os::raw::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = ::std::os::raw::c_longlong;
pub type PLONG64 = *mut ::std::os::raw::c_longlong;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PULONG64 = *mut ::std::os::raw::c_ulonglong;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type PDWORD64 = *mut ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type PVOID = *mut ::std::os::raw::c_void;
pub type CHAR = ::std::os::raw::c_char;
pub type SHORT = ::std::os::raw::c_short;
pub type LONG = ::std::os::raw::c_long;
pub type WCHAR = wchar_t;
pub type PWCHAR = *mut WCHAR;
pub type LPWCH = *mut WCHAR;
pub type PWCH = *mut WCHAR;
pub type LPCWCH = *const WCHAR;
pub type PCWCH = *const WCHAR;
pub type NWPSTR = *mut WCHAR;
pub type LPWSTR = *mut WCHAR;
pub type PWSTR = *mut WCHAR;
pub type PZPWSTR = *mut PWSTR;
pub type PCZPWSTR = *const PWSTR;
pub type LPUWSTR = *mut WCHAR;
pub type PUWSTR = *mut WCHAR;
pub type LPCWSTR = *const WCHAR;
pub type PCWSTR = *const WCHAR;
pub type PZPCWSTR = *mut PCWSTR;
pub type PCZPCWSTR = *const PCWSTR;
pub type LPCUWSTR = *const WCHAR;
pub type PCUWSTR = *const WCHAR;
pub type PZZWSTR = *mut WCHAR;
pub type PCZZWSTR = *const WCHAR;
pub type PUZZWSTR = *mut WCHAR;
pub type PCUZZWSTR = *const WCHAR;
pub type PNZWCH = *mut WCHAR;
pub type PCNZWCH = *const WCHAR;
pub type PUNZWCH = *mut WCHAR;
pub type PCUNZWCH = *const WCHAR;
pub type PCHAR = *mut CHAR;
pub type LPCH = *mut CHAR;
pub type PCH = *mut CHAR;
pub type LPCCH = *const CHAR;
pub type PCCH = *const CHAR;
pub type NPSTR = *mut CHAR;
pub type LPSTR = *mut CHAR;
pub type PSTR = *mut CHAR;
pub type PZPSTR = *mut PSTR;
pub type PCZPSTR = *const PSTR;
pub type LPCSTR = *const CHAR;
pub type PCSTR = *const CHAR;
pub type PZPCSTR = *mut PCSTR;
pub type PCZPCSTR = *const PCSTR;
pub type PZZSTR = *mut CHAR;
pub type PCZZSTR = *const CHAR;
pub type PNZCH = *mut CHAR;
pub type PCNZCH = *const CHAR;
pub type TCHAR = ::std::os::raw::c_char;
pub type PTCHAR = *mut ::std::os::raw::c_char;
pub type TBYTE = ::std::os::raw::c_uchar;
pub type PTBYTE = *mut ::std::os::raw::c_uchar;
pub type LPTCH = LPCH;
pub type PTCH = LPCH;
pub type LPCTCH = LPCCH;
pub type PCTCH = LPCCH;
pub type PTSTR = LPSTR;
pub type LPTSTR = LPSTR;
pub type PUTSTR = LPSTR;
pub type LPUTSTR = LPSTR;
pub type PCTSTR = LPCSTR;
pub type LPCTSTR = LPCSTR;
pub type PCUTSTR = LPCSTR;
pub type LPCUTSTR = LPCSTR;
pub type PZZTSTR = PZZSTR;
pub type PUZZTSTR = PZZSTR;
pub type PCZZTSTR = PCZZSTR;
pub type PCUZZTSTR = PCZZSTR;
pub type PZPTSTR = PZPSTR;
pub type PNZTCH = PNZCH;
pub type PUNZTCH = PNZCH;
pub type PCNZTCH = PCNZCH;
pub type PCUNZTCH = PCNZCH;
pub type PSHORT = *mut SHORT;
pub type PLONG = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_NUMBER {
    pub Group: WORD,
    pub Number: BYTE,
    pub Reserved: BYTE,
}
#[test]
fn bindgen_test_layout__PROCESSOR_NUMBER() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_NUMBER>(),
        4usize,
        concat!("Size of: ", stringify!(_PROCESSOR_NUMBER))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_NUMBER>(),
        2usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_NUMBER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_NUMBER>())).Group as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_NUMBER),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_NUMBER>())).Number as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_NUMBER),
            "::",
            stringify!(Number)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_NUMBER>())).Reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_NUMBER),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type PROCESSOR_NUMBER = _PROCESSOR_NUMBER;
pub type PPROCESSOR_NUMBER = *mut _PROCESSOR_NUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GROUP_AFFINITY {
    pub Mask: KAFFINITY,
    pub Group: WORD,
    pub Reserved: [WORD; 3usize],
}
#[test]
fn bindgen_test_layout__GROUP_AFFINITY() {
    assert_eq!(
        ::std::mem::size_of::<_GROUP_AFFINITY>(),
        16usize,
        concat!("Size of: ", stringify!(_GROUP_AFFINITY))
    );
    assert_eq!(
        ::std::mem::align_of::<_GROUP_AFFINITY>(),
        8usize,
        concat!("Alignment of ", stringify!(_GROUP_AFFINITY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_AFFINITY),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Group as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_AFFINITY),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GROUP_AFFINITY>())).Reserved as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_AFFINITY),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type GROUP_AFFINITY = _GROUP_AFFINITY;
pub type PGROUP_AFFINITY = *mut _GROUP_AFFINITY;
pub type HANDLE = *mut ::std::os::raw::c_void;
pub type PHANDLE = *mut HANDLE;
pub type FCHAR = BYTE;
pub type FSHORT = WORD;
pub type FLONG = DWORD;
pub type HRESULT = ::std::os::raw::c_long;
pub type CCHAR = ::std::os::raw::c_char;
pub type LCID = DWORD;
pub type PLCID = PDWORD;
pub type LANGID = WORD;
pub const COMPARTMENT_ID_UNSPECIFIED_COMPARTMENT_ID: COMPARTMENT_ID = 0;
pub const COMPARTMENT_ID_DEFAULT_COMPARTMENT_ID: COMPARTMENT_ID = 1;
pub type COMPARTMENT_ID = i32;
pub type PCOMPARTMENT_ID = *mut COMPARTMENT_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FLOAT128 {
    pub LowPart: ::std::os::raw::c_longlong,
    pub HighPart: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__FLOAT128() {
    assert_eq!(
        ::std::mem::size_of::<_FLOAT128>(),
        16usize,
        concat!("Size of: ", stringify!(_FLOAT128))
    );
    assert_eq!(
        ::std::mem::align_of::<_FLOAT128>(),
        8usize,
        concat!("Alignment of ", stringify!(_FLOAT128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FLOAT128>())).LowPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOAT128),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FLOAT128>())).HighPart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FLOAT128),
            "::",
            stringify!(HighPart)
        )
    );
}
pub type FLOAT128 = _FLOAT128;
pub type PFLOAT128 = *mut FLOAT128;
pub type LONGLONG = ::std::os::raw::c_longlong;
pub type ULONGLONG = ::std::os::raw::c_ulonglong;
pub type PLONGLONG = *mut LONGLONG;
pub type PULONGLONG = *mut ULONGLONG;
pub type USN = LONGLONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LARGE_INTEGER {
    pub __bindgen_anon_1: _LARGE_INTEGER__bindgen_ty_1,
    pub u: _LARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: LONGLONG,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__LARGE_INTEGER() {
    assert_eq!(
        ::std::mem::size_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_LARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_LARGE_INTEGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LARGE_INTEGER>())).QuadPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type LARGE_INTEGER = _LARGE_INTEGER;
pub type PLARGE_INTEGER = *mut LARGE_INTEGER;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _ULARGE_INTEGER {
    pub __bindgen_anon_1: _ULARGE_INTEGER__bindgen_ty_1,
    pub u: _ULARGE_INTEGER__bindgen_ty_2,
    pub QuadPart: ULONGLONG,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_1 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).LowPart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_1>())).HighPart as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_1),
            "::",
            stringify!(HighPart)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ULARGE_INTEGER__bindgen_ty_2 {
    pub LowPart: DWORD,
    pub HighPart: DWORD,
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_ULARGE_INTEGER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).LowPart as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ULARGE_INTEGER__bindgen_ty_2>())).HighPart as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER__bindgen_ty_2),
            "::",
            stringify!(HighPart)
        )
    );
}
#[test]
fn bindgen_test_layout__ULARGE_INTEGER() {
    assert_eq!(
        ::std::mem::size_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Size of: ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        ::std::mem::align_of::<_ULARGE_INTEGER>(),
        8usize,
        concat!("Alignment of ", stringify!(_ULARGE_INTEGER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ULARGE_INTEGER>())).u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ULARGE_INTEGER>())).QuadPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ULARGE_INTEGER),
            "::",
            stringify!(QuadPart)
        )
    );
}
pub type ULARGE_INTEGER = _ULARGE_INTEGER;
pub type PULARGE_INTEGER = *mut ULARGE_INTEGER;
pub type RTL_REFERENCE_COUNT = LONG_PTR;
pub type PRTL_REFERENCE_COUNT = *mut LONG_PTR;
pub type RTL_REFERENCE_COUNT32 = LONG;
pub type PRTL_REFERENCE_COUNT32 = *mut LONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID {
    pub LowPart: DWORD,
    pub HighPart: LONG,
}
#[test]
fn bindgen_test_layout__LUID() {
    assert_eq!(
        ::std::mem::size_of::<_LUID>(),
        8usize,
        concat!("Size of: ", stringify!(_LUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_LUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LUID>())).LowPart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID),
            "::",
            stringify!(LowPart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LUID>())).HighPart as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID),
            "::",
            stringify!(HighPart)
        )
    );
}
pub type LUID = _LUID;
pub type PLUID = *mut _LUID;
pub type DWORDLONG = ULONGLONG;
pub type PDWORDLONG = *mut DWORDLONG;
extern "C" {
    pub fn _rotl8(
        Value: ::std::os::raw::c_uchar,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _rotl16(
        Value: ::std::os::raw::c_ushort,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _rotr8(
        Value: ::std::os::raw::c_uchar,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _rotr16(
        Value: ::std::os::raw::c_ushort,
        Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _rotl(
        Value: ::std::os::raw::c_uint,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotl64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        Value: ::std::os::raw::c_uint,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _rotr64(
        Value: ::std::os::raw::c_ulonglong,
        Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
pub type BOOLEAN = BYTE;
pub type PBOOLEAN = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LIST_ENTRY {
    pub Flink: *mut _LIST_ENTRY,
    pub Blink: *mut _LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__LIST_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LIST_ENTRY>())).Flink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LIST_ENTRY>())).Blink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LIST_ENTRY),
            "::",
            stringify!(Blink)
        )
    );
}
pub type LIST_ENTRY = _LIST_ENTRY;
pub type PLIST_ENTRY = *mut _LIST_ENTRY;
pub type PRLIST_ENTRY = *mut _LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SINGLE_LIST_ENTRY {
    pub Next: *mut _SINGLE_LIST_ENTRY,
}
#[test]
fn bindgen_test_layout__SINGLE_LIST_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SINGLE_LIST_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SINGLE_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SINGLE_LIST_ENTRY>())).Next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SINGLE_LIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
pub type SINGLE_LIST_ENTRY = _SINGLE_LIST_ENTRY;
pub type PSINGLE_LIST_ENTRY = *mut _SINGLE_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY32 {
    pub Flink: DWORD,
    pub Blink: DWORD,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY32() {
    assert_eq!(
        ::std::mem::size_of::<LIST_ENTRY32>(),
        8usize,
        concat!("Size of: ", stringify!(LIST_ENTRY32))
    );
    assert_eq!(
        ::std::mem::align_of::<LIST_ENTRY32>(),
        4usize,
        concat!("Alignment of ", stringify!(LIST_ENTRY32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST_ENTRY32>())).Flink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY32),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST_ENTRY32>())).Blink as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY32),
            "::",
            stringify!(Blink)
        )
    );
}
pub type PLIST_ENTRY32 = *mut LIST_ENTRY32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LIST_ENTRY64 {
    pub Flink: ULONGLONG,
    pub Blink: ULONGLONG,
}
#[test]
fn bindgen_test_layout_LIST_ENTRY64() {
    assert_eq!(
        ::std::mem::size_of::<LIST_ENTRY64>(),
        16usize,
        concat!("Size of: ", stringify!(LIST_ENTRY64))
    );
    assert_eq!(
        ::std::mem::align_of::<LIST_ENTRY64>(),
        8usize,
        concat!("Alignment of ", stringify!(LIST_ENTRY64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST_ENTRY64>())).Flink as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY64),
            "::",
            stringify!(Flink)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<LIST_ENTRY64>())).Blink as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LIST_ENTRY64),
            "::",
            stringify!(Blink)
        )
    );
}
pub type PLIST_ENTRY64 = *mut LIST_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GUID {
    pub Data1: ::std::os::raw::c_ulong,
    pub Data2: ::std::os::raw::c_ushort,
    pub Data3: ::std::os::raw::c_ushort,
    pub Data4: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout__GUID() {
    assert_eq!(
        ::std::mem::size_of::<_GUID>(),
        16usize,
        concat!("Size of: ", stringify!(_GUID))
    );
    assert_eq!(
        ::std::mem::align_of::<_GUID>(),
        4usize,
        concat!("Alignment of ", stringify!(_GUID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data3 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GUID>())).Data4 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GUID),
            "::",
            stringify!(Data4)
        )
    );
}
pub type GUID = _GUID;
pub type LPGUID = *mut GUID;
pub type LPCGUID = *const GUID;
pub type IID = GUID;
pub type LPIID = *mut IID;
pub type CLSID = GUID;
pub type LPCLSID = *mut CLSID;
pub type FMTID = GUID;
pub type LPFMTID = *mut FMTID;
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const wchar_t) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECTID {
    pub Lineage: GUID,
    pub Uniquifier: DWORD,
}
#[test]
fn bindgen_test_layout__OBJECTID() {
    assert_eq!(
        ::std::mem::size_of::<_OBJECTID>(),
        20usize,
        concat!("Size of: ", stringify!(_OBJECTID))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECTID>(),
        4usize,
        concat!("Alignment of ", stringify!(_OBJECTID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OBJECTID>())).Lineage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECTID),
            "::",
            stringify!(Lineage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OBJECTID>())).Uniquifier as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECTID),
            "::",
            stringify!(Uniquifier)
        )
    );
}
pub type OBJECTID = _OBJECTID;
pub const _EXCEPTION_DISPOSITION_ExceptionContinueExecution: _EXCEPTION_DISPOSITION = 0;
pub const _EXCEPTION_DISPOSITION_ExceptionContinueSearch: _EXCEPTION_DISPOSITION = 1;
pub const _EXCEPTION_DISPOSITION_ExceptionNestedException: _EXCEPTION_DISPOSITION = 2;
pub const _EXCEPTION_DISPOSITION_ExceptionCollidedUnwind: _EXCEPTION_DISPOSITION = 3;
pub type _EXCEPTION_DISPOSITION = i32;
pub use self::_EXCEPTION_DISPOSITION as EXCEPTION_DISPOSITION;
extern "C" {
    pub fn __C_specific_handler(
        ExceptionRecord: *mut _EXCEPTION_RECORD,
        EstablisherFrame: *mut ::std::os::raw::c_void,
        ContextRecord: *mut _CONTEXT,
        DispatcherContext: *mut _DISPATCHER_CONTEXT,
    ) -> EXCEPTION_DISPOSITION;
}
extern "C" {
    pub fn _exception_code() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _exception_info() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _abnormal_termination() -> ::std::os::raw::c_int;
}
pub type PEXCEPTION_ROUTINE =
    ::std::option::Option<unsafe extern "C" fn() -> EXCEPTION_DISPOSITION>;
pub type KSPIN_LOCK = ULONG_PTR;
pub type PKSPIN_LOCK = *mut KSPIN_LOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _M128A {
    pub Low: ULONGLONG,
    pub High: LONGLONG,
}
#[test]
fn bindgen_test_layout__M128A() {
    assert_eq!(
        ::std::mem::size_of::<_M128A>(),
        16usize,
        concat!("Size of: ", stringify!(_M128A))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_M128A>())).Low as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_M128A),
            "::",
            stringify!(Low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_M128A>())).High as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_M128A),
            "::",
            stringify!(High)
        )
    );
}
pub type M128A = _M128A;
pub type PM128A = *mut _M128A;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSAVE_FORMAT {
    pub ControlWord: WORD,
    pub StatusWord: WORD,
    pub TagWord: BYTE,
    pub Reserved1: BYTE,
    pub ErrorOpcode: WORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: WORD,
    pub Reserved2: WORD,
    pub DataOffset: DWORD,
    pub DataSelector: WORD,
    pub Reserved3: WORD,
    pub MxCsr: DWORD,
    pub MxCsr_Mask: DWORD,
    pub FloatRegisters: [M128A; 8usize],
    pub XmmRegisters: [M128A; 16usize],
    pub Reserved4: [BYTE; 96usize],
}
#[test]
fn bindgen_test_layout__XSAVE_FORMAT() {
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_FORMAT>(),
        512usize,
        concat!("Size of: ", stringify!(_XSAVE_FORMAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).ControlWord as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).StatusWord as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).TagWord as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).Reserved1 as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).ErrorOpcode as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ErrorOpcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).ErrorOffset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).ErrorSelector as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).Reserved2 as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).DataOffset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).DataSelector as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).Reserved3 as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).MxCsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(MxCsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).MxCsr_Mask as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(MxCsr_Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).FloatRegisters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(FloatRegisters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).XmmRegisters as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(XmmRegisters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_FORMAT>())).Reserved4 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_FORMAT),
            "::",
            stringify!(Reserved4)
        )
    );
}
pub type XSAVE_FORMAT = _XSAVE_FORMAT;
pub type PXSAVE_FORMAT = *mut _XSAVE_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_CET_U_FORMAT {
    pub Ia32CetUMsr: DWORD64,
    pub Ia32Pl3SspMsr: DWORD64,
}
#[test]
fn bindgen_test_layout__XSAVE_CET_U_FORMAT() {
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_CET_U_FORMAT>(),
        16usize,
        concat!("Size of: ", stringify!(_XSAVE_CET_U_FORMAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSAVE_CET_U_FORMAT>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSAVE_CET_U_FORMAT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_CET_U_FORMAT>())).Ia32CetUMsr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_CET_U_FORMAT),
            "::",
            stringify!(Ia32CetUMsr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSAVE_CET_U_FORMAT>())).Ia32Pl3SspMsr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_CET_U_FORMAT),
            "::",
            stringify!(Ia32Pl3SspMsr)
        )
    );
}
pub type XSAVE_CET_U_FORMAT = _XSAVE_CET_U_FORMAT;
pub type PXSAVE_CET_U_FORMAT = *mut _XSAVE_CET_U_FORMAT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSAVE_AREA_HEADER {
    pub Mask: DWORD64,
    pub CompactionMask: DWORD64,
    pub Reserved2: [DWORD64; 6usize],
}
#[test]
fn bindgen_test_layout__XSAVE_AREA_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_AREA_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_XSAVE_AREA_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSAVE_AREA_HEADER>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSAVE_AREA_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_AREA_HEADER>())).Mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA_HEADER),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSAVE_AREA_HEADER>())).CompactionMask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA_HEADER),
            "::",
            stringify!(CompactionMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_AREA_HEADER>())).Reserved2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA_HEADER),
            "::",
            stringify!(Reserved2)
        )
    );
}
pub type XSAVE_AREA_HEADER = _XSAVE_AREA_HEADER;
pub type PXSAVE_AREA_HEADER = *mut _XSAVE_AREA_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSAVE_AREA {
    pub LegacyState: XSAVE_FORMAT,
    pub Header: XSAVE_AREA_HEADER,
}
#[test]
fn bindgen_test_layout__XSAVE_AREA() {
    assert_eq!(
        ::std::mem::size_of::<_XSAVE_AREA>(),
        576usize,
        concat!("Size of: ", stringify!(_XSAVE_AREA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_AREA>())).LegacyState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA),
            "::",
            stringify!(LegacyState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSAVE_AREA>())).Header as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSAVE_AREA),
            "::",
            stringify!(Header)
        )
    );
}
pub type XSAVE_AREA = _XSAVE_AREA;
pub type PXSAVE_AREA = *mut _XSAVE_AREA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONTEXT {
    pub Mask: DWORD64,
    pub Length: DWORD,
    pub Reserved1: DWORD,
    pub Area: PXSAVE_AREA,
    pub Buffer: PVOID,
}
#[test]
fn bindgen_test_layout__XSTATE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONTEXT>(),
        32usize,
        concat!("Size of: ", stringify!(_XSTATE_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSTATE_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONTEXT>())).Mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONTEXT>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONTEXT>())).Reserved1 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONTEXT>())).Area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONTEXT>())).Buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONTEXT),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type XSTATE_CONTEXT = _XSTATE_CONTEXT;
pub type PXSTATE_CONTEXT = *mut _XSTATE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64 {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_AMD64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_AMD64__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_AMD64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).EndAddress as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).HandlerAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(HandlerAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64__bindgen_ty_1>())).JumpTarget as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64__bindgen_ty_1),
            "::",
            stringify!(JumpTarget)
        )
    );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_AMD64() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_AMD64>(),
        20usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_AMD64))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_AMD64>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_TABLE_AMD64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_AMD64>())).ScopeRecord as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_AMD64),
            "::",
            stringify!(ScopeRecord)
        )
    );
}
pub type SCOPE_TABLE_AMD64 = _SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE_AMD64 = *mut _SCOPE_TABLE_AMD64;
extern "C" {
    pub fn _bittest(Base: *const LONG, Offset: LONG) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandcomplement(Base: *mut LONG, Offset: LONG) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandset(Base: *mut LONG, Offset: LONG) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandreset(Base: *mut LONG, Offset: LONG) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _interlockedbittestandset(Base: *mut LONG, Offset: LONG) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _interlockedbittestandreset(Base: *mut LONG, Offset: LONG) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittest64(Base: *const LONG64, Offset: LONG64) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandcomplement64(Base: *mut LONG64, Offset: LONG64) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandset64(Base: *mut LONG64, Offset: LONG64) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandreset64(Base: *mut LONG64, Offset: LONG64) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _interlockedbittestandset64(
        Base: *mut LONG64,
        Offset: LONG64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _interlockedbittestandreset64(
        Base: *mut LONG64,
        Offset: LONG64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanForward(Index: *mut DWORD, Mask: DWORD) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanReverse(Index: *mut DWORD, Mask: DWORD) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanForward64(Index: *mut DWORD, Mask: DWORD64) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanReverse64(Index: *mut DWORD, Mask: DWORD64) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedIncrement16(Addend: *mut SHORT) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedDecrement16(Addend: *mut SHORT) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedCompareExchange16(
        Destination: *mut SHORT,
        ExChange: SHORT,
        Comperand: SHORT,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedAnd(Destination: *mut LONG, Value: LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedOr(Destination: *mut LONG, Value: LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedXor(Destination: *mut LONG, Value: LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedAnd64(Destination: *mut LONG64, Value: LONG64)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedOr64(Destination: *mut LONG64, Value: LONG64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedXor64(Destination: *mut LONG64, Value: LONG64)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedIncrement(Addend: *mut LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedDecrement(Addend: *mut LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedExchange(Target: *mut LONG, Value: LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedExchangeAdd(Addend: *mut LONG, Value: LONG) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedCompareExchange(
        Destination: *mut LONG,
        ExChange: LONG,
        Comperand: LONG,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedIncrement64(Addend: *mut LONG64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedDecrement64(Addend: *mut LONG64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchange64(Target: *mut LONG64, Value: LONG64)
        -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchangeAdd64(
        Addend: *mut LONG64,
        Value: LONG64,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedCompareExchange64(
        Destination: *mut LONG64,
        ExChange: LONG64,
        Comperand: LONG64,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedCompareExchange128(
        Destination: *mut LONG64,
        ExchangeHigh: LONG64,
        ExchangeLow: LONG64,
        ComparandResult: *mut LONG64,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedCompareExchangePointer(
        Destination: *mut PVOID,
        Exchange: PVOID,
        Comperand: PVOID,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _InterlockedExchangePointer(
        Target: *mut PVOID,
        Value: PVOID,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _InterlockedExchange8(Target: *mut CHAR, Value: CHAR) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedExchange16(
        Destination: *mut SHORT,
        ExChange: SHORT,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedExchangeAdd8(
        _Addend: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedAnd8(
        Destination: *mut ::std::os::raw::c_char,
        Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedOr8(
        Destination: *mut ::std::os::raw::c_char,
        Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedXor8(
        Destination: *mut ::std::os::raw::c_char,
        Value: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedAnd16(Destination: *mut SHORT, Value: SHORT) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedOr16(Destination: *mut SHORT, Value: SHORT) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedXor16(Destination: *mut SHORT, Value: SHORT) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn __cpuidex(
        CPUInfo: *mut ::std::os::raw::c_int,
        Function: ::std::os::raw::c_int,
        SubLeaf: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn _mm_clflush(Address: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _ReadWriteBarrier();
}
extern "C" {
    pub fn __faststorefence();
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    pub fn _mm_prefetch(a: *const CHAR, sel: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _m_prefetchw(Source: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(MxCsr: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __getcallerseflags() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __segmentlimit(Selector: DWORD) -> DWORD;
}
extern "C" {
    pub fn __readpmc(Counter: DWORD) -> DWORD64;
}
extern "C" {
    pub fn __rdtsc() -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __movsb(Destination: PBYTE, Source: *const BYTE, Count: SIZE_T);
}
extern "C" {
    pub fn __movsw(Destination: PWORD, Source: *const WORD, Count: SIZE_T);
}
extern "C" {
    pub fn __movsd(Destination: PDWORD, Source: *const DWORD, Count: SIZE_T);
}
extern "C" {
    pub fn __movsq(Destination: PDWORD64, Source: *const DWORD64, Count: SIZE_T);
}
extern "C" {
    pub fn __stosb(Destination: PBYTE, Value: BYTE, Count: SIZE_T);
}
extern "C" {
    pub fn __stosw(Destination: PWORD, Value: WORD, Count: SIZE_T);
}
extern "C" {
    pub fn __stosd(Destination: PDWORD, Value: DWORD, Count: SIZE_T);
}
extern "C" {
    pub fn __stosq(Destination: PDWORD64, Value: DWORD64, Count: SIZE_T);
}
extern "C" {
    pub fn __mulh(Multiplier: LONG64, Multiplicand: LONG64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __umulh(Multiplier: DWORD64, Multiplicand: DWORD64) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __popcnt64(operand: DWORD64) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __shiftleft128(
        LowPart: DWORD64,
        HighPart: DWORD64,
        Shift: BYTE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __shiftright128(
        LowPart: DWORD64,
        HighPart: DWORD64,
        Shift: BYTE,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _mul128(
        Multiplier: LONG64,
        Multiplicand: LONG64,
        HighProduct: *mut LONG64,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _umul128(
        Multiplier: DWORD64,
        Multiplicand: DWORD64,
        HighProduct: *mut DWORD64,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __readgsbyte(Offset: DWORD) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __readgsword(Offset: DWORD) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __readgsdword(Offset: DWORD) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __readgsqword(Offset: DWORD) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __writegsbyte(Offset: DWORD, Data: BYTE);
}
extern "C" {
    pub fn __writegsword(Offset: DWORD, Data: WORD);
}
extern "C" {
    pub fn __writegsdword(Offset: DWORD, Data: DWORD);
}
extern "C" {
    pub fn __writegsqword(Offset: DWORD, Data: DWORD64);
}
extern "C" {
    pub fn __incgsbyte(Offset: DWORD);
}
extern "C" {
    pub fn __addgsbyte(Offset: DWORD, Value: BYTE);
}
extern "C" {
    pub fn __incgsword(Offset: DWORD);
}
extern "C" {
    pub fn __addgsword(Offset: DWORD, Value: WORD);
}
extern "C" {
    pub fn __incgsdword(Offset: DWORD);
}
extern "C" {
    pub fn __addgsdword(Offset: DWORD, Value: DWORD);
}
extern "C" {
    pub fn __incgsqword(Offset: DWORD);
}
extern "C" {
    pub fn __addgsqword(Offset: DWORD, Value: DWORD64);
}
pub type XMM_SAVE_AREA32 = XSAVE_FORMAT;
pub type PXMM_SAVE_AREA32 = *mut XSAVE_FORMAT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CONTEXT {
    pub P1Home: DWORD64,
    pub P2Home: DWORD64,
    pub P3Home: DWORD64,
    pub P4Home: DWORD64,
    pub P5Home: DWORD64,
    pub P6Home: DWORD64,
    pub ContextFlags: DWORD,
    pub MxCsr: DWORD,
    pub SegCs: WORD,
    pub SegDs: WORD,
    pub SegEs: WORD,
    pub SegFs: WORD,
    pub SegGs: WORD,
    pub SegSs: WORD,
    pub EFlags: DWORD,
    pub Dr0: DWORD64,
    pub Dr1: DWORD64,
    pub Dr2: DWORD64,
    pub Dr3: DWORD64,
    pub Dr6: DWORD64,
    pub Dr7: DWORD64,
    pub Rax: DWORD64,
    pub Rcx: DWORD64,
    pub Rdx: DWORD64,
    pub Rbx: DWORD64,
    pub Rsp: DWORD64,
    pub Rbp: DWORD64,
    pub Rsi: DWORD64,
    pub Rdi: DWORD64,
    pub R8: DWORD64,
    pub R9: DWORD64,
    pub R10: DWORD64,
    pub R11: DWORD64,
    pub R12: DWORD64,
    pub R13: DWORD64,
    pub R14: DWORD64,
    pub R15: DWORD64,
    pub Rip: DWORD64,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1,
    pub VectorRegister: [M128A; 26usize],
    pub VectorControl: DWORD64,
    pub DebugControl: DWORD64,
    pub LastBranchToRip: DWORD64,
    pub LastBranchFromRip: DWORD64,
    pub LastExceptionToRip: DWORD64,
    pub LastExceptionFromRip: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CONTEXT__bindgen_ty_1 {
    pub FltSave: XMM_SAVE_AREA32,
    pub __bindgen_anon_1: _CONTEXT__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u8; 512usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CONTEXT__bindgen_ty_1__bindgen_ty_1 {
    pub Header: [M128A; 2usize],
    pub Legacy: [M128A; 8usize],
    pub Xmm0: M128A,
    pub Xmm1: M128A,
    pub Xmm2: M128A,
    pub Xmm3: M128A,
    pub Xmm4: M128A,
    pub Xmm5: M128A,
    pub Xmm6: M128A,
    pub Xmm7: M128A,
    pub Xmm8: M128A,
    pub Xmm9: M128A,
    pub Xmm10: M128A,
    pub Xmm11: M128A,
    pub Xmm12: M128A,
    pub Xmm13: M128A,
    pub Xmm14: M128A,
    pub Xmm15: M128A,
}
#[test]
fn bindgen_test_layout__CONTEXT__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>(),
        416usize,
        concat!(
            "Size of: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Legacy as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Legacy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm0 as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm1 as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm2 as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm3 as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm4 as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm5 as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm6 as *const _
                as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm7 as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm8 as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm9 as *const _
                as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm10 as *const _
                as usize
        },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm11 as *const _
                as usize
        },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm12 as *const _
                as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm13 as *const _
                as usize
        },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm14 as *const _
                as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1__bindgen_ty_1>())).Xmm15 as *const _
                as usize
        },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm15)
        )
    );
}
#[test]
fn bindgen_test_layout__CONTEXT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_CONTEXT__bindgen_ty_1>(),
        512usize,
        concat!("Size of: ", stringify!(_CONTEXT__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT__bindgen_ty_1>())).FltSave as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(FltSave)
        )
    );
}
#[test]
fn bindgen_test_layout__CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_CONTEXT>(),
        1232usize,
        concat!("Size of: ", stringify!(_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).P1Home as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P1Home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).P2Home as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P2Home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).P3Home as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P3Home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).P4Home as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P4Home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).P5Home as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P5Home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).P6Home as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(P6Home)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).ContextFlags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).MxCsr as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(MxCsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).SegCs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).SegDs as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegDs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).SegEs as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegEs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).SegFs as *const _ as usize },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegFs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).SegGs as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegGs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).SegSs as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).EFlags as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Dr0 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Dr1 as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Dr2 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Dr3 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Dr6 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Dr7 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rax as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rcx as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rdx as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rbx as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rsp as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rbp as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rbp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rsi as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rdi as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R8 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R9 as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R9)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R10 as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R10)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R11 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R11)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R12 as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R12)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R13 as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R13)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R14 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R14)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).R15 as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(R15)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).Rip as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).VectorRegister as *const _ as usize },
        768usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(VectorRegister)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).VectorControl as *const _ as usize },
        1184usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(VectorControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).DebugControl as *const _ as usize },
        1192usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(DebugControl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).LastBranchToRip as *const _ as usize },
        1200usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastBranchToRip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).LastBranchFromRip as *const _ as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastBranchFromRip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).LastExceptionToRip as *const _ as usize },
        1216usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastExceptionToRip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CONTEXT>())).LastExceptionFromRip as *const _ as usize },
        1224usize,
        concat!(
            "Offset of field: ",
            stringify!(_CONTEXT),
            "::",
            stringify!(LastExceptionFromRip)
        )
    );
}
pub type CONTEXT = _CONTEXT;
pub type PCONTEXT = *mut _CONTEXT;
pub type RUNTIME_FUNCTION = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PRUNTIME_FUNCTION = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type SCOPE_TABLE = SCOPE_TABLE_AMD64;
pub type PSCOPE_TABLE = *mut SCOPE_TABLE_AMD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNWIND_HISTORY_TABLE_ENTRY {
    pub ImageBase: DWORD64,
    pub FunctionEntry: PRUNTIME_FUNCTION,
}
#[test]
fn bindgen_test_layout__UNWIND_HISTORY_TABLE_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_UNWIND_HISTORY_TABLE_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_UNWIND_HISTORY_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNWIND_HISTORY_TABLE_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNWIND_HISTORY_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE_ENTRY>())).ImageBase as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE_ENTRY),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE_ENTRY>())).FunctionEntry as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE_ENTRY),
            "::",
            stringify!(FunctionEntry)
        )
    );
}
pub type UNWIND_HISTORY_TABLE_ENTRY = _UNWIND_HISTORY_TABLE_ENTRY;
pub type PUNWIND_HISTORY_TABLE_ENTRY = *mut _UNWIND_HISTORY_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UNWIND_HISTORY_TABLE {
    pub Count: DWORD,
    pub LocalHint: BYTE,
    pub GlobalHint: BYTE,
    pub Search: BYTE,
    pub Once: BYTE,
    pub LowAddress: DWORD64,
    pub HighAddress: DWORD64,
    pub Entry: [UNWIND_HISTORY_TABLE_ENTRY; 12usize],
}
#[test]
fn bindgen_test_layout__UNWIND_HISTORY_TABLE() {
    assert_eq!(
        ::std::mem::size_of::<_UNWIND_HISTORY_TABLE>(),
        216usize,
        concat!("Size of: ", stringify!(_UNWIND_HISTORY_TABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_UNWIND_HISTORY_TABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_UNWIND_HISTORY_TABLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).LocalHint as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(LocalHint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).GlobalHint as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(GlobalHint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).Search as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Search)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).Once as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Once)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).LowAddress as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(LowAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).HighAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(HighAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_UNWIND_HISTORY_TABLE>())).Entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_UNWIND_HISTORY_TABLE),
            "::",
            stringify!(Entry)
        )
    );
}
pub type UNWIND_HISTORY_TABLE = _UNWIND_HISTORY_TABLE;
pub type PUNWIND_HISTORY_TABLE = *mut _UNWIND_HISTORY_TABLE;
pub type GET_RUNTIME_FUNCTION_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(ControlPc: DWORD64, Context: PVOID) -> PRUNTIME_FUNCTION,
>;
pub type PGET_RUNTIME_FUNCTION_CALLBACK = GET_RUNTIME_FUNCTION_CALLBACK;
pub type OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Process: HANDLE,
        TableAddress: PVOID,
        Entries: PDWORD,
        Functions: *mut PRUNTIME_FUNCTION,
    ) -> DWORD,
>;
pub type POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK = OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _DISPATCHER_CONTEXT {
    pub ControlPc: DWORD64,
    pub ImageBase: DWORD64,
    pub FunctionEntry: PRUNTIME_FUNCTION,
    pub EstablisherFrame: DWORD64,
    pub TargetIp: DWORD64,
    pub ContextRecord: PCONTEXT,
    pub LanguageHandler: PEXCEPTION_ROUTINE,
    pub HandlerData: PVOID,
    pub HistoryTable: PUNWIND_HISTORY_TABLE,
    pub ScopeIndex: DWORD,
    pub Fill0: DWORD,
}
#[test]
fn bindgen_test_layout__DISPATCHER_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_DISPATCHER_CONTEXT>(),
        80usize,
        concat!("Size of: ", stringify!(_DISPATCHER_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_DISPATCHER_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(_DISPATCHER_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).ControlPc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ControlPc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).ImageBase as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).FunctionEntry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(FunctionEntry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).EstablisherFrame as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(EstablisherFrame)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).TargetIp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(TargetIp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).ContextRecord as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ContextRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).LanguageHandler as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(LanguageHandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).HandlerData as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(HandlerData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).HistoryTable as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(HistoryTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).ScopeIndex as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(ScopeIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_DISPATCHER_CONTEXT>())).Fill0 as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_DISPATCHER_CONTEXT),
            "::",
            stringify!(Fill0)
        )
    );
}
pub type DISPATCHER_CONTEXT = _DISPATCHER_CONTEXT;
pub type PDISPATCHER_CONTEXT = *mut _DISPATCHER_CONTEXT;
pub type PEXCEPTION_FILTER = ::std::option::Option<
    unsafe extern "C" fn(
        ExceptionPointers: *mut _EXCEPTION_POINTERS,
        EstablisherFrame: PVOID,
    ) -> LONG,
>;
pub type PTERMINATION_HANDLER = ::std::option::Option<
    unsafe extern "C" fn(_abnormal_termination: BOOLEAN, EstablisherFrame: PVOID),
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS {
    pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1,
    pub __bindgen_anon_2: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1 {
    pub FloatingContext: [PM128A; 16usize],
    pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1 {
    pub Xmm0: PM128A,
    pub Xmm1: PM128A,
    pub Xmm2: PM128A,
    pub Xmm3: PM128A,
    pub Xmm4: PM128A,
    pub Xmm5: PM128A,
    pub Xmm6: PM128A,
    pub Xmm7: PM128A,
    pub Xmm8: PM128A,
    pub Xmm9: PM128A,
    pub Xmm10: PM128A,
    pub Xmm11: PM128A,
    pub Xmm12: PM128A,
    pub Xmm13: PM128A,
    pub Xmm14: PM128A,
    pub Xmm15: PM128A,
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm0 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm0)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm1 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm4 as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm5 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm6 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm7 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm7)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1>()))
                .Xmm15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Xmm15)
        )
    );
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1>())).FloatingContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_1),
            "::",
            stringify!(FloatingContext)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2 {
    pub IntegerContext: [PDWORD64; 16usize],
    pub __bindgen_anon_1: _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: [u64; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1 {
    pub Rax: PDWORD64,
    pub Rcx: PDWORD64,
    pub Rdx: PDWORD64,
    pub Rbx: PDWORD64,
    pub Rsp: PDWORD64,
    pub Rbp: PDWORD64,
    pub Rsi: PDWORD64,
    pub Rdi: PDWORD64,
    pub R8: PDWORD64,
    pub R9: PDWORD64,
    pub R10: PDWORD64,
    pub R11: PDWORD64,
    pub R12: PDWORD64,
    pub R13: PDWORD64,
    pub R14: PDWORD64,
    pub R15: PDWORD64,
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rcx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rdx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rbx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rsp as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rsp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rbp as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rbp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rsi as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .Rdi as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R8 as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R9 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R10 as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R11 as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R12 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R13 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R14 as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1>()))
                .R15 as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(R15)
        )
    );
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2>(),
        128usize,
        concat!(
            "Size of: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2>())).IntegerContext
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS__bindgen_ty_2),
            "::",
            stringify!(IntegerContext)
        )
    );
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS() {
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS>(),
        256usize,
        concat!("Size of: ", stringify!(_KNONVOLATILE_CONTEXT_POINTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_KNONVOLATILE_CONTEXT_POINTERS))
    );
}
pub type KNONVOLATILE_CONTEXT_POINTERS = _KNONVOLATILE_CONTEXT_POINTERS;
pub type PKNONVOLATILE_CONTEXT_POINTERS = *mut _KNONVOLATILE_CONTEXT_POINTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_ARM__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_ARM__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).EndAddress as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).HandlerAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
            "::",
            stringify!(HandlerAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM__bindgen_ty_1>())).JumpTarget as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM__bindgen_ty_1),
            "::",
            stringify!(JumpTarget)
        )
    );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_ARM>(),
        20usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_ARM>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM>())).ScopeRecord as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM),
            "::",
            stringify!(ScopeRecord)
        )
    );
}
pub type SCOPE_TABLE_ARM = _SCOPE_TABLE_ARM;
pub type PSCOPE_TABLE_ARM = *mut _SCOPE_TABLE_ARM;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64 {
    pub Count: DWORD,
    pub ScopeRecord: [_SCOPE_TABLE_ARM64__bindgen_ty_1; 1usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCOPE_TABLE_ARM64__bindgen_ty_1 {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub HandlerAddress: DWORD,
    pub JumpTarget: DWORD,
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_ARM64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).EndAddress as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).HandlerAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
            "::",
            stringify!(HandlerAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64__bindgen_ty_1>())).JumpTarget as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM64__bindgen_ty_1),
            "::",
            stringify!(JumpTarget)
        )
    );
}
#[test]
fn bindgen_test_layout__SCOPE_TABLE_ARM64() {
    assert_eq!(
        ::std::mem::size_of::<_SCOPE_TABLE_ARM64>(),
        20usize,
        concat!("Size of: ", stringify!(_SCOPE_TABLE_ARM64))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCOPE_TABLE_ARM64>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCOPE_TABLE_ARM64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM64),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCOPE_TABLE_ARM64>())).ScopeRecord as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCOPE_TABLE_ARM64),
            "::",
            stringify!(ScopeRecord)
        )
    );
}
pub type SCOPE_TABLE_ARM64 = _SCOPE_TABLE_ARM64;
pub type PSCOPE_TABLE_ARM64 = *mut _SCOPE_TABLE_ARM64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64 {
    pub X19: PDWORD64,
    pub X20: PDWORD64,
    pub X21: PDWORD64,
    pub X22: PDWORD64,
    pub X23: PDWORD64,
    pub X24: PDWORD64,
    pub X25: PDWORD64,
    pub X26: PDWORD64,
    pub X27: PDWORD64,
    pub X28: PDWORD64,
    pub Fp: PDWORD64,
    pub Lr: PDWORD64,
    pub D8: PDWORD64,
    pub D9: PDWORD64,
    pub D10: PDWORD64,
    pub D11: PDWORD64,
    pub D12: PDWORD64,
    pub D13: PDWORD64,
    pub D14: PDWORD64,
    pub D15: PDWORD64,
}
#[test]
fn bindgen_test_layout__KNONVOLATILE_CONTEXT_POINTERS_ARM64() {
    assert_eq!(
        ::std::mem::size_of::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>(),
        160usize,
        concat!(
            "Size of: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X19 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X19)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X20 as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X20)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X21 as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X21)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X22 as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X22)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X23 as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X23)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X24 as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X24)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X25 as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X25)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X26 as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X26)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X27 as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X27)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).X28 as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(X28)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).Fp as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(Fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).Lr as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(Lr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D8 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D9 as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D9)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D10 as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D10)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D11 as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D11)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D12 as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D12)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D13 as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D13)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D14 as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D14)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KNONVOLATILE_CONTEXT_POINTERS_ARM64>())).D15 as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_KNONVOLATILE_CONTEXT_POINTERS_ARM64),
            "::",
            stringify!(D15)
        )
    );
}
pub type KNONVOLATILE_CONTEXT_POINTERS_ARM64 = _KNONVOLATILE_CONTEXT_POINTERS_ARM64;
pub type PKNONVOLATILE_CONTEXT_POINTERS_ARM64 = *mut _KNONVOLATILE_CONTEXT_POINTERS_ARM64;
extern "C" {
    pub fn __int2c();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _LDT_ENTRY {
    pub LimitLow: WORD,
    pub BaseLow: WORD,
    pub HighWord: _LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _LDT_ENTRY__bindgen_ty_1 {
    pub Bytes: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Bits: _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub BaseMid: BYTE,
    pub Flags1: BYTE,
    pub Flags2: BYTE,
    pub BaseHi: BYTE,
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseMid as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseMid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags1 as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags2 as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseHi as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseHi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl _LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: DWORD,
        Type: DWORD,
        Dpl: DWORD,
        Pres: DWORD,
        LimitHi: DWORD,
        Sys: DWORD,
        Reserved_0: DWORD,
        Default_Big: DWORD,
        Granularity: DWORD,
        BaseHi: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__LDT_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDT_ENTRY__bindgen_ty_1>())).Bytes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDT_ENTRY__bindgen_ty_1>())).Bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bits)
        )
    );
}
#[test]
fn bindgen_test_layout__LDT_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_LDT_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_LDT_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDT_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_LDT_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDT_ENTRY>())).LimitLow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY),
            "::",
            stringify!(LimitLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDT_ENTRY>())).BaseLow as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY),
            "::",
            stringify!(BaseLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LDT_ENTRY>())).HighWord as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDT_ENTRY),
            "::",
            stringify!(HighWord)
        )
    );
}
pub type LDT_ENTRY = _LDT_ENTRY;
pub type PLDT_ENTRY = *mut _LDT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_FLOATING_SAVE_AREA {
    pub ControlWord: DWORD,
    pub StatusWord: DWORD,
    pub TagWord: DWORD,
    pub ErrorOffset: DWORD,
    pub ErrorSelector: DWORD,
    pub DataOffset: DWORD,
    pub DataSelector: DWORD,
    pub RegisterArea: [BYTE; 80usize],
    pub Cr0NpxState: DWORD,
}
#[test]
fn bindgen_test_layout__WOW64_FLOATING_SAVE_AREA() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_FLOATING_SAVE_AREA>(),
        112usize,
        concat!("Size of: ", stringify!(_WOW64_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_FLOATING_SAVE_AREA>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_FLOATING_SAVE_AREA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).ControlWord as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(ControlWord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).StatusWord as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(StatusWord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).TagWord as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(TagWord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).ErrorOffset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).ErrorSelector as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(ErrorSelector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).DataOffset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).DataSelector as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(DataSelector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).RegisterArea as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(RegisterArea)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_FLOATING_SAVE_AREA>())).Cr0NpxState as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_FLOATING_SAVE_AREA),
            "::",
            stringify!(Cr0NpxState)
        )
    );
}
pub type WOW64_FLOATING_SAVE_AREA = _WOW64_FLOATING_SAVE_AREA;
pub type PWOW64_FLOATING_SAVE_AREA = *mut WOW64_FLOATING_SAVE_AREA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_CONTEXT {
    pub ContextFlags: DWORD,
    pub Dr0: DWORD,
    pub Dr1: DWORD,
    pub Dr2: DWORD,
    pub Dr3: DWORD,
    pub Dr6: DWORD,
    pub Dr7: DWORD,
    pub FloatSave: WOW64_FLOATING_SAVE_AREA,
    pub SegGs: DWORD,
    pub SegFs: DWORD,
    pub SegEs: DWORD,
    pub SegDs: DWORD,
    pub Edi: DWORD,
    pub Esi: DWORD,
    pub Ebx: DWORD,
    pub Edx: DWORD,
    pub Ecx: DWORD,
    pub Eax: DWORD,
    pub Ebp: DWORD,
    pub Eip: DWORD,
    pub SegCs: DWORD,
    pub EFlags: DWORD,
    pub Esp: DWORD,
    pub SegSs: DWORD,
    pub ExtendedRegisters: [BYTE; 512usize],
}
#[test]
fn bindgen_test_layout__WOW64_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_CONTEXT>(),
        716usize,
        concat!("Size of: ", stringify!(_WOW64_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_CONTEXT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).ContextFlags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(ContextFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Dr0 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Dr1 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Dr2 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Dr3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Dr6 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Dr7 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Dr7)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).FloatSave as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(FloatSave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).SegGs as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegGs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).SegFs as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegFs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).SegEs as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegEs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).SegDs as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegDs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Edi as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Edi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Esi as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Esi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Ebx as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Edx as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Edx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Ecx as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Eax as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Ebp as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Ebp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Eip as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Eip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).SegCs as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegCs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).EFlags as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(EFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).Esp as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(Esp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_CONTEXT>())).SegSs as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(SegSs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_CONTEXT>())).ExtendedRegisters as *const _ as usize
        },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_CONTEXT),
            "::",
            stringify!(ExtendedRegisters)
        )
    );
}
pub type WOW64_CONTEXT = _WOW64_CONTEXT;
pub type PWOW64_CONTEXT = *mut WOW64_CONTEXT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_LDT_ENTRY {
    pub LimitLow: WORD,
    pub BaseLow: WORD,
    pub HighWord: _WOW64_LDT_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WOW64_LDT_ENTRY__bindgen_ty_1 {
    pub Bytes: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Bits: _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub BaseMid: BYTE,
    pub Flags1: BYTE,
    pub Flags2: BYTE,
    pub BaseHi: BYTE,
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseMid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseMid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags1
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).Flags2
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1>())).BaseHi
                as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(BaseHi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2)
        )
    );
}
impl _WOW64_LDT_ENTRY__bindgen_ty_1__bindgen_ty_2 {
    #[inline]
    pub fn BaseMid(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseMid(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Type(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn Dpl(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Dpl(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Pres(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Pres(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LimitHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_LimitHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Sys(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Sys(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved_0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved_0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default_Big(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Default_Big(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn BaseHi(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_BaseHi(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BaseMid: DWORD,
        Type: DWORD,
        Dpl: DWORD,
        Pres: DWORD,
        LimitHi: DWORD,
        Sys: DWORD,
        Reserved_0: DWORD,
        Default_Big: DWORD,
        Granularity: DWORD,
        BaseHi: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let BaseMid: u32 = unsafe { ::std::mem::transmute(BaseMid) };
            BaseMid as u64
        });
        __bindgen_bitfield_unit.set(8usize, 5u8, {
            let Type: u32 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Dpl: u32 = unsafe { ::std::mem::transmute(Dpl) };
            Dpl as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Pres: u32 = unsafe { ::std::mem::transmute(Pres) };
            Pres as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let LimitHi: u32 = unsafe { ::std::mem::transmute(LimitHi) };
            LimitHi as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let Sys: u32 = unsafe { ::std::mem::transmute(Sys) };
            Sys as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Reserved_0: u32 = unsafe { ::std::mem::transmute(Reserved_0) };
            Reserved_0 as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let Default_Big: u32 = unsafe { ::std::mem::transmute(Default_Big) };
            Default_Big as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let Granularity: u32 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let BaseHi: u32 = unsafe { ::std::mem::transmute(BaseHi) };
            BaseHi as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1>())).Bytes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_LDT_ENTRY__bindgen_ty_1>())).Bits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Bits)
        )
    );
}
#[test]
fn bindgen_test_layout__WOW64_LDT_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_LDT_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_WOW64_LDT_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_LDT_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_LDT_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_LDT_ENTRY>())).LimitLow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY),
            "::",
            stringify!(LimitLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_LDT_ENTRY>())).BaseLow as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY),
            "::",
            stringify!(BaseLow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_WOW64_LDT_ENTRY>())).HighWord as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_LDT_ENTRY),
            "::",
            stringify!(HighWord)
        )
    );
}
pub type WOW64_LDT_ENTRY = _WOW64_LDT_ENTRY;
pub type PWOW64_LDT_ENTRY = *mut _WOW64_LDT_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    pub Selector: DWORD,
    pub Descriptor: WOW64_LDT_ENTRY,
}
#[test]
fn bindgen_test_layout__WOW64_DESCRIPTOR_TABLE_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_DESCRIPTOR_TABLE_ENTRY>(),
        12usize,
        concat!("Size of: ", stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_DESCRIPTOR_TABLE_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_DESCRIPTOR_TABLE_ENTRY>())).Selector as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY),
            "::",
            stringify!(Selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WOW64_DESCRIPTOR_TABLE_ENTRY>())).Descriptor as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_WOW64_DESCRIPTOR_TABLE_ENTRY),
            "::",
            stringify!(Descriptor)
        )
    );
}
pub type WOW64_DESCRIPTOR_TABLE_ENTRY = _WOW64_DESCRIPTOR_TABLE_ENTRY;
pub type PWOW64_DESCRIPTOR_TABLE_ENTRY = *mut _WOW64_DESCRIPTOR_TABLE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: *mut _EXCEPTION_RECORD,
    pub ExceptionAddress: PVOID,
    pub NumberParameters: DWORD,
    pub ExceptionInformation: [ULONG_PTR; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD() {
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_RECORD>(),
        152usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_RECORD>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EXCEPTION_RECORD>())).ExceptionCode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD>())).ExceptionFlags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD>())).ExceptionRecord as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD>())).ExceptionAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD>())).NumberParameters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD>())).ExceptionInformation as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD = _EXCEPTION_RECORD;
pub type PEXCEPTION_RECORD = *mut EXCEPTION_RECORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD32 {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: DWORD,
    pub ExceptionAddress: DWORD,
    pub NumberParameters: DWORD,
    pub ExceptionInformation: [DWORD; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD32() {
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_RECORD32>(),
        80usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD32))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_RECORD32>(),
        4usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionCode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionFlags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionRecord as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionAddress as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD32>())).NumberParameters as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD32>())).ExceptionInformation as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD32),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD32 = _EXCEPTION_RECORD32;
pub type PEXCEPTION_RECORD32 = *mut _EXCEPTION_RECORD32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_RECORD64 {
    pub ExceptionCode: DWORD,
    pub ExceptionFlags: DWORD,
    pub ExceptionRecord: DWORD64,
    pub ExceptionAddress: DWORD64,
    pub NumberParameters: DWORD,
    pub __unusedAlignment: DWORD,
    pub ExceptionInformation: [DWORD64; 15usize],
}
#[test]
fn bindgen_test_layout__EXCEPTION_RECORD64() {
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_RECORD64>(),
        152usize,
        concat!("Size of: ", stringify!(_EXCEPTION_RECORD64))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_RECORD64>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_RECORD64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionCode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionFlags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionRecord as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionAddress as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).NumberParameters as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(NumberParameters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).__unusedAlignment as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(__unusedAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_RECORD64>())).ExceptionInformation as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_RECORD64),
            "::",
            stringify!(ExceptionInformation)
        )
    );
}
pub type EXCEPTION_RECORD64 = _EXCEPTION_RECORD64;
pub type PEXCEPTION_RECORD64 = *mut _EXCEPTION_RECORD64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_POINTERS {
    pub ExceptionRecord: PEXCEPTION_RECORD,
    pub ContextRecord: PCONTEXT,
}
#[test]
fn bindgen_test_layout__EXCEPTION_POINTERS() {
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_POINTERS>(),
        16usize,
        concat!("Size of: ", stringify!(_EXCEPTION_POINTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_POINTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_POINTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_POINTERS>())).ExceptionRecord as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_POINTERS),
            "::",
            stringify!(ExceptionRecord)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_POINTERS>())).ContextRecord as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_POINTERS),
            "::",
            stringify!(ContextRecord)
        )
    );
}
pub type EXCEPTION_POINTERS = _EXCEPTION_POINTERS;
pub type PEXCEPTION_POINTERS = *mut _EXCEPTION_POINTERS;
pub type PACCESS_TOKEN = PVOID;
pub type PSECURITY_DESCRIPTOR = PVOID;
pub type PSID = PVOID;
pub type PCLAIMS_BLOB = PVOID;
pub type ACCESS_MASK = DWORD;
pub type PACCESS_MASK = *mut ACCESS_MASK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _GENERIC_MAPPING {
    pub GenericRead: ACCESS_MASK,
    pub GenericWrite: ACCESS_MASK,
    pub GenericExecute: ACCESS_MASK,
    pub GenericAll: ACCESS_MASK,
}
#[test]
fn bindgen_test_layout__GENERIC_MAPPING() {
    assert_eq!(
        ::std::mem::size_of::<_GENERIC_MAPPING>(),
        16usize,
        concat!("Size of: ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        ::std::mem::align_of::<_GENERIC_MAPPING>(),
        4usize,
        concat!("Alignment of ", stringify!(_GENERIC_MAPPING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericRead as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericRead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericWrite as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericWrite)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericExecute as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericExecute)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GENERIC_MAPPING>())).GenericAll as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_GENERIC_MAPPING),
            "::",
            stringify!(GenericAll)
        )
    );
}
pub type GENERIC_MAPPING = _GENERIC_MAPPING;
pub type PGENERIC_MAPPING = *mut GENERIC_MAPPING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LUID_AND_ATTRIBUTES {
    pub Luid: LUID,
    pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__LUID_AND_ATTRIBUTES() {
    assert_eq!(
        ::std::mem::size_of::<_LUID_AND_ATTRIBUTES>(),
        12usize,
        concat!("Size of: ", stringify!(_LUID_AND_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_LUID_AND_ATTRIBUTES>(),
        4usize,
        concat!("Alignment of ", stringify!(_LUID_AND_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LUID_AND_ATTRIBUTES>())).Luid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Luid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_LUID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_LUID_AND_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
pub type LUID_AND_ATTRIBUTES = _LUID_AND_ATTRIBUTES;
pub type PLUID_AND_ATTRIBUTES = *mut _LUID_AND_ATTRIBUTES;
pub type LUID_AND_ATTRIBUTES_ARRAY = [LUID_AND_ATTRIBUTES; 1usize];
pub type PLUID_AND_ATTRIBUTES_ARRAY = *mut LUID_AND_ATTRIBUTES_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_IDENTIFIER_AUTHORITY {
    pub Value: [BYTE; 6usize],
}
#[test]
fn bindgen_test_layout__SID_IDENTIFIER_AUTHORITY() {
    assert_eq!(
        ::std::mem::size_of::<_SID_IDENTIFIER_AUTHORITY>(),
        6usize,
        concat!("Size of: ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID_IDENTIFIER_AUTHORITY>(),
        1usize,
        concat!("Alignment of ", stringify!(_SID_IDENTIFIER_AUTHORITY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID_IDENTIFIER_AUTHORITY>())).Value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_IDENTIFIER_AUTHORITY),
            "::",
            stringify!(Value)
        )
    );
}
pub type SID_IDENTIFIER_AUTHORITY = _SID_IDENTIFIER_AUTHORITY;
pub type PSID_IDENTIFIER_AUTHORITY = *mut _SID_IDENTIFIER_AUTHORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID {
    pub Revision: BYTE,
    pub SubAuthorityCount: BYTE,
    pub IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    pub SubAuthority: [DWORD; 1usize],
}
#[test]
fn bindgen_test_layout__SID() {
    assert_eq!(
        ::std::mem::size_of::<_SID>(),
        12usize,
        concat!("Size of: ", stringify!(_SID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID>())).Revision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID>())).SubAuthorityCount as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthorityCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID>())).IdentifierAuthority as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(IdentifierAuthority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID>())).SubAuthority as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID),
            "::",
            stringify!(SubAuthority)
        )
    );
}
pub type SID = _SID;
pub type PISID = *mut _SID;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_SID {
    pub Sid: SID,
    pub Buffer: [BYTE; 68usize],
    _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_SID() {
    assert_eq!(
        ::std::mem::size_of::<_SE_SID>(),
        68usize,
        concat!("Size of: ", stringify!(_SE_SID))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_SID>(),
        4usize,
        concat!("Alignment of ", stringify!(_SE_SID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_SID>())).Sid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SID),
            "::",
            stringify!(Sid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_SID>())).Buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SID),
            "::",
            stringify!(Buffer)
        )
    );
}
pub type SE_SID = _SE_SID;
pub type PSE_SID = *mut _SE_SID;
pub const _SID_NAME_USE_SidTypeUser: _SID_NAME_USE = 1;
pub const _SID_NAME_USE_SidTypeGroup: _SID_NAME_USE = 2;
pub const _SID_NAME_USE_SidTypeDomain: _SID_NAME_USE = 3;
pub const _SID_NAME_USE_SidTypeAlias: _SID_NAME_USE = 4;
pub const _SID_NAME_USE_SidTypeWellKnownGroup: _SID_NAME_USE = 5;
pub const _SID_NAME_USE_SidTypeDeletedAccount: _SID_NAME_USE = 6;
pub const _SID_NAME_USE_SidTypeInvalid: _SID_NAME_USE = 7;
pub const _SID_NAME_USE_SidTypeUnknown: _SID_NAME_USE = 8;
pub const _SID_NAME_USE_SidTypeComputer: _SID_NAME_USE = 9;
pub const _SID_NAME_USE_SidTypeLabel: _SID_NAME_USE = 10;
pub const _SID_NAME_USE_SidTypeLogonSession: _SID_NAME_USE = 11;
pub type _SID_NAME_USE = i32;
pub use self::_SID_NAME_USE as SID_NAME_USE;
pub type PSID_NAME_USE = *mut _SID_NAME_USE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES {
    pub Sid: PSID,
    pub Attributes: DWORD,
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES() {
    assert_eq!(
        ::std::mem::size_of::<_SID_AND_ATTRIBUTES>(),
        16usize,
        concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID_AND_ATTRIBUTES>(),
        8usize,
        concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES>())).Sid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES),
            "::",
            stringify!(Sid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES>())).Attributes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES),
            "::",
            stringify!(Attributes)
        )
    );
}
pub type SID_AND_ATTRIBUTES = _SID_AND_ATTRIBUTES;
pub type PSID_AND_ATTRIBUTES = *mut _SID_AND_ATTRIBUTES;
pub type SID_AND_ATTRIBUTES_ARRAY = [SID_AND_ATTRIBUTES; 1usize];
pub type PSID_AND_ATTRIBUTES_ARRAY = *mut SID_AND_ATTRIBUTES_ARRAY;
pub type SID_HASH_ENTRY = ULONG_PTR;
pub type PSID_HASH_ENTRY = *mut ULONG_PTR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SID_AND_ATTRIBUTES_HASH {
    pub SidCount: DWORD,
    pub SidAttr: PSID_AND_ATTRIBUTES,
    pub Hash: [SID_HASH_ENTRY; 32usize],
}
#[test]
fn bindgen_test_layout__SID_AND_ATTRIBUTES_HASH() {
    assert_eq!(
        ::std::mem::size_of::<_SID_AND_ATTRIBUTES_HASH>(),
        272usize,
        concat!("Size of: ", stringify!(_SID_AND_ATTRIBUTES_HASH))
    );
    assert_eq!(
        ::std::mem::align_of::<_SID_AND_ATTRIBUTES_HASH>(),
        8usize,
        concat!("Alignment of ", stringify!(_SID_AND_ATTRIBUTES_HASH))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES_HASH),
            "::",
            stringify!(SidCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).SidAttr as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES_HASH),
            "::",
            stringify!(SidAttr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SID_AND_ATTRIBUTES_HASH>())).Hash as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SID_AND_ATTRIBUTES_HASH),
            "::",
            stringify!(Hash)
        )
    );
}
pub type SID_AND_ATTRIBUTES_HASH = _SID_AND_ATTRIBUTES_HASH;
pub type PSID_AND_ATTRIBUTES_HASH = *mut _SID_AND_ATTRIBUTES_HASH;
pub const WELL_KNOWN_SID_TYPE_WinNullSid: WELL_KNOWN_SID_TYPE = 0;
pub const WELL_KNOWN_SID_TYPE_WinWorldSid: WELL_KNOWN_SID_TYPE = 1;
pub const WELL_KNOWN_SID_TYPE_WinLocalSid: WELL_KNOWN_SID_TYPE = 2;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerSid: WELL_KNOWN_SID_TYPE = 3;
pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupSid: WELL_KNOWN_SID_TYPE = 4;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerServerSid: WELL_KNOWN_SID_TYPE = 5;
pub const WELL_KNOWN_SID_TYPE_WinCreatorGroupServerSid: WELL_KNOWN_SID_TYPE = 6;
pub const WELL_KNOWN_SID_TYPE_WinNtAuthoritySid: WELL_KNOWN_SID_TYPE = 7;
pub const WELL_KNOWN_SID_TYPE_WinDialupSid: WELL_KNOWN_SID_TYPE = 8;
pub const WELL_KNOWN_SID_TYPE_WinNetworkSid: WELL_KNOWN_SID_TYPE = 9;
pub const WELL_KNOWN_SID_TYPE_WinBatchSid: WELL_KNOWN_SID_TYPE = 10;
pub const WELL_KNOWN_SID_TYPE_WinInteractiveSid: WELL_KNOWN_SID_TYPE = 11;
pub const WELL_KNOWN_SID_TYPE_WinServiceSid: WELL_KNOWN_SID_TYPE = 12;
pub const WELL_KNOWN_SID_TYPE_WinAnonymousSid: WELL_KNOWN_SID_TYPE = 13;
pub const WELL_KNOWN_SID_TYPE_WinProxySid: WELL_KNOWN_SID_TYPE = 14;
pub const WELL_KNOWN_SID_TYPE_WinEnterpriseControllersSid: WELL_KNOWN_SID_TYPE = 15;
pub const WELL_KNOWN_SID_TYPE_WinSelfSid: WELL_KNOWN_SID_TYPE = 16;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticatedUserSid: WELL_KNOWN_SID_TYPE = 17;
pub const WELL_KNOWN_SID_TYPE_WinRestrictedCodeSid: WELL_KNOWN_SID_TYPE = 18;
pub const WELL_KNOWN_SID_TYPE_WinTerminalServerSid: WELL_KNOWN_SID_TYPE = 19;
pub const WELL_KNOWN_SID_TYPE_WinRemoteLogonIdSid: WELL_KNOWN_SID_TYPE = 20;
pub const WELL_KNOWN_SID_TYPE_WinLogonIdsSid: WELL_KNOWN_SID_TYPE = 21;
pub const WELL_KNOWN_SID_TYPE_WinLocalSystemSid: WELL_KNOWN_SID_TYPE = 22;
pub const WELL_KNOWN_SID_TYPE_WinLocalServiceSid: WELL_KNOWN_SID_TYPE = 23;
pub const WELL_KNOWN_SID_TYPE_WinNetworkServiceSid: WELL_KNOWN_SID_TYPE = 24;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDomainSid: WELL_KNOWN_SID_TYPE = 25;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAdministratorsSid: WELL_KNOWN_SID_TYPE = 26;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinUsersSid: WELL_KNOWN_SID_TYPE = 27;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinGuestsSid: WELL_KNOWN_SID_TYPE = 28;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPowerUsersSid: WELL_KNOWN_SID_TYPE = 29;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccountOperatorsSid: WELL_KNOWN_SID_TYPE = 30;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinSystemOperatorsSid: WELL_KNOWN_SID_TYPE = 31;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPrintOperatorsSid: WELL_KNOWN_SID_TYPE = 32;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinBackupOperatorsSid: WELL_KNOWN_SID_TYPE = 33;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinReplicatorSid: WELL_KNOWN_SID_TYPE = 34;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPreWindows2000CompatibleAccessSid: WELL_KNOWN_SID_TYPE = 35;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteDesktopUsersSid: WELL_KNOWN_SID_TYPE = 36;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinNetworkConfigurationOperatorsSid: WELL_KNOWN_SID_TYPE = 37;
pub const WELL_KNOWN_SID_TYPE_WinAccountAdministratorSid: WELL_KNOWN_SID_TYPE = 38;
pub const WELL_KNOWN_SID_TYPE_WinAccountGuestSid: WELL_KNOWN_SID_TYPE = 39;
pub const WELL_KNOWN_SID_TYPE_WinAccountKrbtgtSid: WELL_KNOWN_SID_TYPE = 40;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainAdminsSid: WELL_KNOWN_SID_TYPE = 41;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainUsersSid: WELL_KNOWN_SID_TYPE = 42;
pub const WELL_KNOWN_SID_TYPE_WinAccountDomainGuestsSid: WELL_KNOWN_SID_TYPE = 43;
pub const WELL_KNOWN_SID_TYPE_WinAccountComputersSid: WELL_KNOWN_SID_TYPE = 44;
pub const WELL_KNOWN_SID_TYPE_WinAccountControllersSid: WELL_KNOWN_SID_TYPE = 45;
pub const WELL_KNOWN_SID_TYPE_WinAccountCertAdminsSid: WELL_KNOWN_SID_TYPE = 46;
pub const WELL_KNOWN_SID_TYPE_WinAccountSchemaAdminsSid: WELL_KNOWN_SID_TYPE = 47;
pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseAdminsSid: WELL_KNOWN_SID_TYPE = 48;
pub const WELL_KNOWN_SID_TYPE_WinAccountPolicyAdminsSid: WELL_KNOWN_SID_TYPE = 49;
pub const WELL_KNOWN_SID_TYPE_WinAccountRasAndIasServersSid: WELL_KNOWN_SID_TYPE = 50;
pub const WELL_KNOWN_SID_TYPE_WinNTLMAuthenticationSid: WELL_KNOWN_SID_TYPE = 51;
pub const WELL_KNOWN_SID_TYPE_WinDigestAuthenticationSid: WELL_KNOWN_SID_TYPE = 52;
pub const WELL_KNOWN_SID_TYPE_WinSChannelAuthenticationSid: WELL_KNOWN_SID_TYPE = 53;
pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationSid: WELL_KNOWN_SID_TYPE = 54;
pub const WELL_KNOWN_SID_TYPE_WinOtherOrganizationSid: WELL_KNOWN_SID_TYPE = 55;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinIncomingForestTrustBuildersSid: WELL_KNOWN_SID_TYPE = 56;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfMonitoringUsersSid: WELL_KNOWN_SID_TYPE = 57;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinPerfLoggingUsersSid: WELL_KNOWN_SID_TYPE = 58;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAuthorizationAccessSid: WELL_KNOWN_SID_TYPE = 59;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinTerminalServerLicenseServersSid: WELL_KNOWN_SID_TYPE = 60;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDCOMUsersSid: WELL_KNOWN_SID_TYPE = 61;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinIUsersSid: WELL_KNOWN_SID_TYPE = 62;
pub const WELL_KNOWN_SID_TYPE_WinIUserSid: WELL_KNOWN_SID_TYPE = 63;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinCryptoOperatorsSid: WELL_KNOWN_SID_TYPE = 64;
pub const WELL_KNOWN_SID_TYPE_WinUntrustedLabelSid: WELL_KNOWN_SID_TYPE = 65;
pub const WELL_KNOWN_SID_TYPE_WinLowLabelSid: WELL_KNOWN_SID_TYPE = 66;
pub const WELL_KNOWN_SID_TYPE_WinMediumLabelSid: WELL_KNOWN_SID_TYPE = 67;
pub const WELL_KNOWN_SID_TYPE_WinHighLabelSid: WELL_KNOWN_SID_TYPE = 68;
pub const WELL_KNOWN_SID_TYPE_WinSystemLabelSid: WELL_KNOWN_SID_TYPE = 69;
pub const WELL_KNOWN_SID_TYPE_WinWriteRestrictedCodeSid: WELL_KNOWN_SID_TYPE = 70;
pub const WELL_KNOWN_SID_TYPE_WinCreatorOwnerRightsSid: WELL_KNOWN_SID_TYPE = 71;
pub const WELL_KNOWN_SID_TYPE_WinCacheablePrincipalsGroupSid: WELL_KNOWN_SID_TYPE = 72;
pub const WELL_KNOWN_SID_TYPE_WinNonCacheablePrincipalsGroupSid: WELL_KNOWN_SID_TYPE = 73;
pub const WELL_KNOWN_SID_TYPE_WinEnterpriseReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 74;
pub const WELL_KNOWN_SID_TYPE_WinAccountReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 75;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinEventLogReadersGroup: WELL_KNOWN_SID_TYPE = 76;
pub const WELL_KNOWN_SID_TYPE_WinNewEnterpriseReadonlyControllersSid: WELL_KNOWN_SID_TYPE = 77;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinCertSvcDComAccessGroup: WELL_KNOWN_SID_TYPE = 78;
pub const WELL_KNOWN_SID_TYPE_WinMediumPlusLabelSid: WELL_KNOWN_SID_TYPE = 79;
pub const WELL_KNOWN_SID_TYPE_WinLocalLogonSid: WELL_KNOWN_SID_TYPE = 80;
pub const WELL_KNOWN_SID_TYPE_WinConsoleLogonSid: WELL_KNOWN_SID_TYPE = 81;
pub const WELL_KNOWN_SID_TYPE_WinThisOrganizationCertificateSid: WELL_KNOWN_SID_TYPE = 82;
pub const WELL_KNOWN_SID_TYPE_WinApplicationPackageAuthoritySid: WELL_KNOWN_SID_TYPE = 83;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAnyPackageSid: WELL_KNOWN_SID_TYPE = 84;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientSid: WELL_KNOWN_SID_TYPE = 85;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityInternetClientServerSid: WELL_KNOWN_SID_TYPE = 86;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityPrivateNetworkClientServerSid: WELL_KNOWN_SID_TYPE = 87;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityPicturesLibrarySid: WELL_KNOWN_SID_TYPE = 88;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityVideosLibrarySid: WELL_KNOWN_SID_TYPE = 89;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityMusicLibrarySid: WELL_KNOWN_SID_TYPE = 90;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityDocumentsLibrarySid: WELL_KNOWN_SID_TYPE = 91;
pub const WELL_KNOWN_SID_TYPE_WinCapabilitySharedUserCertificatesSid: WELL_KNOWN_SID_TYPE = 92;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityEnterpriseAuthenticationSid: WELL_KNOWN_SID_TYPE = 93;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityRemovableStorageSid: WELL_KNOWN_SID_TYPE = 94;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSRemoteAccessServersSid: WELL_KNOWN_SID_TYPE = 95;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSEndpointServersSid: WELL_KNOWN_SID_TYPE = 96;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRDSManagementServersSid: WELL_KNOWN_SID_TYPE = 97;
pub const WELL_KNOWN_SID_TYPE_WinUserModeDriversSid: WELL_KNOWN_SID_TYPE = 98;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinHyperVAdminsSid: WELL_KNOWN_SID_TYPE = 99;
pub const WELL_KNOWN_SID_TYPE_WinAccountCloneableControllersSid: WELL_KNOWN_SID_TYPE = 100;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinAccessControlAssistanceOperatorsSid: WELL_KNOWN_SID_TYPE =
    101;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinRemoteManagementUsersSid: WELL_KNOWN_SID_TYPE = 102;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationAuthorityAssertedSid: WELL_KNOWN_SID_TYPE = 103;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationServiceAssertedSid: WELL_KNOWN_SID_TYPE = 104;
pub const WELL_KNOWN_SID_TYPE_WinLocalAccountSid: WELL_KNOWN_SID_TYPE = 105;
pub const WELL_KNOWN_SID_TYPE_WinLocalAccountAndAdministratorSid: WELL_KNOWN_SID_TYPE = 106;
pub const WELL_KNOWN_SID_TYPE_WinAccountProtectedUsersSid: WELL_KNOWN_SID_TYPE = 107;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityAppointmentsSid: WELL_KNOWN_SID_TYPE = 108;
pub const WELL_KNOWN_SID_TYPE_WinCapabilityContactsSid: WELL_KNOWN_SID_TYPE = 109;
pub const WELL_KNOWN_SID_TYPE_WinAccountDefaultSystemManagedSid: WELL_KNOWN_SID_TYPE = 110;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDefaultSystemManagedGroupSid: WELL_KNOWN_SID_TYPE = 111;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinStorageReplicaAdminsSid: WELL_KNOWN_SID_TYPE = 112;
pub const WELL_KNOWN_SID_TYPE_WinAccountKeyAdminsSid: WELL_KNOWN_SID_TYPE = 113;
pub const WELL_KNOWN_SID_TYPE_WinAccountEnterpriseKeyAdminsSid: WELL_KNOWN_SID_TYPE = 114;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyTrustSid: WELL_KNOWN_SID_TYPE = 115;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyMFASid: WELL_KNOWN_SID_TYPE = 116;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationKeyPropertyAttestationSid: WELL_KNOWN_SID_TYPE = 117;
pub const WELL_KNOWN_SID_TYPE_WinAuthenticationFreshKeyAuthSid: WELL_KNOWN_SID_TYPE = 118;
pub const WELL_KNOWN_SID_TYPE_WinBuiltinDeviceOwnersSid: WELL_KNOWN_SID_TYPE = 119;
pub type WELL_KNOWN_SID_TYPE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL {
    pub AclRevision: BYTE,
    pub Sbz1: BYTE,
    pub AclSize: WORD,
    pub AceCount: WORD,
    pub Sbz2: WORD,
}
#[test]
fn bindgen_test_layout__ACL() {
    assert_eq!(
        ::std::mem::size_of::<_ACL>(),
        8usize,
        concat!("Size of: ", stringify!(_ACL))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACL>(),
        2usize,
        concat!("Alignment of ", stringify!(_ACL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACL>())).AclRevision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(AclRevision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACL>())).Sbz1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(Sbz1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACL>())).AclSize as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(AclSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACL>())).AceCount as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(AceCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACL>())).Sbz2 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL),
            "::",
            stringify!(Sbz2)
        )
    );
}
pub type ACL = _ACL;
pub type PACL = *mut ACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACE_HEADER {
    pub AceType: BYTE,
    pub AceFlags: BYTE,
    pub AceSize: WORD,
}
#[test]
fn bindgen_test_layout__ACE_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_ACE_HEADER>(),
        4usize,
        concat!("Size of: ", stringify!(_ACE_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACE_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_ACE_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACE_HEADER),
            "::",
            stringify!(AceType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceFlags as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACE_HEADER),
            "::",
            stringify!(AceFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACE_HEADER>())).AceSize as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACE_HEADER),
            "::",
            stringify!(AceSize)
        )
    );
}
pub type ACE_HEADER = _ACE_HEADER;
pub type PACE_HEADER = *mut ACE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_ACE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_ALLOWED_ACE>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_ALLOWED_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_ALLOWED_ACE>())).SidStart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_ACE = _ACCESS_ALLOWED_ACE;
pub type PACCESS_ALLOWED_ACE = *mut ACCESS_ALLOWED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_DENIED_ACE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_DENIED_ACE>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_DENIED_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_DENIED_ACE>())).SidStart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_ACE = _ACCESS_DENIED_ACE;
pub type PACCESS_DENIED_ACE = *mut ACCESS_DENIED_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_ACE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_ACE>())).SidStart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_ACE = _SYSTEM_AUDIT_ACE;
pub type PSYSTEM_AUDIT_ACE = *mut SYSTEM_AUDIT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ALARM_ACE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_ACE>())).SidStart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_ACE = _SYSTEM_ALARM_ACE;
pub type PSYSTEM_ALARM_ACE = *mut SYSTEM_ALARM_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_RESOURCE_ATTRIBUTE_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_RESOURCE_ATTRIBUTE_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_RESOURCE_ATTRIBUTE_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_RESOURCE_ATTRIBUTE_ACE = _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
pub type PSYSTEM_RESOURCE_ATTRIBUTE_ACE = *mut _SYSTEM_RESOURCE_ATTRIBUTE_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_SCOPED_POLICY_ID_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_SCOPED_POLICY_ID_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_SCOPED_POLICY_ID_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_SCOPED_POLICY_ID_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_SCOPED_POLICY_ID_ACE = _SYSTEM_SCOPED_POLICY_ID_ACE;
pub type PSYSTEM_SCOPED_POLICY_ID_ACE = *mut _SYSTEM_SCOPED_POLICY_ID_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_MANDATORY_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_MANDATORY_LABEL_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_MANDATORY_LABEL_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_MANDATORY_LABEL_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_MANDATORY_LABEL_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_MANDATORY_LABEL_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_MANDATORY_LABEL_ACE = _SYSTEM_MANDATORY_LABEL_ACE;
pub type PSYSTEM_MANDATORY_LABEL_ACE = *mut _SYSTEM_MANDATORY_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESS_TRUST_LABEL_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_PROCESS_TRUST_LABEL_ACE>())).SidStart as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESS_TRUST_LABEL_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_PROCESS_TRUST_LABEL_ACE = _SYSTEM_PROCESS_TRUST_LABEL_ACE;
pub type PSYSTEM_PROCESS_TRUST_LABEL_ACE = *mut _SYSTEM_PROCESS_TRUST_LABEL_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ACCESS_FILTER_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ACCESS_FILTER_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ACCESS_FILTER_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ACCESS_FILTER_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ACCESS_FILTER_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ACCESS_FILTER_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ACCESS_FILTER_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ACCESS_FILTER_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ACCESS_FILTER_ACE = _SYSTEM_ACCESS_FILTER_ACE;
pub type PSYSTEM_ACCESS_FILTER_ACE = *mut _SYSTEM_ACCESS_FILTER_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_OBJECT_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).Flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).ObjectType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).InheritedObjectType as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_OBJECT_ACE>())).SidStart as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_OBJECT_ACE = _ACCESS_ALLOWED_OBJECT_ACE;
pub type PACCESS_ALLOWED_OBJECT_ACE = *mut _ACCESS_ALLOWED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_DENIED_OBJECT_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).Flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).ObjectType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).InheritedObjectType as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_OBJECT_ACE>())).SidStart as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_OBJECT_ACE = _ACCESS_DENIED_OBJECT_ACE;
pub type PACCESS_DENIED_OBJECT_ACE = *mut _ACCESS_DENIED_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_OBJECT_ACE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).Flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).ObjectType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).InheritedObjectType as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_OBJECT_ACE>())).SidStart as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_OBJECT_ACE = _SYSTEM_AUDIT_OBJECT_ACE;
pub type PSYSTEM_AUDIT_OBJECT_ACE = *mut _SYSTEM_AUDIT_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_OBJECT_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ALARM_OBJECT_ACE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Header as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).Flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).ObjectType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).InheritedObjectType as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_OBJECT_ACE>())).SidStart as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_OBJECT_ACE = _SYSTEM_ALARM_OBJECT_ACE;
pub type PSYSTEM_ALARM_OBJECT_ACE = *mut _SYSTEM_ALARM_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_CALLBACK_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_ALLOWED_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_CALLBACK_ACE = _ACCESS_ALLOWED_CALLBACK_ACE;
pub type PACCESS_ALLOWED_CALLBACK_ACE = *mut _ACCESS_ALLOWED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_CALLBACK_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_DENIED_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_CALLBACK_ACE = _ACCESS_DENIED_CALLBACK_ACE;
pub type PACCESS_DENIED_CALLBACK_ACE = *mut _ACCESS_DENIED_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_AUDIT_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_CALLBACK_ACE = _SYSTEM_AUDIT_CALLBACK_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_ACE = *mut _SYSTEM_AUDIT_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
        12usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_ACE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_ALARM_CALLBACK_ACE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Header as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).Mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_ACE>())).SidStart as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_CALLBACK_ACE = _SYSTEM_ALARM_CALLBACK_ACE;
pub type PSYSTEM_ALARM_CALLBACK_ACE = *mut _SYSTEM_ALARM_CALLBACK_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_ALLOWED_CALLBACK_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).Mask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).Flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).ObjectType as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).InheritedObjectType
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE>())).SidStart as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_ALLOWED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
pub type PACCESS_ALLOWED_CALLBACK_OBJECT_ACE = *mut _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__ACCESS_DENIED_CALLBACK_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).Flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).ObjectType as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).InheritedObjectType
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACCESS_DENIED_CALLBACK_OBJECT_ACE>())).SidStart as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_DENIED_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type ACCESS_DENIED_CALLBACK_OBJECT_ACE = _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
pub type PACCESS_DENIED_CALLBACK_OBJECT_ACE = *mut _ACCESS_DENIED_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_AUDIT_CALLBACK_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).ObjectType as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).InheritedObjectType
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE>())).SidStart as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_AUDIT_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE = *mut _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    pub Header: ACE_HEADER,
    pub Mask: ACCESS_MASK,
    pub Flags: DWORD,
    pub ObjectType: GUID,
    pub InheritedObjectType: GUID,
    pub SidStart: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_ALARM_CALLBACK_OBJECT_ACE() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
        48usize,
        concat!("Size of: ", stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Header as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Header)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).Flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).ObjectType as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(ObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).InheritedObjectType
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(InheritedObjectType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_ALARM_CALLBACK_OBJECT_ACE>())).SidStart as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_ALARM_CALLBACK_OBJECT_ACE),
            "::",
            stringify!(SidStart)
        )
    );
}
pub type SYSTEM_ALARM_CALLBACK_OBJECT_ACE = _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub type PSYSTEM_ALARM_CALLBACK_OBJECT_ACE = *mut _SYSTEM_ALARM_CALLBACK_OBJECT_ACE;
pub const _ACL_INFORMATION_CLASS_AclRevisionInformation: _ACL_INFORMATION_CLASS = 1;
pub const _ACL_INFORMATION_CLASS_AclSizeInformation: _ACL_INFORMATION_CLASS = 2;
pub type _ACL_INFORMATION_CLASS = i32;
pub use self::_ACL_INFORMATION_CLASS as ACL_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL_REVISION_INFORMATION {
    pub AclRevision: DWORD,
}
#[test]
fn bindgen_test_layout__ACL_REVISION_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ACL_REVISION_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_ACL_REVISION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACL_REVISION_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACL_REVISION_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACL_REVISION_INFORMATION>())).AclRevision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_REVISION_INFORMATION),
            "::",
            stringify!(AclRevision)
        )
    );
}
pub type ACL_REVISION_INFORMATION = _ACL_REVISION_INFORMATION;
pub type PACL_REVISION_INFORMATION = *mut ACL_REVISION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACL_SIZE_INFORMATION {
    pub AceCount: DWORD,
    pub AclBytesInUse: DWORD,
    pub AclBytesFree: DWORD,
}
#[test]
fn bindgen_test_layout__ACL_SIZE_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ACL_SIZE_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_ACL_SIZE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACL_SIZE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACL_SIZE_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACL_SIZE_INFORMATION>())).AceCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_SIZE_INFORMATION),
            "::",
            stringify!(AceCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACL_SIZE_INFORMATION>())).AclBytesInUse as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_SIZE_INFORMATION),
            "::",
            stringify!(AclBytesInUse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACL_SIZE_INFORMATION>())).AclBytesFree as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACL_SIZE_INFORMATION),
            "::",
            stringify!(AclBytesFree)
        )
    );
}
pub type ACL_SIZE_INFORMATION = _ACL_SIZE_INFORMATION;
pub type PACL_SIZE_INFORMATION = *mut ACL_SIZE_INFORMATION;
pub type SECURITY_DESCRIPTOR_CONTROL = WORD;
pub type PSECURITY_DESCRIPTOR_CONTROL = *mut WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR_RELATIVE {
    pub Revision: BYTE,
    pub Sbz1: BYTE,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: DWORD,
    pub Group: DWORD,
    pub Sacl: DWORD,
    pub Dacl: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR_RELATIVE() {
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
        20usize,
        concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_DESCRIPTOR_RELATIVE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR_RELATIVE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sbz1 as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Sbz1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Control as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Owner as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Group as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Sacl as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Sacl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR_RELATIVE>())).Dacl as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR_RELATIVE),
            "::",
            stringify!(Dacl)
        )
    );
}
pub type SECURITY_DESCRIPTOR_RELATIVE = _SECURITY_DESCRIPTOR_RELATIVE;
pub type PISECURITY_DESCRIPTOR_RELATIVE = *mut _SECURITY_DESCRIPTOR_RELATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_DESCRIPTOR {
    pub Revision: BYTE,
    pub Sbz1: BYTE,
    pub Control: SECURITY_DESCRIPTOR_CONTROL,
    pub Owner: PSID,
    pub Group: PSID,
    pub Sacl: PACL,
    pub Dacl: PACL,
}
#[test]
fn bindgen_test_layout__SECURITY_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_DESCRIPTOR>(),
        40usize,
        concat!("Size of: ", stringify!(_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Revision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Sbz1 as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Sbz1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Control as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Sacl as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Sacl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_DESCRIPTOR>())).Dacl as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Dacl)
        )
    );
}
pub type SECURITY_DESCRIPTOR = _SECURITY_DESCRIPTOR;
pub type PISECURITY_DESCRIPTOR = *mut _SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_OBJECT_AI_PARAMS {
    pub Size: DWORD,
    pub ConstraintMask: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_OBJECT_AI_PARAMS() {
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_OBJECT_AI_PARAMS>(),
        8usize,
        concat!("Size of: ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_OBJECT_AI_PARAMS>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_OBJECT_AI_PARAMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_OBJECT_AI_PARAMS),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_OBJECT_AI_PARAMS>())).ConstraintMask as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_OBJECT_AI_PARAMS),
            "::",
            stringify!(ConstraintMask)
        )
    );
}
pub type SECURITY_OBJECT_AI_PARAMS = _SECURITY_OBJECT_AI_PARAMS;
pub type PSECURITY_OBJECT_AI_PARAMS = *mut _SECURITY_OBJECT_AI_PARAMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _OBJECT_TYPE_LIST {
    pub Level: WORD,
    pub Sbz: WORD,
    pub ObjectType: *mut GUID,
}
#[test]
fn bindgen_test_layout__OBJECT_TYPE_LIST() {
    assert_eq!(
        ::std::mem::size_of::<_OBJECT_TYPE_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(_OBJECT_TYPE_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_OBJECT_TYPE_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(_OBJECT_TYPE_LIST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).Level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_LIST),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).Sbz as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_LIST),
            "::",
            stringify!(Sbz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OBJECT_TYPE_LIST>())).ObjectType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OBJECT_TYPE_LIST),
            "::",
            stringify!(ObjectType)
        )
    );
}
pub type OBJECT_TYPE_LIST = _OBJECT_TYPE_LIST;
pub type POBJECT_TYPE_LIST = *mut _OBJECT_TYPE_LIST;
pub const _AUDIT_EVENT_TYPE_AuditEventObjectAccess: _AUDIT_EVENT_TYPE = 0;
pub const _AUDIT_EVENT_TYPE_AuditEventDirectoryServiceAccess: _AUDIT_EVENT_TYPE = 1;
pub type _AUDIT_EVENT_TYPE = i32;
pub use self::_AUDIT_EVENT_TYPE as AUDIT_EVENT_TYPE;
pub type PAUDIT_EVENT_TYPE = *mut _AUDIT_EVENT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PRIVILEGE_SET {
    pub PrivilegeCount: DWORD,
    pub Control: DWORD,
    pub Privilege: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__PRIVILEGE_SET() {
    assert_eq!(
        ::std::mem::size_of::<_PRIVILEGE_SET>(),
        20usize,
        concat!("Size of: ", stringify!(_PRIVILEGE_SET))
    );
    assert_eq!(
        ::std::mem::align_of::<_PRIVILEGE_SET>(),
        4usize,
        concat!("Alignment of ", stringify!(_PRIVILEGE_SET))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).PrivilegeCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).Control as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PRIVILEGE_SET>())).Privilege as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PRIVILEGE_SET),
            "::",
            stringify!(Privilege)
        )
    );
}
pub type PRIVILEGE_SET = _PRIVILEGE_SET;
pub type PPRIVILEGE_SET = *mut _PRIVILEGE_SET;
pub const _ACCESS_REASON_TYPE_AccessReasonNone: _ACCESS_REASON_TYPE = 0;
pub const _ACCESS_REASON_TYPE_AccessReasonAllowedAce: _ACCESS_REASON_TYPE = 65536;
pub const _ACCESS_REASON_TYPE_AccessReasonDeniedAce: _ACCESS_REASON_TYPE = 131072;
pub const _ACCESS_REASON_TYPE_AccessReasonAllowedParentAce: _ACCESS_REASON_TYPE = 196608;
pub const _ACCESS_REASON_TYPE_AccessReasonDeniedParentAce: _ACCESS_REASON_TYPE = 262144;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedByCape: _ACCESS_REASON_TYPE = 327680;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedByParentCape: _ACCESS_REASON_TYPE = 393216;
pub const _ACCESS_REASON_TYPE_AccessReasonNotGrantedToAppContainer: _ACCESS_REASON_TYPE = 458752;
pub const _ACCESS_REASON_TYPE_AccessReasonMissingPrivilege: _ACCESS_REASON_TYPE = 1048576;
pub const _ACCESS_REASON_TYPE_AccessReasonFromPrivilege: _ACCESS_REASON_TYPE = 2097152;
pub const _ACCESS_REASON_TYPE_AccessReasonIntegrityLevel: _ACCESS_REASON_TYPE = 3145728;
pub const _ACCESS_REASON_TYPE_AccessReasonOwnership: _ACCESS_REASON_TYPE = 4194304;
pub const _ACCESS_REASON_TYPE_AccessReasonNullDacl: _ACCESS_REASON_TYPE = 5242880;
pub const _ACCESS_REASON_TYPE_AccessReasonEmptyDacl: _ACCESS_REASON_TYPE = 6291456;
pub const _ACCESS_REASON_TYPE_AccessReasonNoSD: _ACCESS_REASON_TYPE = 7340032;
pub const _ACCESS_REASON_TYPE_AccessReasonNoGrant: _ACCESS_REASON_TYPE = 8388608;
pub const _ACCESS_REASON_TYPE_AccessReasonTrustLabel: _ACCESS_REASON_TYPE = 9437184;
pub const _ACCESS_REASON_TYPE_AccessReasonFilterAce: _ACCESS_REASON_TYPE = 10485760;
pub type _ACCESS_REASON_TYPE = i32;
pub use self::_ACCESS_REASON_TYPE as ACCESS_REASON_TYPE;
pub type ACCESS_REASON = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACCESS_REASONS {
    pub Data: [ACCESS_REASON; 32usize],
}
#[test]
fn bindgen_test_layout__ACCESS_REASONS() {
    assert_eq!(
        ::std::mem::size_of::<_ACCESS_REASONS>(),
        128usize,
        concat!("Size of: ", stringify!(_ACCESS_REASONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACCESS_REASONS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACCESS_REASONS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ACCESS_REASONS>())).Data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACCESS_REASONS),
            "::",
            stringify!(Data)
        )
    );
}
pub type ACCESS_REASONS = _ACCESS_REASONS;
pub type PACCESS_REASONS = *mut _ACCESS_REASONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_SECURITY_DESCRIPTOR {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub SecurityDescriptor: PSECURITY_DESCRIPTOR,
}
#[test]
fn bindgen_test_layout__SE_SECURITY_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<_SE_SECURITY_DESCRIPTOR>(),
        16usize,
        concat!("Size of: ", stringify!(_SE_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_SECURITY_DESCRIPTOR>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_SECURITY_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SECURITY_DESCRIPTOR),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_SECURITY_DESCRIPTOR>())).SecurityDescriptor as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_SECURITY_DESCRIPTOR),
            "::",
            stringify!(SecurityDescriptor)
        )
    );
}
pub type SE_SECURITY_DESCRIPTOR = _SE_SECURITY_DESCRIPTOR;
pub type PSE_SECURITY_DESCRIPTOR = *mut _SE_SECURITY_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REQUEST {
    pub Size: DWORD,
    pub SeSecurityDescriptor: PSE_SECURITY_DESCRIPTOR,
    pub DesiredAccess: ACCESS_MASK,
    pub PreviouslyGrantedAccess: ACCESS_MASK,
    pub PrincipalSelfSid: PSID,
    pub GenericMapping: PGENERIC_MAPPING,
    pub ObjectTypeListCount: DWORD,
    pub ObjectTypeList: POBJECT_TYPE_LIST,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REQUEST() {
    assert_eq!(
        ::std::mem::size_of::<_SE_ACCESS_REQUEST>(),
        56usize,
        concat!("Size of: ", stringify!(_SE_ACCESS_REQUEST))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_ACCESS_REQUEST>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_ACCESS_REQUEST))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).SeSecurityDescriptor as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(SeSecurityDescriptor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).DesiredAccess as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(DesiredAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).PreviouslyGrantedAccess as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(PreviouslyGrantedAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).PrincipalSelfSid as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(PrincipalSelfSid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).GenericMapping as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(GenericMapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeListCount as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(ObjectTypeListCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REQUEST>())).ObjectTypeList as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REQUEST),
            "::",
            stringify!(ObjectTypeList)
        )
    );
}
pub type SE_ACCESS_REQUEST = _SE_ACCESS_REQUEST;
pub type PSE_ACCESS_REQUEST = *mut _SE_ACCESS_REQUEST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_ACCESS_REPLY {
    pub Size: DWORD,
    pub ResultListCount: DWORD,
    pub GrantedAccess: PACCESS_MASK,
    pub AccessStatus: PDWORD,
    pub AccessReason: PACCESS_REASONS,
    pub Privileges: *mut PPRIVILEGE_SET,
}
#[test]
fn bindgen_test_layout__SE_ACCESS_REPLY() {
    assert_eq!(
        ::std::mem::size_of::<_SE_ACCESS_REPLY>(),
        40usize,
        concat!("Size of: ", stringify!(_SE_ACCESS_REPLY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_ACCESS_REPLY>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_ACCESS_REPLY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).ResultListCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(ResultListCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).GrantedAccess as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(GrantedAccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).AccessStatus as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(AccessStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).AccessReason as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(AccessReason)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_ACCESS_REPLY>())).Privileges as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_ACCESS_REPLY),
            "::",
            stringify!(Privileges)
        )
    );
}
pub type SE_ACCESS_REPLY = _SE_ACCESS_REPLY;
pub type PSE_ACCESS_REPLY = *mut _SE_ACCESS_REPLY;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityAnonymous: _SECURITY_IMPERSONATION_LEVEL = 0;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityIdentification: _SECURITY_IMPERSONATION_LEVEL = 1;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityImpersonation: _SECURITY_IMPERSONATION_LEVEL = 2;
pub const _SECURITY_IMPERSONATION_LEVEL_SecurityDelegation: _SECURITY_IMPERSONATION_LEVEL = 3;
pub type _SECURITY_IMPERSONATION_LEVEL = i32;
pub use self::_SECURITY_IMPERSONATION_LEVEL as SECURITY_IMPERSONATION_LEVEL;
pub type PSECURITY_IMPERSONATION_LEVEL = *mut _SECURITY_IMPERSONATION_LEVEL;
pub const _TOKEN_TYPE_TokenPrimary: _TOKEN_TYPE = 1;
pub const _TOKEN_TYPE_TokenImpersonation: _TOKEN_TYPE = 2;
pub type _TOKEN_TYPE = i32;
pub use self::_TOKEN_TYPE as TOKEN_TYPE;
pub type PTOKEN_TYPE = *mut TOKEN_TYPE;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeDefault: _TOKEN_ELEVATION_TYPE = 1;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeFull: _TOKEN_ELEVATION_TYPE = 2;
pub const _TOKEN_ELEVATION_TYPE_TokenElevationTypeLimited: _TOKEN_ELEVATION_TYPE = 3;
pub type _TOKEN_ELEVATION_TYPE = i32;
pub use self::_TOKEN_ELEVATION_TYPE as TOKEN_ELEVATION_TYPE;
pub type PTOKEN_ELEVATION_TYPE = *mut _TOKEN_ELEVATION_TYPE;
pub const _TOKEN_INFORMATION_CLASS_TokenUser: _TOKEN_INFORMATION_CLASS = 1;
pub const _TOKEN_INFORMATION_CLASS_TokenGroups: _TOKEN_INFORMATION_CLASS = 2;
pub const _TOKEN_INFORMATION_CLASS_TokenPrivileges: _TOKEN_INFORMATION_CLASS = 3;
pub const _TOKEN_INFORMATION_CLASS_TokenOwner: _TOKEN_INFORMATION_CLASS = 4;
pub const _TOKEN_INFORMATION_CLASS_TokenPrimaryGroup: _TOKEN_INFORMATION_CLASS = 5;
pub const _TOKEN_INFORMATION_CLASS_TokenDefaultDacl: _TOKEN_INFORMATION_CLASS = 6;
pub const _TOKEN_INFORMATION_CLASS_TokenSource: _TOKEN_INFORMATION_CLASS = 7;
pub const _TOKEN_INFORMATION_CLASS_TokenType: _TOKEN_INFORMATION_CLASS = 8;
pub const _TOKEN_INFORMATION_CLASS_TokenImpersonationLevel: _TOKEN_INFORMATION_CLASS = 9;
pub const _TOKEN_INFORMATION_CLASS_TokenStatistics: _TOKEN_INFORMATION_CLASS = 10;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedSids: _TOKEN_INFORMATION_CLASS = 11;
pub const _TOKEN_INFORMATION_CLASS_TokenSessionId: _TOKEN_INFORMATION_CLASS = 12;
pub const _TOKEN_INFORMATION_CLASS_TokenGroupsAndPrivileges: _TOKEN_INFORMATION_CLASS = 13;
pub const _TOKEN_INFORMATION_CLASS_TokenSessionReference: _TOKEN_INFORMATION_CLASS = 14;
pub const _TOKEN_INFORMATION_CLASS_TokenSandBoxInert: _TOKEN_INFORMATION_CLASS = 15;
pub const _TOKEN_INFORMATION_CLASS_TokenAuditPolicy: _TOKEN_INFORMATION_CLASS = 16;
pub const _TOKEN_INFORMATION_CLASS_TokenOrigin: _TOKEN_INFORMATION_CLASS = 17;
pub const _TOKEN_INFORMATION_CLASS_TokenElevationType: _TOKEN_INFORMATION_CLASS = 18;
pub const _TOKEN_INFORMATION_CLASS_TokenLinkedToken: _TOKEN_INFORMATION_CLASS = 19;
pub const _TOKEN_INFORMATION_CLASS_TokenElevation: _TOKEN_INFORMATION_CLASS = 20;
pub const _TOKEN_INFORMATION_CLASS_TokenHasRestrictions: _TOKEN_INFORMATION_CLASS = 21;
pub const _TOKEN_INFORMATION_CLASS_TokenAccessInformation: _TOKEN_INFORMATION_CLASS = 22;
pub const _TOKEN_INFORMATION_CLASS_TokenVirtualizationAllowed: _TOKEN_INFORMATION_CLASS = 23;
pub const _TOKEN_INFORMATION_CLASS_TokenVirtualizationEnabled: _TOKEN_INFORMATION_CLASS = 24;
pub const _TOKEN_INFORMATION_CLASS_TokenIntegrityLevel: _TOKEN_INFORMATION_CLASS = 25;
pub const _TOKEN_INFORMATION_CLASS_TokenUIAccess: _TOKEN_INFORMATION_CLASS = 26;
pub const _TOKEN_INFORMATION_CLASS_TokenMandatoryPolicy: _TOKEN_INFORMATION_CLASS = 27;
pub const _TOKEN_INFORMATION_CLASS_TokenLogonSid: _TOKEN_INFORMATION_CLASS = 28;
pub const _TOKEN_INFORMATION_CLASS_TokenIsAppContainer: _TOKEN_INFORMATION_CLASS = 29;
pub const _TOKEN_INFORMATION_CLASS_TokenCapabilities: _TOKEN_INFORMATION_CLASS = 30;
pub const _TOKEN_INFORMATION_CLASS_TokenAppContainerSid: _TOKEN_INFORMATION_CLASS = 31;
pub const _TOKEN_INFORMATION_CLASS_TokenAppContainerNumber: _TOKEN_INFORMATION_CLASS = 32;
pub const _TOKEN_INFORMATION_CLASS_TokenUserClaimAttributes: _TOKEN_INFORMATION_CLASS = 33;
pub const _TOKEN_INFORMATION_CLASS_TokenDeviceClaimAttributes: _TOKEN_INFORMATION_CLASS = 34;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedUserClaimAttributes: _TOKEN_INFORMATION_CLASS =
    35;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedDeviceClaimAttributes: _TOKEN_INFORMATION_CLASS =
    36;
pub const _TOKEN_INFORMATION_CLASS_TokenDeviceGroups: _TOKEN_INFORMATION_CLASS = 37;
pub const _TOKEN_INFORMATION_CLASS_TokenRestrictedDeviceGroups: _TOKEN_INFORMATION_CLASS = 38;
pub const _TOKEN_INFORMATION_CLASS_TokenSecurityAttributes: _TOKEN_INFORMATION_CLASS = 39;
pub const _TOKEN_INFORMATION_CLASS_TokenIsRestricted: _TOKEN_INFORMATION_CLASS = 40;
pub const _TOKEN_INFORMATION_CLASS_TokenProcessTrustLevel: _TOKEN_INFORMATION_CLASS = 41;
pub const _TOKEN_INFORMATION_CLASS_TokenPrivateNameSpace: _TOKEN_INFORMATION_CLASS = 42;
pub const _TOKEN_INFORMATION_CLASS_TokenSingletonAttributes: _TOKEN_INFORMATION_CLASS = 43;
pub const _TOKEN_INFORMATION_CLASS_TokenBnoIsolation: _TOKEN_INFORMATION_CLASS = 44;
pub const _TOKEN_INFORMATION_CLASS_TokenChildProcessFlags: _TOKEN_INFORMATION_CLASS = 45;
pub const _TOKEN_INFORMATION_CLASS_TokenIsLessPrivilegedAppContainer: _TOKEN_INFORMATION_CLASS = 46;
pub const _TOKEN_INFORMATION_CLASS_MaxTokenInfoClass: _TOKEN_INFORMATION_CLASS = 47;
pub type _TOKEN_INFORMATION_CLASS = i32;
pub use self::_TOKEN_INFORMATION_CLASS as TOKEN_INFORMATION_CLASS;
pub type PTOKEN_INFORMATION_CLASS = *mut _TOKEN_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER {
    pub User: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_USER() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_USER>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_USER))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_USER>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_USER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_USER>())).User as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_USER),
            "::",
            stringify!(User)
        )
    );
}
pub type TOKEN_USER = _TOKEN_USER;
pub type PTOKEN_USER = *mut _TOKEN_USER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SE_TOKEN_USER {
    pub __bindgen_anon_1: _SE_TOKEN_USER__bindgen_ty_1,
    pub __bindgen_anon_2: _SE_TOKEN_USER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_1 {
    pub TokenUser: TOKEN_USER,
    pub User: SID_AND_ATTRIBUTES,
    _bindgen_union_align: [u64; 2usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).TokenUser as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_1),
            "::",
            stringify!(TokenUser)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_1>())).User as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_1),
            "::",
            stringify!(User)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SE_TOKEN_USER__bindgen_ty_2 {
    pub Sid: SID,
    pub Buffer: [BYTE; 68usize],
    _bindgen_union_align: [u32; 17usize],
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
        68usize,
        concat!("Size of: ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_TOKEN_USER__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(_SE_TOKEN_USER__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Sid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_2),
            "::",
            stringify!(Sid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_TOKEN_USER__bindgen_ty_2>())).Buffer as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_TOKEN_USER__bindgen_ty_2),
            "::",
            stringify!(Buffer)
        )
    );
}
#[test]
fn bindgen_test_layout__SE_TOKEN_USER() {
    assert_eq!(
        ::std::mem::size_of::<_SE_TOKEN_USER>(),
        88usize,
        concat!("Size of: ", stringify!(_SE_TOKEN_USER))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_TOKEN_USER>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_TOKEN_USER))
    );
}
pub type SE_TOKEN_USER = _SE_TOKEN_USER;
pub type PSE_TOKEN_USER = _SE_TOKEN_USER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS {
    pub GroupCount: DWORD,
    pub Groups: [SID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__TOKEN_GROUPS() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_GROUPS>(),
        24usize,
        concat!("Size of: ", stringify!(_TOKEN_GROUPS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_GROUPS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_GROUPS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_GROUPS>())).GroupCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS),
            "::",
            stringify!(GroupCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_GROUPS>())).Groups as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS),
            "::",
            stringify!(Groups)
        )
    );
}
pub type TOKEN_GROUPS = _TOKEN_GROUPS;
pub type PTOKEN_GROUPS = *mut _TOKEN_GROUPS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIVILEGES {
    pub PrivilegeCount: DWORD,
    pub Privileges: [LUID_AND_ATTRIBUTES; 1usize],
}
#[test]
fn bindgen_test_layout__TOKEN_PRIVILEGES() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_PRIVILEGES>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_PRIVILEGES))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_PRIVILEGES>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_PRIVILEGES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_PRIVILEGES>())).PrivilegeCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_PRIVILEGES),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_PRIVILEGES>())).Privileges as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_PRIVILEGES),
            "::",
            stringify!(Privileges)
        )
    );
}
pub type TOKEN_PRIVILEGES = _TOKEN_PRIVILEGES;
pub type PTOKEN_PRIVILEGES = *mut _TOKEN_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_OWNER {
    pub Owner: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_OWNER() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_OWNER>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_OWNER))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_OWNER>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_OWNER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_OWNER>())).Owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_OWNER),
            "::",
            stringify!(Owner)
        )
    );
}
pub type TOKEN_OWNER = _TOKEN_OWNER;
pub type PTOKEN_OWNER = *mut _TOKEN_OWNER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_PRIMARY_GROUP {
    pub PrimaryGroup: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_PRIMARY_GROUP() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_PRIMARY_GROUP>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_PRIMARY_GROUP))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_PRIMARY_GROUP>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_PRIMARY_GROUP))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_PRIMARY_GROUP>())).PrimaryGroup as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_PRIMARY_GROUP),
            "::",
            stringify!(PrimaryGroup)
        )
    );
}
pub type TOKEN_PRIMARY_GROUP = _TOKEN_PRIMARY_GROUP;
pub type PTOKEN_PRIMARY_GROUP = *mut _TOKEN_PRIMARY_GROUP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEFAULT_DACL {
    pub DefaultDacl: PACL,
}
#[test]
fn bindgen_test_layout__TOKEN_DEFAULT_DACL() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_DEFAULT_DACL>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_DEFAULT_DACL))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_DEFAULT_DACL>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_DEFAULT_DACL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_DEFAULT_DACL>())).DefaultDacl as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_DEFAULT_DACL),
            "::",
            stringify!(DefaultDacl)
        )
    );
}
pub type TOKEN_DEFAULT_DACL = _TOKEN_DEFAULT_DACL;
pub type PTOKEN_DEFAULT_DACL = *mut _TOKEN_DEFAULT_DACL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_USER_CLAIMS {
    pub UserClaims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__TOKEN_USER_CLAIMS() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_USER_CLAIMS>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_USER_CLAIMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_USER_CLAIMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_USER_CLAIMS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_USER_CLAIMS>())).UserClaims as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_USER_CLAIMS),
            "::",
            stringify!(UserClaims)
        )
    );
}
pub type TOKEN_USER_CLAIMS = _TOKEN_USER_CLAIMS;
pub type PTOKEN_USER_CLAIMS = *mut _TOKEN_USER_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_DEVICE_CLAIMS {
    pub DeviceClaims: PCLAIMS_BLOB,
}
#[test]
fn bindgen_test_layout__TOKEN_DEVICE_CLAIMS() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_DEVICE_CLAIMS>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_DEVICE_CLAIMS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_DEVICE_CLAIMS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_DEVICE_CLAIMS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_DEVICE_CLAIMS>())).DeviceClaims as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_DEVICE_CLAIMS),
            "::",
            stringify!(DeviceClaims)
        )
    );
}
pub type TOKEN_DEVICE_CLAIMS = _TOKEN_DEVICE_CLAIMS;
pub type PTOKEN_DEVICE_CLAIMS = *mut _TOKEN_DEVICE_CLAIMS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_GROUPS_AND_PRIVILEGES {
    pub SidCount: DWORD,
    pub SidLength: DWORD,
    pub Sids: PSID_AND_ATTRIBUTES,
    pub RestrictedSidCount: DWORD,
    pub RestrictedSidLength: DWORD,
    pub RestrictedSids: PSID_AND_ATTRIBUTES,
    pub PrivilegeCount: DWORD,
    pub PrivilegeLength: DWORD,
    pub Privileges: PLUID_AND_ATTRIBUTES,
    pub AuthenticationId: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_GROUPS_AND_PRIVILEGES() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_GROUPS_AND_PRIVILEGES>(),
        56usize,
        concat!("Size of: ", stringify!(_TOKEN_GROUPS_AND_PRIVILEGES))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_GROUPS_AND_PRIVILEGES>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_GROUPS_AND_PRIVILEGES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).SidCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(SidCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).SidLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(SidLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).Sids as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(Sids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).RestrictedSidCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(RestrictedSidCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).RestrictedSidLength as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(RestrictedSidLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).RestrictedSids as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(RestrictedSids)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).PrivilegeCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).PrivilegeLength as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(PrivilegeLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).Privileges as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(Privileges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_GROUPS_AND_PRIVILEGES>())).AuthenticationId as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_GROUPS_AND_PRIVILEGES),
            "::",
            stringify!(AuthenticationId)
        )
    );
}
pub type TOKEN_GROUPS_AND_PRIVILEGES = _TOKEN_GROUPS_AND_PRIVILEGES;
pub type PTOKEN_GROUPS_AND_PRIVILEGES = *mut _TOKEN_GROUPS_AND_PRIVILEGES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_LINKED_TOKEN {
    pub LinkedToken: HANDLE,
}
#[test]
fn bindgen_test_layout__TOKEN_LINKED_TOKEN() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_LINKED_TOKEN>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_LINKED_TOKEN))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_LINKED_TOKEN>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_LINKED_TOKEN))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_LINKED_TOKEN>())).LinkedToken as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_LINKED_TOKEN),
            "::",
            stringify!(LinkedToken)
        )
    );
}
pub type TOKEN_LINKED_TOKEN = _TOKEN_LINKED_TOKEN;
pub type PTOKEN_LINKED_TOKEN = *mut _TOKEN_LINKED_TOKEN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ELEVATION {
    pub TokenIsElevated: DWORD,
}
#[test]
fn bindgen_test_layout__TOKEN_ELEVATION() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_ELEVATION>(),
        4usize,
        concat!("Size of: ", stringify!(_TOKEN_ELEVATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_ELEVATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_ELEVATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ELEVATION>())).TokenIsElevated as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ELEVATION),
            "::",
            stringify!(TokenIsElevated)
        )
    );
}
pub type TOKEN_ELEVATION = _TOKEN_ELEVATION;
pub type PTOKEN_ELEVATION = *mut _TOKEN_ELEVATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_LABEL {
    pub Label: SID_AND_ATTRIBUTES,
}
#[test]
fn bindgen_test_layout__TOKEN_MANDATORY_LABEL() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_MANDATORY_LABEL>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_MANDATORY_LABEL))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_MANDATORY_LABEL>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_MANDATORY_LABEL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_MANDATORY_LABEL>())).Label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_MANDATORY_LABEL),
            "::",
            stringify!(Label)
        )
    );
}
pub type TOKEN_MANDATORY_LABEL = _TOKEN_MANDATORY_LABEL;
pub type PTOKEN_MANDATORY_LABEL = *mut _TOKEN_MANDATORY_LABEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_MANDATORY_POLICY {
    pub Policy: DWORD,
}
#[test]
fn bindgen_test_layout__TOKEN_MANDATORY_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_MANDATORY_POLICY>(),
        4usize,
        concat!("Size of: ", stringify!(_TOKEN_MANDATORY_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_MANDATORY_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_MANDATORY_POLICY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_MANDATORY_POLICY>())).Policy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_MANDATORY_POLICY),
            "::",
            stringify!(Policy)
        )
    );
}
pub type TOKEN_MANDATORY_POLICY = _TOKEN_MANDATORY_POLICY;
pub type PTOKEN_MANDATORY_POLICY = *mut _TOKEN_MANDATORY_POLICY;
pub type PSECURITY_ATTRIBUTES_OPAQUE = PVOID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ACCESS_INFORMATION {
    pub SidHash: PSID_AND_ATTRIBUTES_HASH,
    pub RestrictedSidHash: PSID_AND_ATTRIBUTES_HASH,
    pub Privileges: PTOKEN_PRIVILEGES,
    pub AuthenticationId: LUID,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    pub Flags: DWORD,
    pub AppContainerNumber: DWORD,
    pub PackageSid: PSID,
    pub CapabilitiesHash: PSID_AND_ATTRIBUTES_HASH,
    pub TrustLevelSid: PSID,
    pub SecurityAttributes: PSECURITY_ATTRIBUTES_OPAQUE,
}
#[test]
fn bindgen_test_layout__TOKEN_ACCESS_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_ACCESS_INFORMATION>(),
        88usize,
        concat!("Size of: ", stringify!(_TOKEN_ACCESS_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_ACCESS_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_ACCESS_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).SidHash as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(SidHash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).RestrictedSidHash as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(RestrictedSidHash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).Privileges as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(Privileges)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).AuthenticationId as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(AuthenticationId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).TokenType as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(TokenType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).ImpersonationLevel as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).MandatoryPolicy as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(MandatoryPolicy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).Flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).AppContainerNumber as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(AppContainerNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).PackageSid as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(PackageSid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).CapabilitiesHash as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(CapabilitiesHash)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).TrustLevelSid as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(TrustLevelSid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ACCESS_INFORMATION>())).SecurityAttributes as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ACCESS_INFORMATION),
            "::",
            stringify!(SecurityAttributes)
        )
    );
}
pub type TOKEN_ACCESS_INFORMATION = _TOKEN_ACCESS_INFORMATION;
pub type PTOKEN_ACCESS_INFORMATION = *mut _TOKEN_ACCESS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_AUDIT_POLICY {
    pub PerUserPolicy: [BYTE; 30usize],
}
#[test]
fn bindgen_test_layout__TOKEN_AUDIT_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_AUDIT_POLICY>(),
        30usize,
        concat!("Size of: ", stringify!(_TOKEN_AUDIT_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_AUDIT_POLICY>(),
        1usize,
        concat!("Alignment of ", stringify!(_TOKEN_AUDIT_POLICY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_AUDIT_POLICY>())).PerUserPolicy as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_AUDIT_POLICY),
            "::",
            stringify!(PerUserPolicy)
        )
    );
}
pub type TOKEN_AUDIT_POLICY = _TOKEN_AUDIT_POLICY;
pub type PTOKEN_AUDIT_POLICY = *mut _TOKEN_AUDIT_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SOURCE {
    pub SourceName: [CHAR; 8usize],
    pub SourceIdentifier: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_SOURCE() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_SOURCE>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_SOURCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_SOURCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_SOURCE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_SOURCE>())).SourceName as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_SOURCE),
            "::",
            stringify!(SourceName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_SOURCE>())).SourceIdentifier as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_SOURCE),
            "::",
            stringify!(SourceIdentifier)
        )
    );
}
pub type TOKEN_SOURCE = _TOKEN_SOURCE;
pub type PTOKEN_SOURCE = *mut _TOKEN_SOURCE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TOKEN_STATISTICS {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ExpirationTime: LARGE_INTEGER,
    pub TokenType: TOKEN_TYPE,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub DynamicCharged: DWORD,
    pub DynamicAvailable: DWORD,
    pub GroupCount: DWORD,
    pub PrivilegeCount: DWORD,
    pub ModifiedId: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_STATISTICS() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_STATISTICS>(),
        56usize,
        concat!("Size of: ", stringify!(_TOKEN_STATISTICS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_STATISTICS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_STATISTICS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).TokenId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(TokenId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).AuthenticationId as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(AuthenticationId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).ExpirationTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(ExpirationTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).TokenType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(TokenType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).ImpersonationLevel as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).DynamicCharged as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(DynamicCharged)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).DynamicAvailable as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(DynamicAvailable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).GroupCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(GroupCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).PrivilegeCount as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(PrivilegeCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_STATISTICS>())).ModifiedId as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_STATISTICS),
            "::",
            stringify!(ModifiedId)
        )
    );
}
pub type TOKEN_STATISTICS = _TOKEN_STATISTICS;
pub type PTOKEN_STATISTICS = *mut _TOKEN_STATISTICS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_CONTROL {
    pub TokenId: LUID,
    pub AuthenticationId: LUID,
    pub ModifiedId: LUID,
    pub TokenSource: TOKEN_SOURCE,
}
#[test]
fn bindgen_test_layout__TOKEN_CONTROL() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_CONTROL>(),
        40usize,
        concat!("Size of: ", stringify!(_TOKEN_CONTROL))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_CONTROL>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_CONTROL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_CONTROL>())).TokenId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(TokenId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_CONTROL>())).AuthenticationId as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(AuthenticationId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_CONTROL>())).ModifiedId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(ModifiedId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_CONTROL>())).TokenSource as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_CONTROL),
            "::",
            stringify!(TokenSource)
        )
    );
}
pub type TOKEN_CONTROL = _TOKEN_CONTROL;
pub type PTOKEN_CONTROL = *mut _TOKEN_CONTROL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_ORIGIN {
    pub OriginatingLogonSession: LUID,
}
#[test]
fn bindgen_test_layout__TOKEN_ORIGIN() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_ORIGIN>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_ORIGIN))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_ORIGIN>(),
        4usize,
        concat!("Alignment of ", stringify!(_TOKEN_ORIGIN))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_ORIGIN>())).OriginatingLogonSession as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_ORIGIN),
            "::",
            stringify!(OriginatingLogonSession)
        )
    );
}
pub type TOKEN_ORIGIN = _TOKEN_ORIGIN;
pub type PTOKEN_ORIGIN = *mut _TOKEN_ORIGIN;
pub const _MANDATORY_LEVEL_MandatoryLevelUntrusted: _MANDATORY_LEVEL = 0;
pub const _MANDATORY_LEVEL_MandatoryLevelLow: _MANDATORY_LEVEL = 1;
pub const _MANDATORY_LEVEL_MandatoryLevelMedium: _MANDATORY_LEVEL = 2;
pub const _MANDATORY_LEVEL_MandatoryLevelHigh: _MANDATORY_LEVEL = 3;
pub const _MANDATORY_LEVEL_MandatoryLevelSystem: _MANDATORY_LEVEL = 4;
pub const _MANDATORY_LEVEL_MandatoryLevelSecureProcess: _MANDATORY_LEVEL = 5;
pub const _MANDATORY_LEVEL_MandatoryLevelCount: _MANDATORY_LEVEL = 6;
pub type _MANDATORY_LEVEL = i32;
pub use self::_MANDATORY_LEVEL as MANDATORY_LEVEL;
pub type PMANDATORY_LEVEL = *mut _MANDATORY_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_APPCONTAINER_INFORMATION {
    pub TokenAppContainer: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_APPCONTAINER_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_APPCONTAINER_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_APPCONTAINER_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_APPCONTAINER_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_APPCONTAINER_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_APPCONTAINER_INFORMATION>())).TokenAppContainer
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_APPCONTAINER_INFORMATION),
            "::",
            stringify!(TokenAppContainer)
        )
    );
}
pub type TOKEN_APPCONTAINER_INFORMATION = _TOKEN_APPCONTAINER_INFORMATION;
pub type PTOKEN_APPCONTAINER_INFORMATION = *mut _TOKEN_APPCONTAINER_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_SID_INFORMATION {
    pub Sid: PSID,
}
#[test]
fn bindgen_test_layout__TOKEN_SID_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_SID_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_TOKEN_SID_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_SID_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TOKEN_SID_INFORMATION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TOKEN_SID_INFORMATION>())).Sid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_SID_INFORMATION),
            "::",
            stringify!(Sid)
        )
    );
}
pub type TOKEN_SID_INFORMATION = _TOKEN_SID_INFORMATION;
pub type PTOKEN_SID_INFORMATION = *mut _TOKEN_SID_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TOKEN_BNO_ISOLATION_INFORMATION {
    pub IsolationPrefix: PWSTR,
    pub IsolationEnabled: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TOKEN_BNO_ISOLATION_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TOKEN_BNO_ISOLATION_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TOKEN_BNO_ISOLATION_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TOKEN_BNO_ISOLATION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TOKEN_BNO_ISOLATION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_BNO_ISOLATION_INFORMATION>())).IsolationPrefix as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_BNO_ISOLATION_INFORMATION),
            "::",
            stringify!(IsolationPrefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TOKEN_BNO_ISOLATION_INFORMATION>())).IsolationEnabled
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TOKEN_BNO_ISOLATION_INFORMATION),
            "::",
            stringify!(IsolationEnabled)
        )
    );
}
pub type TOKEN_BNO_ISOLATION_INFORMATION = _TOKEN_BNO_ISOLATION_INFORMATION;
pub type PTOKEN_BNO_ISOLATION_INFORMATION = *mut _TOKEN_BNO_ISOLATION_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    pub Version: DWORD64,
    pub Name: PWSTR,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>())).Version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE>())).Name as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE),
            "::",
            stringify!(Name)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = *mut _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    pub pValue: PVOID,
    pub ValueLength: DWORD,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>())).pValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
            "::",
            stringify!(pValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE>())).ValueLength
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE),
            "::",
            stringify!(ValueLength)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
pub type PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE =
    *mut _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_V1 {
    pub Name: PWSTR,
    pub ValueType: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ValueCount: DWORD,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1 {
    pub pInt64: PLONG64,
    pub pUint64: PDWORD64,
    pub ppString: *mut PWSTR,
    pub pFqbn: PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
    pub pOctetString: PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pInt64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pInt64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pUint64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pUint64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).ppString
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(ppString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pFqbn as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pFqbn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1>())).pOctetString
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1__bindgen_ty_1),
            "::",
            stringify!(pOctetString)
        )
    );
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_V1() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_V1>(),
        32usize,
        concat!("Size of: ", stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1))
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_V1>(),
        8usize,
        concat!("Alignment of ", stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).ValueType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Reserved as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Flags as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).ValueCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(ValueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_V1>())).Values as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_V1),
            "::",
            stringify!(Values)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_V1 = _CLAIM_SECURITY_ATTRIBUTE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {
    pub Name: DWORD,
    pub ValueType: WORD,
    pub Reserved: WORD,
    pub Flags: DWORD,
    pub ValueCount: DWORD,
    pub Values: _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1 {
    pub pInt64: [DWORD; 1usize],
    pub pUint64: [DWORD; 1usize],
    pub ppString: [DWORD; 1usize],
    pub pFqbn: [DWORD; 1usize],
    pub pOctetString: [DWORD; 1usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pInt64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pInt64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pUint64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pUint64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).ppString
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(ppString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>())).pFqbn
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pFqbn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1>()))
                .pOctetString as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1__bindgen_ty_1),
            "::",
            stringify!(pOctetString)
        )
    );
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Name as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).ValueType as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(ValueType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Reserved as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Flags as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).ValueCount as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(ValueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1>())).Values as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1),
            "::",
            stringify!(Values)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
pub type PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = *mut _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {
    pub Version: WORD,
    pub Reserved: WORD,
    pub AttributeCount: DWORD,
    pub Attribute: _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1 {
    pub pAttributeV1: PCLAIM_SECURITY_ATTRIBUTE_V1,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1>()))
                .pAttributeV1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(pAttributeV1)
        )
    );
}
#[test]
fn bindgen_test_layout__CLAIM_SECURITY_ATTRIBUTES_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).Version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).Reserved as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).AttributeCount
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(AttributeCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CLAIM_SECURITY_ATTRIBUTES_INFORMATION>())).Attribute as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CLAIM_SECURITY_ATTRIBUTES_INFORMATION),
            "::",
            stringify!(Attribute)
        )
    );
}
pub type CLAIM_SECURITY_ATTRIBUTES_INFORMATION = _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type PCLAIM_SECURITY_ATTRIBUTES_INFORMATION = *mut _CLAIM_SECURITY_ATTRIBUTES_INFORMATION;
pub type SECURITY_CONTEXT_TRACKING_MODE = BOOLEAN;
pub type PSECURITY_CONTEXT_TRACKING_MODE = *mut BOOLEAN;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_QUALITY_OF_SERVICE {
    pub Length: DWORD,
    pub ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    pub ContextTrackingMode: SECURITY_CONTEXT_TRACKING_MODE,
    pub EffectiveOnly: BOOLEAN,
}
#[test]
fn bindgen_test_layout__SECURITY_QUALITY_OF_SERVICE() {
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        12usize,
        concat!("Size of: ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_QUALITY_OF_SERVICE>(),
        4usize,
        concat!("Alignment of ", stringify!(_SECURITY_QUALITY_OF_SERVICE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ImpersonationLevel as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ImpersonationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).ContextTrackingMode as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(ContextTrackingMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_QUALITY_OF_SERVICE>())).EffectiveOnly as *const _
                as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_QUALITY_OF_SERVICE),
            "::",
            stringify!(EffectiveOnly)
        )
    );
}
pub type SECURITY_QUALITY_OF_SERVICE = _SECURITY_QUALITY_OF_SERVICE;
pub type PSECURITY_QUALITY_OF_SERVICE = *mut _SECURITY_QUALITY_OF_SERVICE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SE_IMPERSONATION_STATE {
    pub Token: PACCESS_TOKEN,
    pub CopyOnOpen: BOOLEAN,
    pub EffectiveOnly: BOOLEAN,
    pub Level: SECURITY_IMPERSONATION_LEVEL,
}
#[test]
fn bindgen_test_layout__SE_IMPERSONATION_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_SE_IMPERSONATION_STATE>(),
        16usize,
        concat!("Size of: ", stringify!(_SE_IMPERSONATION_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_SE_IMPERSONATION_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(_SE_IMPERSONATION_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).Token as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(Token)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).CopyOnOpen as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(CopyOnOpen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).EffectiveOnly as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(EffectiveOnly)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SE_IMPERSONATION_STATE>())).Level as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SE_IMPERSONATION_STATE),
            "::",
            stringify!(Level)
        )
    );
}
pub type SE_IMPERSONATION_STATE = _SE_IMPERSONATION_STATE;
pub type PSE_IMPERSONATION_STATE = *mut _SE_IMPERSONATION_STATE;
pub type SECURITY_INFORMATION = DWORD;
pub type PSECURITY_INFORMATION = *mut DWORD;
pub type SE_SIGNING_LEVEL = BYTE;
pub type PSE_SIGNING_LEVEL = *mut BYTE;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureNone: _SE_IMAGE_SIGNATURE_TYPE = 0;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureEmbedded: _SE_IMAGE_SIGNATURE_TYPE = 1;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCache: _SE_IMAGE_SIGNATURE_TYPE = 2;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogCached: _SE_IMAGE_SIGNATURE_TYPE = 3;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogNotCached: _SE_IMAGE_SIGNATURE_TYPE = 4;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignatureCatalogHint: _SE_IMAGE_SIGNATURE_TYPE = 5;
pub const _SE_IMAGE_SIGNATURE_TYPE_SeImageSignaturePackageCatalog: _SE_IMAGE_SIGNATURE_TYPE = 6;
pub type _SE_IMAGE_SIGNATURE_TYPE = i32;
pub use self::_SE_IMAGE_SIGNATURE_TYPE as SE_IMAGE_SIGNATURE_TYPE;
pub type PSE_IMAGE_SIGNATURE_TYPE = *mut _SE_IMAGE_SIGNATURE_TYPE;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeInvalidType: _SE_LEARNING_MODE_DATA_TYPE = 0;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeSettings: _SE_LEARNING_MODE_DATA_TYPE = 1;
pub const _SE_LEARNING_MODE_DATA_TYPE_SeLearningModeMax: _SE_LEARNING_MODE_DATA_TYPE = 2;
pub type _SE_LEARNING_MODE_DATA_TYPE = i32;
pub use self::_SE_LEARNING_MODE_DATA_TYPE as SE_LEARNING_MODE_DATA_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SECURITY_CAPABILITIES {
    pub AppContainerSid: PSID,
    pub Capabilities: PSID_AND_ATTRIBUTES,
    pub CapabilityCount: DWORD,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__SECURITY_CAPABILITIES() {
    assert_eq!(
        ::std::mem::size_of::<_SECURITY_CAPABILITIES>(),
        24usize,
        concat!("Size of: ", stringify!(_SECURITY_CAPABILITIES))
    );
    assert_eq!(
        ::std::mem::align_of::<_SECURITY_CAPABILITIES>(),
        8usize,
        concat!("Alignment of ", stringify!(_SECURITY_CAPABILITIES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).AppContainerSid as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(AppContainerSid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).Capabilities as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(Capabilities)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).CapabilityCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(CapabilityCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SECURITY_CAPABILITIES>())).Reserved as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_SECURITY_CAPABILITIES),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type SECURITY_CAPABILITIES = _SECURITY_CAPABILITIES;
pub type PSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
pub type LPSECURITY_CAPABILITIES = *mut _SECURITY_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOB_SET_ARRAY {
    pub JobHandle: HANDLE,
    pub MemberLevel: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__JOB_SET_ARRAY() {
    assert_eq!(
        ::std::mem::size_of::<_JOB_SET_ARRAY>(),
        16usize,
        concat!("Size of: ", stringify!(_JOB_SET_ARRAY))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOB_SET_ARRAY>(),
        8usize,
        concat!("Alignment of ", stringify!(_JOB_SET_ARRAY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JOB_SET_ARRAY>())).JobHandle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOB_SET_ARRAY),
            "::",
            stringify!(JobHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JOB_SET_ARRAY>())).MemberLevel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOB_SET_ARRAY),
            "::",
            stringify!(MemberLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_JOB_SET_ARRAY>())).Flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOB_SET_ARRAY),
            "::",
            stringify!(Flags)
        )
    );
}
pub type JOB_SET_ARRAY = _JOB_SET_ARRAY;
pub type PJOB_SET_ARRAY = *mut _JOB_SET_ARRAY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EXCEPTION_REGISTRATION_RECORD {
    pub Next: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub Handler: PEXCEPTION_ROUTINE,
}
#[test]
fn bindgen_test_layout__EXCEPTION_REGISTRATION_RECORD() {
    assert_eq!(
        ::std::mem::size_of::<_EXCEPTION_REGISTRATION_RECORD>(),
        16usize,
        concat!("Size of: ", stringify!(_EXCEPTION_REGISTRATION_RECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_EXCEPTION_REGISTRATION_RECORD>(),
        8usize,
        concat!("Alignment of ", stringify!(_EXCEPTION_REGISTRATION_RECORD))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_REGISTRATION_RECORD>())).Next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD),
            "::",
            stringify!(Next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EXCEPTION_REGISTRATION_RECORD>())).Handler as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EXCEPTION_REGISTRATION_RECORD),
            "::",
            stringify!(Handler)
        )
    );
}
pub type EXCEPTION_REGISTRATION_RECORD = _EXCEPTION_REGISTRATION_RECORD;
pub type PEXCEPTION_REGISTRATION_RECORD = *mut EXCEPTION_REGISTRATION_RECORD;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB {
    pub ExceptionList: *mut _EXCEPTION_REGISTRATION_RECORD,
    pub StackBase: PVOID,
    pub StackLimit: PVOID,
    pub SubSystemTib: PVOID,
    pub __bindgen_anon_1: _NT_TIB__bindgen_ty_1,
    pub ArbitraryUserPointer: PVOID,
    pub Self_: *mut _NT_TIB,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB__bindgen_ty_1 {
    pub FiberData: PVOID,
    pub Version: DWORD,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__NT_TIB__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NT_TIB__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB__bindgen_ty_1>())).FiberData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB__bindgen_ty_1),
            "::",
            stringify!(FiberData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB__bindgen_ty_1>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB__bindgen_ty_1),
            "::",
            stringify!(Version)
        )
    );
}
#[test]
fn bindgen_test_layout__NT_TIB() {
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB>(),
        56usize,
        concat!("Size of: ", stringify!(_NT_TIB))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB>())).ExceptionList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(ExceptionList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB>())).StackBase as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB>())).StackLimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB>())).SubSystemTib as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(SubSystemTib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB>())).ArbitraryUserPointer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(ArbitraryUserPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB>())).Self_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB),
            "::",
            stringify!(Self_)
        )
    );
}
pub type NT_TIB = _NT_TIB;
pub type PNT_TIB = *mut NT_TIB;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB32 {
    pub ExceptionList: DWORD,
    pub StackBase: DWORD,
    pub StackLimit: DWORD,
    pub SubSystemTib: DWORD,
    pub __bindgen_anon_1: _NT_TIB32__bindgen_ty_1,
    pub ArbitraryUserPointer: DWORD,
    pub Self_: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB32__bindgen_ty_1 {
    pub FiberData: DWORD,
    pub Version: DWORD,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__NT_TIB32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB32__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_NT_TIB32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB32__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_NT_TIB32__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NT_TIB32__bindgen_ty_1>())).FiberData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32__bindgen_ty_1),
            "::",
            stringify!(FiberData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32__bindgen_ty_1>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32__bindgen_ty_1),
            "::",
            stringify!(Version)
        )
    );
}
#[test]
fn bindgen_test_layout__NT_TIB32() {
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB32>(),
        28usize,
        concat!("Size of: ", stringify!(_NT_TIB32))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB32>(),
        4usize,
        concat!("Alignment of ", stringify!(_NT_TIB32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32>())).ExceptionList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(ExceptionList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32>())).StackBase as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32>())).StackLimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32>())).SubSystemTib as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(SubSystemTib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32>())).ArbitraryUserPointer as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(ArbitraryUserPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB32>())).Self_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB32),
            "::",
            stringify!(Self_)
        )
    );
}
pub type NT_TIB32 = _NT_TIB32;
pub type PNT_TIB32 = *mut _NT_TIB32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _NT_TIB64 {
    pub ExceptionList: DWORD64,
    pub StackBase: DWORD64,
    pub StackLimit: DWORD64,
    pub SubSystemTib: DWORD64,
    pub __bindgen_anon_1: _NT_TIB64__bindgen_ty_1,
    pub ArbitraryUserPointer: DWORD64,
    pub Self_: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _NT_TIB64__bindgen_ty_1 {
    pub FiberData: DWORD64,
    pub Version: DWORD,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__NT_TIB64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB64__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_NT_TIB64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB64__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB64__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NT_TIB64__bindgen_ty_1>())).FiberData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64__bindgen_ty_1),
            "::",
            stringify!(FiberData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64__bindgen_ty_1>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64__bindgen_ty_1),
            "::",
            stringify!(Version)
        )
    );
}
#[test]
fn bindgen_test_layout__NT_TIB64() {
    assert_eq!(
        ::std::mem::size_of::<_NT_TIB64>(),
        56usize,
        concat!("Size of: ", stringify!(_NT_TIB64))
    );
    assert_eq!(
        ::std::mem::align_of::<_NT_TIB64>(),
        8usize,
        concat!("Alignment of ", stringify!(_NT_TIB64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64>())).ExceptionList as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(ExceptionList)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64>())).StackBase as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(StackBase)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64>())).StackLimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(StackLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64>())).SubSystemTib as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(SubSystemTib)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64>())).ArbitraryUserPointer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(ArbitraryUserPointer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NT_TIB64>())).Self_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_NT_TIB64),
            "::",
            stringify!(Self_)
        )
    );
}
pub type NT_TIB64 = _NT_TIB64;
pub type PNT_TIB64 = *mut _NT_TIB64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _UMS_CREATE_THREAD_ATTRIBUTES {
    pub UmsVersion: DWORD,
    pub UmsContext: PVOID,
    pub UmsCompletionList: PVOID,
}
#[test]
fn bindgen_test_layout__UMS_CREATE_THREAD_ATTRIBUTES() {
    assert_eq!(
        ::std::mem::size_of::<_UMS_CREATE_THREAD_ATTRIBUTES>(),
        24usize,
        concat!("Size of: ", stringify!(_UMS_CREATE_THREAD_ATTRIBUTES))
    );
    assert_eq!(
        ::std::mem::align_of::<_UMS_CREATE_THREAD_ATTRIBUTES>(),
        8usize,
        concat!("Alignment of ", stringify!(_UMS_CREATE_THREAD_ATTRIBUTES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UMS_CREATE_THREAD_ATTRIBUTES>())).UmsVersion as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
            "::",
            stringify!(UmsVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UMS_CREATE_THREAD_ATTRIBUTES>())).UmsContext as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
            "::",
            stringify!(UmsContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_UMS_CREATE_THREAD_ATTRIBUTES>())).UmsCompletionList as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_UMS_CREATE_THREAD_ATTRIBUTES),
            "::",
            stringify!(UmsCompletionList)
        )
    );
}
pub type UMS_CREATE_THREAD_ATTRIBUTES = _UMS_CREATE_THREAD_ATTRIBUTES;
pub type PUMS_CREATE_THREAD_ATTRIBUTES = *mut _UMS_CREATE_THREAD_ATTRIBUTES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WOW64_ARCHITECTURE_INFORMATION {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__WOW64_ARCHITECTURE_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_WOW64_ARCHITECTURE_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_WOW64_ARCHITECTURE_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_WOW64_ARCHITECTURE_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_WOW64_ARCHITECTURE_INFORMATION))
    );
}
impl _WOW64_ARCHITECTURE_INFORMATION {
    #[inline]
    pub fn Machine(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Machine(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn KernelMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_KernelMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn UserMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_UserMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Native(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Native(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Process(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Process(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedZero0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedZero0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Machine: DWORD,
        KernelMode: DWORD,
        UserMode: DWORD,
        Native: DWORD,
        Process: DWORD,
        ReservedZero0: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Machine: u32 = unsafe { ::std::mem::transmute(Machine) };
            Machine as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let KernelMode: u32 = unsafe { ::std::mem::transmute(KernelMode) };
            KernelMode as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let UserMode: u32 = unsafe { ::std::mem::transmute(UserMode) };
            UserMode as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Native: u32 = unsafe { ::std::mem::transmute(Native) };
            Native as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Process: u32 = unsafe { ::std::mem::transmute(Process) };
            Process as u64
        });
        __bindgen_bitfield_unit.set(20usize, 12u8, {
            let ReservedZero0: u32 = unsafe { ::std::mem::transmute(ReservedZero0) };
            ReservedZero0 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type WOW64_ARCHITECTURE_INFORMATION = _WOW64_ARCHITECTURE_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS() {
    assert_eq!(
        ::std::mem::size_of::<_QUOTA_LIMITS>(),
        48usize,
        concat!("Size of: ", stringify!(_QUOTA_LIMITS))
    );
    assert_eq!(
        ::std::mem::align_of::<_QUOTA_LIMITS>(),
        8usize,
        concat!("Alignment of ", stringify!(_QUOTA_LIMITS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS>())).PagedPoolLimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(PagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS>())).NonPagedPoolLimit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(NonPagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_QUOTA_LIMITS>())).MinimumWorkingSetSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(MinimumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_QUOTA_LIMITS>())).MaximumWorkingSetSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(MaximumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS>())).PagefileLimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(PagefileLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS>())).TimeLimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS),
            "::",
            stringify!(TimeLimit)
        )
    );
}
pub type QUOTA_LIMITS = _QUOTA_LIMITS;
pub type PQUOTA_LIMITS = *mut _QUOTA_LIMITS;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RATE_QUOTA_LIMIT {
    pub RateData: DWORD,
    pub __bindgen_anon_1: _RATE_QUOTA_LIMIT__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_RATE_QUOTA_LIMIT__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_RATE_QUOTA_LIMIT__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_RATE_QUOTA_LIMIT__bindgen_ty_1))
    );
}
impl _RATE_QUOTA_LIMIT__bindgen_ty_1 {
    #[inline]
    pub fn RatePercent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_RatePercent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 25u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 25u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RatePercent: DWORD,
        Reserved0: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let RatePercent: u32 = unsafe { ::std::mem::transmute(RatePercent) };
            RatePercent as u64
        });
        __bindgen_bitfield_unit.set(7usize, 25u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__RATE_QUOTA_LIMIT() {
    assert_eq!(
        ::std::mem::size_of::<_RATE_QUOTA_LIMIT>(),
        4usize,
        concat!("Size of: ", stringify!(_RATE_QUOTA_LIMIT))
    );
    assert_eq!(
        ::std::mem::align_of::<_RATE_QUOTA_LIMIT>(),
        4usize,
        concat!("Alignment of ", stringify!(_RATE_QUOTA_LIMIT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RATE_QUOTA_LIMIT>())).RateData as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RATE_QUOTA_LIMIT),
            "::",
            stringify!(RateData)
        )
    );
}
pub type RATE_QUOTA_LIMIT = _RATE_QUOTA_LIMIT;
pub type PRATE_QUOTA_LIMIT = *mut _RATE_QUOTA_LIMIT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _QUOTA_LIMITS_EX {
    pub PagedPoolLimit: SIZE_T,
    pub NonPagedPoolLimit: SIZE_T,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub PagefileLimit: SIZE_T,
    pub TimeLimit: LARGE_INTEGER,
    pub WorkingSetLimit: SIZE_T,
    pub Reserved2: SIZE_T,
    pub Reserved3: SIZE_T,
    pub Reserved4: SIZE_T,
    pub Flags: DWORD,
    pub CpuRateLimit: RATE_QUOTA_LIMIT,
}
#[test]
fn bindgen_test_layout__QUOTA_LIMITS_EX() {
    assert_eq!(
        ::std::mem::size_of::<_QUOTA_LIMITS_EX>(),
        88usize,
        concat!("Size of: ", stringify!(_QUOTA_LIMITS_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<_QUOTA_LIMITS_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(_QUOTA_LIMITS_EX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).PagedPoolLimit as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(PagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).NonPagedPoolLimit as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(NonPagedPoolLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).MinimumWorkingSetSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(MinimumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).MaximumWorkingSetSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(MaximumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).PagefileLimit as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(PagefileLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).TimeLimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(TimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).WorkingSetLimit as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(WorkingSetLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).Reserved2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).Reserved3 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).Reserved4 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).Flags as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_QUOTA_LIMITS_EX>())).CpuRateLimit as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_QUOTA_LIMITS_EX),
            "::",
            stringify!(CpuRateLimit)
        )
    );
}
pub type QUOTA_LIMITS_EX = _QUOTA_LIMITS_EX;
pub type PQUOTA_LIMITS_EX = *mut _QUOTA_LIMITS_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_COUNTERS {
    pub ReadOperationCount: ULONGLONG,
    pub WriteOperationCount: ULONGLONG,
    pub OtherOperationCount: ULONGLONG,
    pub ReadTransferCount: ULONGLONG,
    pub WriteTransferCount: ULONGLONG,
    pub OtherTransferCount: ULONGLONG,
}
#[test]
fn bindgen_test_layout__IO_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<_IO_COUNTERS>(),
        48usize,
        concat!("Size of: ", stringify!(_IO_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_COUNTERS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_COUNTERS>())).ReadOperationCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(ReadOperationCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IO_COUNTERS>())).WriteOperationCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(WriteOperationCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IO_COUNTERS>())).OtherOperationCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(OtherOperationCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_COUNTERS>())).ReadTransferCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(ReadTransferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_COUNTERS>())).WriteTransferCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(WriteTransferCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_COUNTERS>())).OtherTransferCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_COUNTERS),
            "::",
            stringify!(OtherTransferCount)
        )
    );
}
pub type IO_COUNTERS = _IO_COUNTERS;
pub type PIO_COUNTERS = *mut IO_COUNTERS;
pub const _HARDWARE_COUNTER_TYPE_PMCCounter: _HARDWARE_COUNTER_TYPE = 0;
pub const _HARDWARE_COUNTER_TYPE_MaxHardwareCounterType: _HARDWARE_COUNTER_TYPE = 1;
pub type _HARDWARE_COUNTER_TYPE = i32;
pub use self::_HARDWARE_COUNTER_TYPE as HARDWARE_COUNTER_TYPE;
pub type PHARDWARE_COUNTER_TYPE = *mut _HARDWARE_COUNTER_TYPE;
pub const _PROCESS_MITIGATION_POLICY_ProcessDEPPolicy: _PROCESS_MITIGATION_POLICY = 0;
pub const _PROCESS_MITIGATION_POLICY_ProcessASLRPolicy: _PROCESS_MITIGATION_POLICY = 1;
pub const _PROCESS_MITIGATION_POLICY_ProcessDynamicCodePolicy: _PROCESS_MITIGATION_POLICY = 2;
pub const _PROCESS_MITIGATION_POLICY_ProcessStrictHandleCheckPolicy: _PROCESS_MITIGATION_POLICY = 3;
pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallDisablePolicy: _PROCESS_MITIGATION_POLICY = 4;
pub const _PROCESS_MITIGATION_POLICY_ProcessMitigationOptionsMask: _PROCESS_MITIGATION_POLICY = 5;
pub const _PROCESS_MITIGATION_POLICY_ProcessExtensionPointDisablePolicy:
    _PROCESS_MITIGATION_POLICY = 6;
pub const _PROCESS_MITIGATION_POLICY_ProcessControlFlowGuardPolicy: _PROCESS_MITIGATION_POLICY = 7;
pub const _PROCESS_MITIGATION_POLICY_ProcessSignaturePolicy: _PROCESS_MITIGATION_POLICY = 8;
pub const _PROCESS_MITIGATION_POLICY_ProcessFontDisablePolicy: _PROCESS_MITIGATION_POLICY = 9;
pub const _PROCESS_MITIGATION_POLICY_ProcessImageLoadPolicy: _PROCESS_MITIGATION_POLICY = 10;
pub const _PROCESS_MITIGATION_POLICY_ProcessSystemCallFilterPolicy: _PROCESS_MITIGATION_POLICY = 11;
pub const _PROCESS_MITIGATION_POLICY_ProcessPayloadRestrictionPolicy: _PROCESS_MITIGATION_POLICY =
    12;
pub const _PROCESS_MITIGATION_POLICY_ProcessChildProcessPolicy: _PROCESS_MITIGATION_POLICY = 13;
pub const _PROCESS_MITIGATION_POLICY_ProcessSideChannelIsolationPolicy: _PROCESS_MITIGATION_POLICY =
    14;
pub const _PROCESS_MITIGATION_POLICY_MaxProcessMitigationPolicy: _PROCESS_MITIGATION_POLICY = 15;
pub type _PROCESS_MITIGATION_POLICY = i32;
pub use self::_PROCESS_MITIGATION_POLICY as PROCESS_MITIGATION_POLICY;
pub type PPROCESS_MITIGATION_POLICY = *mut _PROCESS_MITIGATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableBottomUpRandomization(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableBottomUpRandomization(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableForceRelocateImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableForceRelocateImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableHighEntropy(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableHighEntropy(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisallowStrippedImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowStrippedImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableBottomUpRandomization: DWORD,
        EnableForceRelocateImages: DWORD,
        EnableHighEntropy: DWORD,
        DisallowStrippedImages: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableBottomUpRandomization: u32 =
                unsafe { ::std::mem::transmute(EnableBottomUpRandomization) };
            EnableBottomUpRandomization as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableForceRelocateImages: u32 =
                unsafe { ::std::mem::transmute(EnableForceRelocateImages) };
            EnableForceRelocateImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableHighEntropy: u32 = unsafe { ::std::mem::transmute(EnableHighEntropy) };
            EnableHighEntropy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DisallowStrippedImages: u32 =
                unsafe { ::std::mem::transmute(DisallowStrippedImages) };
            DisallowStrippedImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1>())).Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_ASLR_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_ASLR_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_ASLR_POLICY>(),
        4usize,
        concat!("Size of: ", stringify!(_PROCESS_MITIGATION_ASLR_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_ASLR_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESS_MITIGATION_ASLR_POLICY))
    );
}
pub type PROCESS_MITIGATION_ASLR_POLICY = _PROCESS_MITIGATION_ASLR_POLICY;
pub type PPROCESS_MITIGATION_ASLR_POLICY = *mut _PROCESS_MITIGATION_ASLR_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1,
    pub Permanent: BOOLEAN,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Enable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Enable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisableAtlThunkEmulation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableAtlThunkEmulation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Enable: DWORD,
        DisableAtlThunkEmulation: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Enable: u32 = unsafe { ::std::mem::transmute(Enable) };
            Enable as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let DisableAtlThunkEmulation: u32 =
                unsafe { ::std::mem::transmute(DisableAtlThunkEmulation) };
            DisableAtlThunkEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1>())).Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DEP_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DEP_POLICY>(),
        8usize,
        concat!("Size of: ", stringify!(_PROCESS_MITIGATION_DEP_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DEP_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESS_MITIGATION_DEP_POLICY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_DEP_POLICY>())).Permanent as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_DEP_POLICY),
            "::",
            stringify!(Permanent)
        )
    );
}
pub type PROCESS_MITIGATION_DEP_POLICY = _PROCESS_MITIGATION_DEP_POLICY;
pub type PPROCESS_MITIGATION_DEP_POLICY = *mut _PROCESS_MITIGATION_DEP_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RaiseExceptionOnInvalidHandleReference(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RaiseExceptionOnInvalidHandleReference(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HandleExceptionsPermanentlyEnabled(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_HandleExceptionsPermanentlyEnabled(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RaiseExceptionOnInvalidHandleReference: DWORD,
        HandleExceptionsPermanentlyEnabled: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RaiseExceptionOnInvalidHandleReference: u32 =
                unsafe { ::std::mem::transmute(RaiseExceptionOnInvalidHandleReference) };
            RaiseExceptionOnInvalidHandleReference as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let HandleExceptionsPermanentlyEnabled: u32 =
                unsafe { ::std::mem::transmute(HandleExceptionsPermanentlyEnabled) };
            HandleExceptionsPermanentlyEnabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1>()))
                .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
pub type PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY =
    *mut _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisallowWin32kSystemCalls(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisallowWin32kSystemCalls(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditDisallowWin32kSystemCalls(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditDisallowWin32kSystemCalls(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisallowWin32kSystemCalls: DWORD,
        AuditDisallowWin32kSystemCalls: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(DisallowWin32kSystemCalls) };
            DisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditDisallowWin32kSystemCalls: u32 =
                unsafe { ::std::mem::transmute(AuditDisallowWin32kSystemCalls) };
            AuditDisallowWin32kSystemCalls as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1>()))
                .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableExtensionPoints(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableExtensionPoints(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableExtensionPoints: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableExtensionPoints: u32 =
                unsafe { ::std::mem::transmute(DisableExtensionPoints) };
            DisableExtensionPoints as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            & ( * ( :: std :: ptr :: null :: < _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1 > ( ) ) ) . Flags as * const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY =
    *mut _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn ProhibitDynamicCode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ProhibitDynamicCode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowThreadOptOut(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowThreadOptOut(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowRemoteDowngrade(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowRemoteDowngrade(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditProhibitDynamicCode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditProhibitDynamicCode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ProhibitDynamicCode: DWORD,
        AllowThreadOptOut: DWORD,
        AllowRemoteDowngrade: DWORD,
        AuditProhibitDynamicCode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ProhibitDynamicCode: u32 = unsafe { ::std::mem::transmute(ProhibitDynamicCode) };
            ProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowThreadOptOut: u32 = unsafe { ::std::mem::transmute(AllowThreadOptOut) };
            AllowThreadOptOut as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowRemoteDowngrade: u32 = unsafe { ::std::mem::transmute(AllowRemoteDowngrade) };
            AllowRemoteDowngrade as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditProhibitDynamicCode: u32 =
                unsafe { ::std::mem::transmute(AuditProhibitDynamicCode) };
            AuditProhibitDynamicCode as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1>())).Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_DYNAMIC_CODE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_DYNAMIC_CODE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_DYNAMIC_CODE_POLICY = _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
pub type PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY = *mut _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableControlFlowGuard(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableControlFlowGuard(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportSuppression(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportSuppression(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StrictMode(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StrictMode(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableControlFlowGuard: DWORD,
        EnableExportSuppression: DWORD,
        StrictMode: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableControlFlowGuard: u32 =
                unsafe { ::std::mem::transmute(EnableControlFlowGuard) };
            EnableControlFlowGuard as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let EnableExportSuppression: u32 =
                unsafe { ::std::mem::transmute(EnableExportSuppression) };
            EnableExportSuppression as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let StrictMode: u32 = unsafe { ::std::mem::transmute(StrictMode) };
            StrictMode as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1>()))
                .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
pub type PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY =
    *mut _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn MicrosoftSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MicrosoftSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StoreSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StoreSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MitigationOptIn(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_MitigationOptIn(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditMicrosoftSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditMicrosoftSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditStoreSignedOnly(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditStoreSignedOnly(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        MicrosoftSignedOnly: DWORD,
        StoreSignedOnly: DWORD,
        MitigationOptIn: DWORD,
        AuditMicrosoftSignedOnly: DWORD,
        AuditStoreSignedOnly: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let MicrosoftSignedOnly: u32 = unsafe { ::std::mem::transmute(MicrosoftSignedOnly) };
            MicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let StoreSignedOnly: u32 = unsafe { ::std::mem::transmute(StoreSignedOnly) };
            StoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let MitigationOptIn: u32 = unsafe { ::std::mem::transmute(MitigationOptIn) };
            MitigationOptIn as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditMicrosoftSignedOnly: u32 =
                unsafe { ::std::mem::transmute(AuditMicrosoftSignedOnly) };
            AuditMicrosoftSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuditStoreSignedOnly: u32 = unsafe { ::std::mem::transmute(AuditStoreSignedOnly) };
            AuditStoreSignedOnly as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1>()))
                .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY = _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
pub type PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY =
    *mut _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn DisableNonSystemFonts(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableNonSystemFonts(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNonSystemFontLoading(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNonSystemFontLoading(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableNonSystemFonts: DWORD,
        AuditNonSystemFontLoading: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableNonSystemFonts: u32 =
                unsafe { ::std::mem::transmute(DisableNonSystemFonts) };
            DisableNonSystemFonts as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNonSystemFontLoading: u32 =
                unsafe { ::std::mem::transmute(AuditNonSystemFontLoading) };
            AuditNonSystemFontLoading as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1>())).Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_FONT_DISABLE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_FONT_DISABLE_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_FONT_DISABLE_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_FONT_DISABLE_POLICY = _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
pub type PPROCESS_MITIGATION_FONT_DISABLE_POLICY = *mut _PROCESS_MITIGATION_FONT_DISABLE_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoRemoteImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoRemoteImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NoLowMandatoryLabelImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoLowMandatoryLabelImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PreferSystem32Images(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_PreferSystem32Images(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoRemoteImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoRemoteImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoLowMandatoryLabelImages(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoLowMandatoryLabelImages(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 27u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 27u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoRemoteImages: DWORD,
        NoLowMandatoryLabelImages: DWORD,
        PreferSystem32Images: DWORD,
        AuditNoRemoteImages: DWORD,
        AuditNoLowMandatoryLabelImages: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoRemoteImages: u32 = unsafe { ::std::mem::transmute(NoRemoteImages) };
            NoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NoLowMandatoryLabelImages: u32 =
                unsafe { ::std::mem::transmute(NoLowMandatoryLabelImages) };
            NoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let PreferSystem32Images: u32 = unsafe { ::std::mem::transmute(PreferSystem32Images) };
            PreferSystem32Images as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditNoRemoteImages: u32 = unsafe { ::std::mem::transmute(AuditNoRemoteImages) };
            AuditNoRemoteImages as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let AuditNoLowMandatoryLabelImages: u32 =
                unsafe { ::std::mem::transmute(AuditNoLowMandatoryLabelImages) };
            AuditNoLowMandatoryLabelImages as u64
        });
        __bindgen_bitfield_unit.set(5usize, 27u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1>())).Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_IMAGE_LOAD_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_IMAGE_LOAD_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_IMAGE_LOAD_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_IMAGE_LOAD_POLICY = _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
pub type PPROCESS_MITIGATION_IMAGE_LOAD_POLICY = *mut _PROCESS_MITIGATION_IMAGE_LOAD_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn FilterId(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_FilterId(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        FilterId: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let FilterId: u32 = unsafe { ::std::mem::transmute(FilterId) };
            FilterId as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1>()))
                .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
    _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
pub type PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY =
    *mut _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1()
{
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn EnableExportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableExportAddressFilterPlus(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableExportAddressFilterPlus(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditExportAddressFilterPlus(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditExportAddressFilterPlus(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableImportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableImportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditImportAddressFilter(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditImportAddressFilter(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopStackPivot(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopStackPivot(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopStackPivot(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopStackPivot(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopCallerCheck(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopCallerCheck(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopCallerCheck(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopCallerCheck(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnableRopSimExec(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EnableRopSimExec(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditRopSimExec(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditRopSimExec(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EnableExportAddressFilter: DWORD,
        AuditExportAddressFilter: DWORD,
        EnableExportAddressFilterPlus: DWORD,
        AuditExportAddressFilterPlus: DWORD,
        EnableImportAddressFilter: DWORD,
        AuditImportAddressFilter: DWORD,
        EnableRopStackPivot: DWORD,
        AuditRopStackPivot: DWORD,
        EnableRopCallerCheck: DWORD,
        AuditRopCallerCheck: DWORD,
        EnableRopSimExec: DWORD,
        AuditRopSimExec: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EnableExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilter) };
            EnableExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditExportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilter) };
            AuditExportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let EnableExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(EnableExportAddressFilterPlus) };
            EnableExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let AuditExportAddressFilterPlus: u32 =
                unsafe { ::std::mem::transmute(AuditExportAddressFilterPlus) };
            AuditExportAddressFilterPlus as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EnableImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(EnableImportAddressFilter) };
            EnableImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let AuditImportAddressFilter: u32 =
                unsafe { ::std::mem::transmute(AuditImportAddressFilter) };
            AuditImportAddressFilter as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let EnableRopStackPivot: u32 = unsafe { ::std::mem::transmute(EnableRopStackPivot) };
            EnableRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let AuditRopStackPivot: u32 = unsafe { ::std::mem::transmute(AuditRopStackPivot) };
            AuditRopStackPivot as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let EnableRopCallerCheck: u32 = unsafe { ::std::mem::transmute(EnableRopCallerCheck) };
            EnableRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let AuditRopCallerCheck: u32 = unsafe { ::std::mem::transmute(AuditRopCallerCheck) };
            AuditRopCallerCheck as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let EnableRopSimExec: u32 = unsafe { ::std::mem::transmute(EnableRopSimExec) };
            EnableRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let AuditRopSimExec: u32 = unsafe { ::std::mem::transmute(AuditRopSimExec) };
            AuditRopSimExec as u64
        });
        __bindgen_bitfield_unit.set(12usize, 20u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1>()))
                .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
    _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
pub type PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY =
    *mut _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1: _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoChildProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NoChildProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AuditNoChildProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AuditNoChildProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowSecureProcessCreation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowSecureProcessCreation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 29u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 29u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoChildProcessCreation: DWORD,
        AuditNoChildProcessCreation: DWORD,
        AllowSecureProcessCreation: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoChildProcessCreation: u32 =
                unsafe { ::std::mem::transmute(NoChildProcessCreation) };
            NoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AuditNoChildProcessCreation: u32 =
                unsafe { ::std::mem::transmute(AuditNoChildProcessCreation) };
            AuditNoChildProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllowSecureProcessCreation: u32 =
                unsafe { ::std::mem::transmute(AllowSecureProcessCreation) };
            AllowSecureProcessCreation as u64
        });
        __bindgen_bitfield_unit.set(3usize, 29u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1>())).Flags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_CHILD_PROCESS_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_CHILD_PROCESS_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_CHILD_PROCESS_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_CHILD_PROCESS_POLICY = _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
pub type PPROCESS_MITIGATION_CHILD_PROCESS_POLICY = *mut _PROCESS_MITIGATION_CHILD_PROCESS_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY {
    pub __bindgen_anon_1: _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1 {
    pub Flags: DWORD,
    pub __bindgen_anon_1:
        _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(
                _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SmtBranchTargetIsolation(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SmtBranchTargetIsolation(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IsolateSecurityDomain(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsolateSecurityDomain(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DisablePageCombine(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisablePageCombine(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpeculativeStoreBypassDisable(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SpeculativeStoreBypassDisable(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SmtBranchTargetIsolation: DWORD,
        IsolateSecurityDomain: DWORD,
        DisablePageCombine: DWORD,
        SpeculativeStoreBypassDisable: DWORD,
        ReservedFlags: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let SmtBranchTargetIsolation: u32 =
                unsafe { ::std::mem::transmute(SmtBranchTargetIsolation) };
            SmtBranchTargetIsolation as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let IsolateSecurityDomain: u32 =
                unsafe { ::std::mem::transmute(IsolateSecurityDomain) };
            IsolateSecurityDomain as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let DisablePageCombine: u32 = unsafe { ::std::mem::transmute(DisablePageCombine) };
            DisablePageCombine as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let SpeculativeStoreBypassDisable: u32 =
                unsafe { ::std::mem::transmute(SpeculativeStoreBypassDisable) };
            SpeculativeStoreBypassDisable as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let ReservedFlags: u32 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1>(
            )))
            .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout__PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY)
        )
    );
}
pub type PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
    _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
pub type PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY =
    *mut _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    pub TotalUserTime: LARGE_INTEGER,
    pub TotalKernelTime: LARGE_INTEGER,
    pub ThisPeriodTotalUserTime: LARGE_INTEGER,
    pub ThisPeriodTotalKernelTime: LARGE_INTEGER,
    pub TotalPageFaultCount: DWORD,
    pub TotalProcesses: DWORD,
    pub ActiveProcesses: DWORD,
    pub TotalTerminatedProcesses: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_ACCOUNTING_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalUserTime
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalUserTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalKernelTime
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalKernelTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>()))
                .ThisPeriodTotalUserTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(ThisPeriodTotalUserTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>()))
                .ThisPeriodTotalKernelTime as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(ThisPeriodTotalKernelTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalPageFaultCount
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalPageFaultCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).TotalProcesses
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalProcesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>())).ActiveProcesses
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(ActiveProcesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION>()))
                .TotalTerminatedProcesses as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_ACCOUNTING_INFORMATION),
            "::",
            stringify!(TotalTerminatedProcesses)
        )
    );
}
pub type JOBOBJECT_BASIC_ACCOUNTING_INFORMATION = _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = *mut _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    pub PerProcessUserTimeLimit: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub LimitFlags: DWORD,
    pub MinimumWorkingSetSize: SIZE_T,
    pub MaximumWorkingSetSize: SIZE_T,
    pub ActiveProcessLimit: DWORD,
    pub Affinity: ULONG_PTR,
    pub PriorityClass: DWORD,
    pub SchedulingClass: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_LIMIT_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>(),
        64usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).PerProcessUserTimeLimit
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(PerProcessUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).PerJobUserTimeLimit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).LimitFlags as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).MinimumWorkingSetSize
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(MinimumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).MaximumWorkingSetSize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(MaximumWorkingSetSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).ActiveProcessLimit
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(ActiveProcessLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).Affinity as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(Affinity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).PriorityClass as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(PriorityClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_LIMIT_INFORMATION>())).SchedulingClass
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_LIMIT_INFORMATION),
            "::",
            stringify!(SchedulingClass)
        )
    );
}
pub type JOBOBJECT_BASIC_LIMIT_INFORMATION = _JOBOBJECT_BASIC_LIMIT_INFORMATION;
pub type PJOBOBJECT_BASIC_LIMIT_INFORMATION = *mut _JOBOBJECT_BASIC_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    pub BasicLimitInformation: JOBOBJECT_BASIC_LIMIT_INFORMATION,
    pub IoInfo: IO_COUNTERS,
    pub ProcessMemoryLimit: SIZE_T,
    pub JobMemoryLimit: SIZE_T,
    pub PeakProcessMemoryUsed: SIZE_T,
    pub PeakJobMemoryUsed: SIZE_T,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_EXTENDED_LIMIT_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).BasicLimitInformation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(BasicLimitInformation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).IoInfo as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(IoInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).ProcessMemoryLimit
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(ProcessMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).JobMemoryLimit
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).PeakProcessMemoryUsed
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(PeakProcessMemoryUsed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_EXTENDED_LIMIT_INFORMATION>())).PeakJobMemoryUsed
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_EXTENDED_LIMIT_INFORMATION),
            "::",
            stringify!(PeakJobMemoryUsed)
        )
    );
}
pub type JOBOBJECT_EXTENDED_LIMIT_INFORMATION = _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
pub type PJOBOBJECT_EXTENDED_LIMIT_INFORMATION = *mut _JOBOBJECT_EXTENDED_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    pub NumberOfAssignedProcesses: DWORD,
    pub NumberOfProcessIdsInList: DWORD,
    pub ProcessIdList: [ULONG_PTR; 1usize],
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_PROCESS_ID_LIST() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>(),
        16usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>())).NumberOfAssignedProcesses
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
            "::",
            stringify!(NumberOfAssignedProcesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>())).NumberOfProcessIdsInList
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
            "::",
            stringify!(NumberOfProcessIdsInList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_PROCESS_ID_LIST>())).ProcessIdList as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_PROCESS_ID_LIST),
            "::",
            stringify!(ProcessIdList)
        )
    );
}
pub type JOBOBJECT_BASIC_PROCESS_ID_LIST = _JOBOBJECT_BASIC_PROCESS_ID_LIST;
pub type PJOBOBJECT_BASIC_PROCESS_ID_LIST = *mut _JOBOBJECT_BASIC_PROCESS_ID_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    pub UIRestrictionsClass: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_UI_RESTRICTIONS() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>(),
        4usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_UI_RESTRICTIONS>())).UIRestrictionsClass
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_UI_RESTRICTIONS),
            "::",
            stringify!(UIRestrictionsClass)
        )
    );
}
pub type JOBOBJECT_BASIC_UI_RESTRICTIONS = _JOBOBJECT_BASIC_UI_RESTRICTIONS;
pub type PJOBOBJECT_BASIC_UI_RESTRICTIONS = *mut _JOBOBJECT_BASIC_UI_RESTRICTIONS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    pub SecurityLimitFlags: DWORD,
    pub JobToken: HANDLE,
    pub SidsToDisable: PTOKEN_GROUPS,
    pub PrivilegesToDelete: PTOKEN_PRIVILEGES,
    pub RestrictedSids: PTOKEN_GROUPS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_SECURITY_LIMIT_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).SecurityLimitFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(SecurityLimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).JobToken as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(JobToken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).SidsToDisable
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(SidsToDisable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).PrivilegesToDelete
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(PrivilegesToDelete)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_SECURITY_LIMIT_INFORMATION>())).RestrictedSids
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_SECURITY_LIMIT_INFORMATION),
            "::",
            stringify!(RestrictedSids)
        )
    );
}
pub type JOBOBJECT_SECURITY_LIMIT_INFORMATION = _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
pub type PJOBOBJECT_SECURITY_LIMIT_INFORMATION = *mut _JOBOBJECT_SECURITY_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    pub EndOfJobTimeAction: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_END_OF_JOB_TIME_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_END_OF_JOB_TIME_INFORMATION>())).EndOfJobTimeAction
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_END_OF_JOB_TIME_INFORMATION),
            "::",
            stringify!(EndOfJobTimeAction)
        )
    );
}
pub type JOBOBJECT_END_OF_JOB_TIME_INFORMATION = _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
pub type PJOBOBJECT_END_OF_JOB_TIME_INFORMATION = *mut _JOBOBJECT_END_OF_JOB_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    pub CompletionKey: PVOID,
    pub CompletionPort: HANDLE,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_ASSOCIATE_COMPLETION_PORT() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>())).CompletionKey
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT),
            "::",
            stringify!(CompletionKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_ASSOCIATE_COMPLETION_PORT>())).CompletionPort
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_ASSOCIATE_COMPLETION_PORT),
            "::",
            stringify!(CompletionPort)
        )
    );
}
pub type JOBOBJECT_ASSOCIATE_COMPLETION_PORT = _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
pub type PJOBOBJECT_ASSOCIATE_COMPLETION_PORT = *mut _JOBOBJECT_ASSOCIATE_COMPLETION_PORT;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    pub BasicInfo: JOBOBJECT_BASIC_ACCOUNTING_INFORMATION,
    pub IoInfo: IO_COUNTERS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>())).BasicInfo
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
            "::",
            stringify!(BasicInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION>())).IoInfo
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION),
            "::",
            stringify!(IoInfo)
        )
    );
}
pub type JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
    _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
pub type PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION =
    *mut _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_JOBSET_INFORMATION {
    pub MemberLevel: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_JOBSET_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_JOBSET_INFORMATION>(),
        4usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_JOBSET_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_JOBSET_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_JOBOBJECT_JOBSET_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_JOBSET_INFORMATION>())).MemberLevel as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_JOBSET_INFORMATION),
            "::",
            stringify!(MemberLevel)
        )
    );
}
pub type JOBOBJECT_JOBSET_INFORMATION = _JOBOBJECT_JOBSET_INFORMATION;
pub type PJOBOBJECT_JOBSET_INFORMATION = *mut _JOBOBJECT_JOBSET_INFORMATION;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_ToleranceLow: _JOBOBJECT_RATE_CONTROL_TOLERANCE = 1;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_ToleranceMedium: _JOBOBJECT_RATE_CONTROL_TOLERANCE = 2;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_ToleranceHigh: _JOBOBJECT_RATE_CONTROL_TOLERANCE = 3;
pub type _JOBOBJECT_RATE_CONTROL_TOLERANCE = i32;
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE as JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub type PJOBOBJECT_RATE_CONTROL_TOLERANCE = *mut _JOBOBJECT_RATE_CONTROL_TOLERANCE;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_ToleranceIntervalShort:
    _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = 1;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_ToleranceIntervalMedium:
    _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = 2;
pub const _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL_ToleranceIntervalLong:
    _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = 3;
pub type _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL = i32;
pub use self::_JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL as JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
pub type PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL =
    *mut _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemoryLimit: DWORD64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub LimitFlags: DWORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).IoReadBytesLimit
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).IoWriteBytesLimit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>()))
                .PerJobUserTimeLimit as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).JobMemoryLimit
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>()))
                .RateControlTolerance as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>()))
                .RateControlToleranceInterval as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(RateControlToleranceInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION>())).LimitFlags
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION),
            "::",
            stringify!(LimitFlags)
        )
    );
}
pub type JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
pub type PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION = *mut _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2 {
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub __bindgen_anon_1: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1,
    pub __bindgen_anon_2: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2,
    pub __bindgen_anon_3: JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3,
    pub LimitFlags: DWORD,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub JobLowMemoryLimit: DWORD64,
    pub IoRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1 {
    pub JobHighMemoryLimit: DWORD64,
    pub JobMemoryLimit: DWORD64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>()))
                .JobHighMemoryLimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobHighMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1>()))
                .JobMemoryLimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>()))
                .RateControlTolerance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2>()))
                .CpuRateControlTolerance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(CpuRateControlTolerance)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3 {
    pub RateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    pub CpuRateControlToleranceInterval: JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>()))
                .RateControlToleranceInterval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(RateControlToleranceInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3>()))
                .CpuRateControlToleranceInterval as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(CpuRateControlToleranceInterval)
        )
    );
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).IoReadBytesLimit
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).IoWriteBytesLimit
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
                .PerJobUserTimeLimit as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).LimitFlags
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
                .IoRateControlTolerance as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>())).JobLowMemoryLimit
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(JobLowMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
                .IoRateControlToleranceInterval as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(IoRateControlToleranceInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
                .NetRateControlTolerance as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(NetRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2>()))
                .NetRateControlToleranceInterval as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2),
            "::",
            stringify!(NetRateControlToleranceInterval)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    pub LimitFlags: DWORD,
    pub ViolationLimitFlags: DWORD,
    pub IoReadBytes: DWORD64,
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytes: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTime: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemory: DWORD64,
    pub JobMemoryLimit: DWORD64,
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_LIMIT_VIOLATION_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).LimitFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).ViolationLimitFlags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(ViolationLimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoReadBytes
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoReadBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoReadBytesLimit
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoWriteBytes
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoWriteBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).IoWriteBytesLimit
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).PerJobUserTime
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(PerJobUserTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).PerJobUserTimeLimit
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).JobMemory as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(JobMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).JobMemoryLimit
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>())).RateControlTolerance
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_LIMIT_VIOLATION_INFORMATION>()))
                .RateControlToleranceLimit as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_LIMIT_VIOLATION_INFORMATION),
            "::",
            stringify!(RateControlToleranceLimit)
        )
    );
}
pub type JOBOBJECT_LIMIT_VIOLATION_INFORMATION = _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
pub type PJOBOBJECT_LIMIT_VIOLATION_INFORMATION = *mut _JOBOBJECT_LIMIT_VIOLATION_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2 {
    pub LimitFlags: DWORD,
    pub ViolationLimitFlags: DWORD,
    pub IoReadBytes: DWORD64,
    pub IoReadBytesLimit: DWORD64,
    pub IoWriteBytes: DWORD64,
    pub IoWriteBytesLimit: DWORD64,
    pub PerJobUserTime: LARGE_INTEGER,
    pub PerJobUserTimeLimit: LARGE_INTEGER,
    pub JobMemory: DWORD64,
    pub __bindgen_anon_1: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1,
    pub __bindgen_anon_2: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2,
    pub __bindgen_anon_3: JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3,
    pub JobLowMemoryLimit: DWORD64,
    pub IoRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub IoRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub NetRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1 {
    pub JobHighMemoryLimit: DWORD64,
    pub JobMemoryLimit: DWORD64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>()))
                .JobHighMemoryLimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobHighMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1>()))
                .JobMemoryLimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_1),
            "::",
            stringify!(JobMemoryLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2 {
    pub RateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlTolerance: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>()))
                .RateControlTolerance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(RateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2>()))
                .CpuRateControlTolerance as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_2),
            "::",
            stringify!(CpuRateControlTolerance)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3 {
    pub RateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    pub CpuRateControlToleranceLimit: JOBOBJECT_RATE_CONTROL_TOLERANCE,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>()))
                .RateControlToleranceLimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(RateControlToleranceLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3>()))
                .CpuRateControlToleranceLimit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2__bindgen_ty_3),
            "::",
            stringify!(CpuRateControlToleranceLimit)
        )
    );
}
#[test]
fn bindgen_test_layout_JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).LimitFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(LimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).ViolationLimitFlags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(ViolationLimitFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoReadBytes
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoReadBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoReadBytesLimit
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoReadBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoWriteBytes
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoWriteBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).IoWriteBytesLimit
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoWriteBytesLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).PerJobUserTime
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(PerJobUserTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).PerJobUserTimeLimit
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(PerJobUserTimeLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).JobMemory
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(JobMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>())).JobLowMemoryLimit
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(JobLowMemoryLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>()))
                .IoRateControlTolerance as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>()))
                .IoRateControlToleranceLimit as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(IoRateControlToleranceLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>()))
                .NetRateControlTolerance as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(NetRateControlTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2>()))
                .NetRateControlToleranceLimit as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2),
            "::",
            stringify!(NetRateControlToleranceLimit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    pub ControlFlags: DWORD,
    pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1 {
    pub CpuRate: DWORD,
    pub Weight: DWORD,
    pub __bindgen_anon_1: _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub MinRate: WORD,
    pub MaxRate: WORD,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1>(
        ),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
            >()))
            .MinRate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MinRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1,
            >()))
            .MaxRate as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(MaxRate)
        )
    );
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>()))
                .CpuRate as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(CpuRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1>())).Weight
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(Weight)
        )
    );
}
#[test]
fn bindgen_test_layout__JOBOBJECT_CPU_RATE_CONTROL_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION>())).ControlFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_CPU_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(ControlFlags)
        )
    );
}
pub type JOBOBJECT_CPU_RATE_CONTROL_INFORMATION = _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub type PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION = *mut _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_ENABLE:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 1;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 2;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 4;
pub const JOB_OBJECT_NET_RATE_CONTROL_FLAGS_JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS:
    JOB_OBJECT_NET_RATE_CONTROL_FLAGS = 7;
pub type JOB_OBJECT_NET_RATE_CONTROL_FLAGS = i32;
pub type __C_ASSERT__ = [::std::os::raw::c_char; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION {
    pub MaxBandwidth: DWORD64,
    pub ControlFlags: JOB_OBJECT_NET_RATE_CONTROL_FLAGS,
    pub DscpTag: BYTE,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_NET_RATE_CONTROL_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>())).MaxBandwidth
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>())).ControlFlags
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_NET_RATE_CONTROL_INFORMATION>())).DscpTag as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_NET_RATE_CONTROL_INFORMATION),
            "::",
            stringify!(DscpTag)
        )
    );
}
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_ENABLE:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 1;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 2;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 4;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP : JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 8 ;
pub const JOB_OBJECT_IO_RATE_CONTROL_FLAGS_JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS:
    JOB_OBJECT_IO_RATE_CONTROL_FLAGS = 15;
pub type JOB_OBJECT_IO_RATE_CONTROL_FLAGS = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).MaxIops
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(MaxIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).MaxBandwidth
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).ReservationIops
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(ReservationIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).VolumeName
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).BaseIoSize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(BaseIoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>())).ControlFlags
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE>()))
                .VolumeNameLength as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE),
            "::",
            stringify!(VolumeNameLength)
        )
    );
}
pub type JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1 =
    JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2 {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
    pub CriticalReservationIops: LONG64,
    pub ReservationBandwidth: LONG64,
    pub CriticalReservationBandwidth: LONG64,
    pub MaxTimePercent: LONG64,
    pub ReservationTimePercent: LONG64,
    pub CriticalReservationTimePercent: LONG64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).MaxIops
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(MaxIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).MaxBandwidth
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .ReservationIops as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ReservationIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).VolumeName
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).BaseIoSize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(BaseIoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>())).ControlFlags
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .VolumeNameLength as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(VolumeNameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .CriticalReservationIops as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(CriticalReservationIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .ReservationBandwidth as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .CriticalReservationBandwidth as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(CriticalReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .MaxTimePercent as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(MaxTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .ReservationTimePercent as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(ReservationTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2>()))
                .CriticalReservationTimePercent as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2),
            "::",
            stringify!(CriticalReservationTimePercent)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3 {
    pub MaxIops: LONG64,
    pub MaxBandwidth: LONG64,
    pub ReservationIops: LONG64,
    pub VolumeName: PWSTR,
    pub BaseIoSize: DWORD,
    pub ControlFlags: JOB_OBJECT_IO_RATE_CONTROL_FLAGS,
    pub VolumeNameLength: WORD,
    pub CriticalReservationIops: LONG64,
    pub ReservationBandwidth: LONG64,
    pub CriticalReservationBandwidth: LONG64,
    pub MaxTimePercent: LONG64,
    pub ReservationTimePercent: LONG64,
    pub CriticalReservationTimePercent: LONG64,
    pub SoftMaxIops: LONG64,
    pub SoftMaxBandwidth: LONG64,
    pub SoftMaxTimePercent: LONG64,
    pub LimitExcessNotifyIops: LONG64,
    pub LimitExcessNotifyBandwidth: LONG64,
    pub LimitExcessNotifyTimePercent: LONG64,
}
#[test]
fn bindgen_test_layout_JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3() {
    assert_eq!(
        ::std::mem::size_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>(),
        144usize,
        concat!(
            "Size of: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).MaxIops
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(MaxIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).MaxBandwidth
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(MaxBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .ReservationIops as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ReservationIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).VolumeName
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(VolumeName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).BaseIoSize
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(BaseIoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).ControlFlags
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .VolumeNameLength as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(VolumeNameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .CriticalReservationIops as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(CriticalReservationIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .ReservationBandwidth as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .CriticalReservationBandwidth as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(CriticalReservationBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .MaxTimePercent as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(MaxTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .ReservationTimePercent as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(ReservationTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .CriticalReservationTimePercent as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(CriticalReservationTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>())).SoftMaxIops
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(SoftMaxIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .SoftMaxBandwidth as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(SoftMaxBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .SoftMaxTimePercent as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(SoftMaxTimePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .LimitExcessNotifyIops as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(LimitExcessNotifyIops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .LimitExcessNotifyBandwidth as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(LimitExcessNotifyBandwidth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3>()))
                .LimitExcessNotifyTimePercent as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3),
            "::",
            stringify!(LimitExcessNotifyTimePercent)
        )
    );
}
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS_JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE:
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = 1;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS_JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE:
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = 2;
pub const JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS_JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS:
    JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = 3;
pub type JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_STATS {
    pub IoCount: ULONG_PTR,
    pub TotalNonOverlappedQueueTime: ULONGLONG,
    pub TotalNonOverlappedServiceTime: ULONGLONG,
    pub TotalSize: ULONGLONG,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_IO_ATTRIBUTION_STATS() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_IO_ATTRIBUTION_STATS>(),
        32usize,
        concat!("Size of: ", stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS))
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_IO_ATTRIBUTION_STATS>(),
        8usize,
        concat!("Alignment of ", stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).IoCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(IoCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).TotalNonOverlappedQueueTime
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(TotalNonOverlappedQueueTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>()))
                .TotalNonOverlappedServiceTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(TotalNonOverlappedServiceTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_STATS>())).TotalSize as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_STATS),
            "::",
            stringify!(TotalSize)
        )
    );
}
pub type JOBOBJECT_IO_ATTRIBUTION_STATS = _JOBOBJECT_IO_ATTRIBUTION_STATS;
pub type PJOBOBJECT_IO_ATTRIBUTION_STATS = *mut _JOBOBJECT_IO_ATTRIBUTION_STATS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION {
    pub ControlFlags: DWORD,
    pub ReadStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
    pub WriteStats: JOBOBJECT_IO_ATTRIBUTION_STATS,
}
#[test]
fn bindgen_test_layout__JOBOBJECT_IO_ATTRIBUTION_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>())).ControlFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
            "::",
            stringify!(ControlFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>())).ReadStats as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
            "::",
            stringify!(ReadStats)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_JOBOBJECT_IO_ATTRIBUTION_INFORMATION>())).WriteStats as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JOBOBJECT_IO_ATTRIBUTION_INFORMATION),
            "::",
            stringify!(WriteStats)
        )
    );
}
pub type JOBOBJECT_IO_ATTRIBUTION_INFORMATION = _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub type PJOBOBJECT_IO_ATTRIBUTION_INFORMATION = *mut _JOBOBJECT_IO_ATTRIBUTION_INFORMATION;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicAccountingInformation: _JOBOBJECTINFOCLASS = 1;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicLimitInformation: _JOBOBJECTINFOCLASS = 2;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicProcessIdList: _JOBOBJECTINFOCLASS = 3;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicUIRestrictions: _JOBOBJECTINFOCLASS = 4;
pub const _JOBOBJECTINFOCLASS_JobObjectSecurityLimitInformation: _JOBOBJECTINFOCLASS = 5;
pub const _JOBOBJECTINFOCLASS_JobObjectEndOfJobTimeInformation: _JOBOBJECTINFOCLASS = 6;
pub const _JOBOBJECTINFOCLASS_JobObjectAssociateCompletionPortInformation: _JOBOBJECTINFOCLASS = 7;
pub const _JOBOBJECTINFOCLASS_JobObjectBasicAndIoAccountingInformation: _JOBOBJECTINFOCLASS = 8;
pub const _JOBOBJECTINFOCLASS_JobObjectExtendedLimitInformation: _JOBOBJECTINFOCLASS = 9;
pub const _JOBOBJECTINFOCLASS_JobObjectJobSetInformation: _JOBOBJECTINFOCLASS = 10;
pub const _JOBOBJECTINFOCLASS_JobObjectGroupInformation: _JOBOBJECTINFOCLASS = 11;
pub const _JOBOBJECTINFOCLASS_JobObjectNotificationLimitInformation: _JOBOBJECTINFOCLASS = 12;
pub const _JOBOBJECTINFOCLASS_JobObjectLimitViolationInformation: _JOBOBJECTINFOCLASS = 13;
pub const _JOBOBJECTINFOCLASS_JobObjectGroupInformationEx: _JOBOBJECTINFOCLASS = 14;
pub const _JOBOBJECTINFOCLASS_JobObjectCpuRateControlInformation: _JOBOBJECTINFOCLASS = 15;
pub const _JOBOBJECTINFOCLASS_JobObjectCompletionFilter: _JOBOBJECTINFOCLASS = 16;
pub const _JOBOBJECTINFOCLASS_JobObjectCompletionCounter: _JOBOBJECTINFOCLASS = 17;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved1Information: _JOBOBJECTINFOCLASS = 18;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved2Information: _JOBOBJECTINFOCLASS = 19;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved3Information: _JOBOBJECTINFOCLASS = 20;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved4Information: _JOBOBJECTINFOCLASS = 21;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved5Information: _JOBOBJECTINFOCLASS = 22;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved6Information: _JOBOBJECTINFOCLASS = 23;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved7Information: _JOBOBJECTINFOCLASS = 24;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved8Information: _JOBOBJECTINFOCLASS = 25;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved9Information: _JOBOBJECTINFOCLASS = 26;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved10Information: _JOBOBJECTINFOCLASS = 27;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved11Information: _JOBOBJECTINFOCLASS = 28;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved12Information: _JOBOBJECTINFOCLASS = 29;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved13Information: _JOBOBJECTINFOCLASS = 30;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved14Information: _JOBOBJECTINFOCLASS = 31;
pub const _JOBOBJECTINFOCLASS_JobObjectNetRateControlInformation: _JOBOBJECTINFOCLASS = 32;
pub const _JOBOBJECTINFOCLASS_JobObjectNotificationLimitInformation2: _JOBOBJECTINFOCLASS = 33;
pub const _JOBOBJECTINFOCLASS_JobObjectLimitViolationInformation2: _JOBOBJECTINFOCLASS = 34;
pub const _JOBOBJECTINFOCLASS_JobObjectCreateSilo: _JOBOBJECTINFOCLASS = 35;
pub const _JOBOBJECTINFOCLASS_JobObjectSiloBasicInformation: _JOBOBJECTINFOCLASS = 36;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved15Information: _JOBOBJECTINFOCLASS = 37;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved16Information: _JOBOBJECTINFOCLASS = 38;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved17Information: _JOBOBJECTINFOCLASS = 39;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved18Information: _JOBOBJECTINFOCLASS = 40;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved19Information: _JOBOBJECTINFOCLASS = 41;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved20Information: _JOBOBJECTINFOCLASS = 42;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved21Information: _JOBOBJECTINFOCLASS = 43;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved22Information: _JOBOBJECTINFOCLASS = 44;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved23Information: _JOBOBJECTINFOCLASS = 45;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved24Information: _JOBOBJECTINFOCLASS = 46;
pub const _JOBOBJECTINFOCLASS_JobObjectReserved25Information: _JOBOBJECTINFOCLASS = 47;
pub const _JOBOBJECTINFOCLASS_MaxJobObjectInfoClass: _JOBOBJECTINFOCLASS = 48;
pub type _JOBOBJECTINFOCLASS = i32;
pub use self::_JOBOBJECTINFOCLASS as JOBOBJECTINFOCLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SILOOBJECT_BASIC_INFORMATION {
    pub SiloId: DWORD,
    pub SiloParentId: DWORD,
    pub NumberOfProcesses: DWORD,
    pub IsInServerSilo: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
}
#[test]
fn bindgen_test_layout__SILOOBJECT_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_SILOOBJECT_BASIC_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SILOOBJECT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SILOOBJECT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(SiloId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).SiloParentId as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(SiloParentId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).NumberOfProcesses as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(NumberOfProcesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).IsInServerSilo as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(IsInServerSilo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SILOOBJECT_BASIC_INFORMATION>())).Reserved as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_SILOOBJECT_BASIC_INFORMATION),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type SILOOBJECT_BASIC_INFORMATION = _SILOOBJECT_BASIC_INFORMATION;
pub type PSILOOBJECT_BASIC_INFORMATION = *mut _SILOOBJECT_BASIC_INFORMATION;
pub const _SERVERSILO_STATE_SERVERSILO_INITING: _SERVERSILO_STATE = 0;
pub const _SERVERSILO_STATE_SERVERSILO_STARTED: _SERVERSILO_STATE = 1;
pub const _SERVERSILO_STATE_SERVERSILO_SHUTTING_DOWN: _SERVERSILO_STATE = 2;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATING: _SERVERSILO_STATE = 3;
pub const _SERVERSILO_STATE_SERVERSILO_TERMINATED: _SERVERSILO_STATE = 4;
pub type _SERVERSILO_STATE = i32;
pub use self::_SERVERSILO_STATE as SERVERSILO_STATE;
pub type PSERVERSILO_STATE = *mut _SERVERSILO_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SERVERSILO_BASIC_INFORMATION {
    pub ServiceSessionId: DWORD,
    pub State: SERVERSILO_STATE,
    pub ExitStatus: DWORD,
}
#[test]
fn bindgen_test_layout__SERVERSILO_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_SERVERSILO_BASIC_INFORMATION>(),
        12usize,
        concat!("Size of: ", stringify!(_SERVERSILO_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SERVERSILO_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_SERVERSILO_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ServiceSessionId as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(ServiceSessionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).State as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SERVERSILO_BASIC_INFORMATION>())).ExitStatus as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SERVERSILO_BASIC_INFORMATION),
            "::",
            stringify!(ExitStatus)
        )
    );
}
pub type SERVERSILO_BASIC_INFORMATION = _SERVERSILO_BASIC_INFORMATION;
pub type PSERVERSILO_BASIC_INFORMATION = *mut _SERVERSILO_BASIC_INFORMATION;
pub const _FIRMWARE_TYPE_FirmwareTypeUnknown: _FIRMWARE_TYPE = 0;
pub const _FIRMWARE_TYPE_FirmwareTypeBios: _FIRMWARE_TYPE = 1;
pub const _FIRMWARE_TYPE_FirmwareTypeUefi: _FIRMWARE_TYPE = 2;
pub const _FIRMWARE_TYPE_FirmwareTypeMax: _FIRMWARE_TYPE = 3;
pub type _FIRMWARE_TYPE = i32;
pub use self::_FIRMWARE_TYPE as FIRMWARE_TYPE;
pub type PFIRMWARE_TYPE = *mut _FIRMWARE_TYPE;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorCore: _LOGICAL_PROCESSOR_RELATIONSHIP =
    0;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationNumaNode: _LOGICAL_PROCESSOR_RELATIONSHIP = 1;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationCache: _LOGICAL_PROCESSOR_RELATIONSHIP = 2;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationProcessorPackage:
    _LOGICAL_PROCESSOR_RELATIONSHIP = 3;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationGroup: _LOGICAL_PROCESSOR_RELATIONSHIP = 4;
pub const _LOGICAL_PROCESSOR_RELATIONSHIP_RelationAll: _LOGICAL_PROCESSOR_RELATIONSHIP = 65535;
pub type _LOGICAL_PROCESSOR_RELATIONSHIP = i32;
pub use self::_LOGICAL_PROCESSOR_RELATIONSHIP as LOGICAL_PROCESSOR_RELATIONSHIP;
pub const _PROCESSOR_CACHE_TYPE_CacheUnified: _PROCESSOR_CACHE_TYPE = 0;
pub const _PROCESSOR_CACHE_TYPE_CacheInstruction: _PROCESSOR_CACHE_TYPE = 1;
pub const _PROCESSOR_CACHE_TYPE_CacheData: _PROCESSOR_CACHE_TYPE = 2;
pub const _PROCESSOR_CACHE_TYPE_CacheTrace: _PROCESSOR_CACHE_TYPE = 3;
pub type _PROCESSOR_CACHE_TYPE = i32;
pub use self::_PROCESSOR_CACHE_TYPE as PROCESSOR_CACHE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_DESCRIPTOR {
    pub Level: BYTE,
    pub Associativity: BYTE,
    pub LineSize: WORD,
    pub Size: DWORD,
    pub Type: PROCESSOR_CACHE_TYPE,
}
#[test]
fn bindgen_test_layout__CACHE_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<_CACHE_DESCRIPTOR>(),
        12usize,
        concat!("Size of: ", stringify!(_CACHE_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_CACHE_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_CACHE_DESCRIPTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Associativity as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Associativity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).LineSize as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(LineSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_DESCRIPTOR>())).Type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_DESCRIPTOR),
            "::",
            stringify!(Type)
        )
    );
}
pub type CACHE_DESCRIPTOR = _CACHE_DESCRIPTOR;
pub type PCACHE_DESCRIPTOR = *mut _CACHE_DESCRIPTOR;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    pub ProcessorMask: ULONG_PTR,
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1 {
    pub ProcessorCore: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    pub NumaNode: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
    pub Cache: CACHE_DESCRIPTOR,
    pub Reserved: [ULONGLONG; 2usize],
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Flags: BYTE,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2 {
    pub NodeNumber: DWORD,
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2,
            >()))
            .NodeNumber as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(NodeNumber)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>()))
                .ProcessorCore as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(ProcessorCore)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).NumaNode
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(NumaNode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Cache
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(Cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1>())).Reserved
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).ProcessorMask
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
            "::",
            stringify!(ProcessorMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION>())).Relationship
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION),
            "::",
            stringify!(Relationship)
        )
    );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_RELATIONSHIP {
    pub Flags: BYTE,
    pub EfficiencyClass: BYTE,
    pub Reserved: [BYTE; 20usize],
    pub GroupCount: WORD,
    pub GroupMask: [GROUP_AFFINITY; 1usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_RELATIONSHIP() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_RELATIONSHIP>(),
        40usize,
        concat!("Size of: ", stringify!(_PROCESSOR_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_RELATIONSHIP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).EfficiencyClass as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(EfficiencyClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).Reserved as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupCount as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(GroupCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_RELATIONSHIP>())).GroupMask as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_RELATIONSHIP),
            "::",
            stringify!(GroupMask)
        )
    );
}
pub type PROCESSOR_RELATIONSHIP = _PROCESSOR_RELATIONSHIP;
pub type PPROCESSOR_RELATIONSHIP = *mut _PROCESSOR_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NUMA_NODE_RELATIONSHIP {
    pub NodeNumber: DWORD,
    pub Reserved: [BYTE; 20usize],
    pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__NUMA_NODE_RELATIONSHIP() {
    assert_eq!(
        ::std::mem::size_of::<_NUMA_NODE_RELATIONSHIP>(),
        40usize,
        concat!("Size of: ", stringify!(_NUMA_NODE_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_NUMA_NODE_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_NUMA_NODE_RELATIONSHIP))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).NodeNumber as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NUMA_NODE_RELATIONSHIP),
            "::",
            stringify!(NodeNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_NUMA_NODE_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NUMA_NODE_RELATIONSHIP>())).GroupMask as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_NUMA_NODE_RELATIONSHIP),
            "::",
            stringify!(GroupMask)
        )
    );
}
pub type NUMA_NODE_RELATIONSHIP = _NUMA_NODE_RELATIONSHIP;
pub type PNUMA_NODE_RELATIONSHIP = *mut _NUMA_NODE_RELATIONSHIP;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CACHE_RELATIONSHIP {
    pub Level: BYTE,
    pub Associativity: BYTE,
    pub LineSize: WORD,
    pub CacheSize: DWORD,
    pub Type: PROCESSOR_CACHE_TYPE,
    pub Reserved: [BYTE; 20usize],
    pub GroupMask: GROUP_AFFINITY,
}
#[test]
fn bindgen_test_layout__CACHE_RELATIONSHIP() {
    assert_eq!(
        ::std::mem::size_of::<_CACHE_RELATIONSHIP>(),
        48usize,
        concat!("Size of: ", stringify!(_CACHE_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_CACHE_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_CACHE_RELATIONSHIP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Level)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Associativity as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Associativity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).LineSize as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(LineSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).CacheSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(CacheSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).Reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CACHE_RELATIONSHIP>())).GroupMask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_CACHE_RELATIONSHIP),
            "::",
            stringify!(GroupMask)
        )
    );
}
pub type CACHE_RELATIONSHIP = _CACHE_RELATIONSHIP;
pub type PCACHE_RELATIONSHIP = *mut _CACHE_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _PROCESSOR_GROUP_INFO {
    pub MaximumProcessorCount: BYTE,
    pub ActiveProcessorCount: BYTE,
    pub Reserved: [BYTE; 38usize],
    pub ActiveProcessorMask: KAFFINITY,
}
#[test]
fn bindgen_test_layout__PROCESSOR_GROUP_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_GROUP_INFO>(),
        48usize,
        concat!("Size of: ", stringify!(_PROCESSOR_GROUP_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_GROUP_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_GROUP_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).MaximumProcessorCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(MaximumProcessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorCount as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(ActiveProcessorCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).Reserved as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_GROUP_INFO>())).ActiveProcessorMask as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_GROUP_INFO),
            "::",
            stringify!(ActiveProcessorMask)
        )
    );
}
pub type PROCESSOR_GROUP_INFO = _PROCESSOR_GROUP_INFO;
pub type PPROCESSOR_GROUP_INFO = *mut _PROCESSOR_GROUP_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _GROUP_RELATIONSHIP {
    pub MaximumGroupCount: WORD,
    pub ActiveGroupCount: WORD,
    pub Reserved: [BYTE; 20usize],
    pub GroupInfo: [PROCESSOR_GROUP_INFO; 1usize],
}
#[test]
fn bindgen_test_layout__GROUP_RELATIONSHIP() {
    assert_eq!(
        ::std::mem::size_of::<_GROUP_RELATIONSHIP>(),
        72usize,
        concat!("Size of: ", stringify!(_GROUP_RELATIONSHIP))
    );
    assert_eq!(
        ::std::mem::align_of::<_GROUP_RELATIONSHIP>(),
        8usize,
        concat!("Alignment of ", stringify!(_GROUP_RELATIONSHIP))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).MaximumGroupCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(MaximumGroupCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).ActiveGroupCount as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(ActiveGroupCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_GROUP_RELATIONSHIP>())).GroupInfo as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_GROUP_RELATIONSHIP),
            "::",
            stringify!(GroupInfo)
        )
    );
}
pub type GROUP_RELATIONSHIP = _GROUP_RELATIONSHIP;
pub type PGROUP_RELATIONSHIP = *mut _GROUP_RELATIONSHIP;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    pub Relationship: LOGICAL_PROCESSOR_RELATIONSHIP,
    pub Size: DWORD,
    pub __bindgen_anon_1: _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1 {
    pub Processor: PROCESSOR_RELATIONSHIP,
    pub NumaNode: NUMA_NODE_RELATIONSHIP,
    pub Cache: CACHE_RELATIONSHIP,
    pub Group: GROUP_RELATIONSHIP,
    _bindgen_union_align: [u64; 9usize],
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>()))
                .Processor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(Processor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>()))
                .NumaNode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(NumaNode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Cache
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(Cache)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1>())).Group
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX__bindgen_ty_1),
            "::",
            stringify!(Group)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
        80usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Relationship
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
            "::",
            stringify!(Relationship)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX>())).Size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX),
            "::",
            stringify!(Size)
        )
    );
}
pub type SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub type PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX = *mut _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;
pub const _CPU_SET_INFORMATION_TYPE_CpuSetInformation: _CPU_SET_INFORMATION_TYPE = 0;
pub type _CPU_SET_INFORMATION_TYPE = i32;
pub use self::_CPU_SET_INFORMATION_TYPE as CPU_SET_INFORMATION_TYPE;
pub type PCPU_SET_INFORMATION_TYPE = *mut _CPU_SET_INFORMATION_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION {
    pub Size: DWORD,
    pub Type: CPU_SET_INFORMATION_TYPE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1 {
    pub CpuSet: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: [u64; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1 {
    pub Id: DWORD,
    pub Group: WORD,
    pub LogicalProcessorIndex: BYTE,
    pub CoreIndex: BYTE,
    pub LastLevelCacheIndex: BYTE,
    pub NumaNodeIndex: BYTE,
    pub EfficiencyClass: BYTE,
    pub __bindgen_anon_1: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
    pub AllocationTag: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub AllFlags: BYTE,
    pub __bindgen_anon_1:
        _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
}
impl _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Parked(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Parked(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Allocated(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_Allocated(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllocatedToTargetProcess(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_AllocatedToTargetProcess(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RealTime(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_RealTime(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedFlags(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_ReservedFlags(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Parked: BYTE,
        Allocated: BYTE,
        AllocatedToTargetProcess: BYTE,
        RealTime: BYTE,
        ReservedFlags: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Parked: u8 = unsafe { ::std::mem::transmute(Parked) };
            Parked as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Allocated: u8 = unsafe { ::std::mem::transmute(Allocated) };
            Allocated as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AllocatedToTargetProcess: u8 =
                unsafe { ::std::mem::transmute(AllocatedToTargetProcess) };
            AllocatedToTargetProcess as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let RealTime: u8 = unsafe { ::std::mem::transmute(RealTime) };
            RealTime as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let ReservedFlags: u8 = unsafe { ::std::mem::transmute(ReservedFlags) };
            ReservedFlags as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .AllFlags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AllFlags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2 {
    pub Reserved: DWORD,
    pub SchedulingClass: BYTE,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2>(
        ),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
            >()))
            .Reserved as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                _SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2,
            >()))
            .SchedulingClass as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(SchedulingClass)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>())).Id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .Group as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Group)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .LogicalProcessorIndex as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LogicalProcessorIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .CoreIndex as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(CoreIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .LastLevelCacheIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastLevelCacheIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .NumaNodeIndex as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(NumaNodeIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .EfficiencyClass as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(EfficiencyClass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1>()))
                .AllocationTag as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AllocationTag)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1>())).CpuSet as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION__bindgen_ty_1),
            "::",
            stringify!(CpuSet)
        )
    );
}
#[test]
fn bindgen_test_layout__SYSTEM_CPU_SET_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_CPU_SET_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_CPU_SET_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_SYSTEM_CPU_SET_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_CPU_SET_INFORMATION>())).Type as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_CPU_SET_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type SYSTEM_CPU_SET_INFORMATION = _SYSTEM_CPU_SET_INFORMATION;
pub type PSYSTEM_CPU_SET_INFORMATION = *mut _SYSTEM_CPU_SET_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    pub CycleTime: DWORD64,
}
#[test]
fn bindgen_test_layout__SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION>())).CycleTime
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION),
            "::",
            stringify!(CycleTime)
        )
    );
}
pub type SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
pub type PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION = *mut _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_FEATURE {
    pub Offset: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__XSTATE_FEATURE() {
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_FEATURE>(),
        8usize,
        concat!("Size of: ", stringify!(_XSTATE_FEATURE))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_FEATURE>(),
        4usize,
        concat!("Alignment of ", stringify!(_XSTATE_FEATURE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_FEATURE>())).Offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_FEATURE),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_FEATURE>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_FEATURE),
            "::",
            stringify!(Size)
        )
    );
}
pub type XSTATE_FEATURE = _XSTATE_FEATURE;
pub type PXSTATE_FEATURE = *mut _XSTATE_FEATURE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _XSTATE_CONFIGURATION {
    pub EnabledFeatures: DWORD64,
    pub EnabledVolatileFeatures: DWORD64,
    pub Size: DWORD,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1,
    pub Features: [XSTATE_FEATURE; 64usize],
    pub EnabledSupervisorFeatures: DWORD64,
    pub AlignedFeatures: DWORD64,
    pub AllFeatureSize: DWORD,
    pub AllFeatures: [DWORD; 64usize],
    pub EnabledUserVisibleSupervisorFeatures: DWORD64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _XSTATE_CONFIGURATION__bindgen_ty_1 {
    pub ControlFlags: DWORD,
    pub __bindgen_anon_1: _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub __bindgen_padding_0: [u8; 3usize],
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _XSTATE_CONFIGURATION__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn OptimizedSave(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_OptimizedSave(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CompactionEnabled(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_CompactionEnabled(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OptimizedSave: DWORD,
        CompactionEnabled: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let OptimizedSave: u32 = unsafe { ::std::mem::transmute(OptimizedSave) };
            OptimizedSave as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let CompactionEnabled: u32 = unsafe { ::std::mem::transmute(CompactionEnabled) };
            CompactionEnabled as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONFIGURATION__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION__bindgen_ty_1>())).ControlFlags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION__bindgen_ty_1),
            "::",
            stringify!(ControlFlags)
        )
    );
}
#[test]
fn bindgen_test_layout__XSTATE_CONFIGURATION() {
    assert_eq!(
        ::std::mem::size_of::<_XSTATE_CONFIGURATION>(),
        824usize,
        concat!("Size of: ", stringify!(_XSTATE_CONFIGURATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_XSTATE_CONFIGURATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_XSTATE_CONFIGURATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledVolatileFeatures as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledVolatileFeatures)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).Size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).Features as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(Features)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledSupervisorFeatures as *const _
                as usize
        },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledSupervisorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).AlignedFeatures as *const _ as usize
        },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AlignedFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).AllFeatureSize as *const _ as usize
        },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AllFeatureSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).AllFeatures as *const _ as usize
        },
        556usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(AllFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_XSTATE_CONFIGURATION>())).EnabledUserVisibleSupervisorFeatures
                as *const _ as usize
        },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(_XSTATE_CONFIGURATION),
            "::",
            stringify!(EnabledUserVisibleSupervisorFeatures)
        )
    );
}
pub type XSTATE_CONFIGURATION = _XSTATE_CONFIGURATION;
pub type PXSTATE_CONFIGURATION = *mut _XSTATE_CONFIGURATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION {
    pub BaseAddress: PVOID,
    pub AllocationBase: PVOID,
    pub AllocationProtect: DWORD,
    pub RegionSize: SIZE_T,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_BASIC_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_BASIC_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).BaseAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).AllocationBase as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).AllocationProtect as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).RegionSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).State as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).Protect as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION>())).Type as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION = _MEMORY_BASIC_INFORMATION;
pub type PMEMORY_BASIC_INFORMATION = *mut _MEMORY_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION32 {
    pub BaseAddress: DWORD,
    pub AllocationBase: DWORD,
    pub AllocationProtect: DWORD,
    pub RegionSize: DWORD,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION32() {
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_BASIC_INFORMATION32>(),
        28usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION32))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEMORY_BASIC_INFORMATION32>(),
        4usize,
        concat!("Alignment of ", stringify!(_MEMORY_BASIC_INFORMATION32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).BaseAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).AllocationBase as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).AllocationProtect as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).RegionSize as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).State as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).Protect as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION32>())).Type as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION32),
            "::",
            stringify!(Type)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION32 = _MEMORY_BASIC_INFORMATION32;
pub type PMEMORY_BASIC_INFORMATION32 = *mut _MEMORY_BASIC_INFORMATION32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEMORY_BASIC_INFORMATION64 {
    pub BaseAddress: ULONGLONG,
    pub AllocationBase: ULONGLONG,
    pub AllocationProtect: DWORD,
    pub __alignment1: DWORD,
    pub RegionSize: ULONGLONG,
    pub State: DWORD,
    pub Protect: DWORD,
    pub Type: DWORD,
    pub __alignment2: DWORD,
}
#[test]
fn bindgen_test_layout__MEMORY_BASIC_INFORMATION64() {
    assert_eq!(
        ::std::mem::size_of::<_MEMORY_BASIC_INFORMATION64>(),
        48usize,
        concat!("Size of: ", stringify!(_MEMORY_BASIC_INFORMATION64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).BaseAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).AllocationBase as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(AllocationBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).AllocationProtect as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(AllocationProtect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).__alignment1 as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(__alignment1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).RegionSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(RegionSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).State as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).Protect as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(Protect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).Type as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEMORY_BASIC_INFORMATION64>())).__alignment2 as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEMORY_BASIC_INFORMATION64),
            "::",
            stringify!(__alignment2)
        )
    );
}
pub type MEMORY_BASIC_INFORMATION64 = _MEMORY_BASIC_INFORMATION64;
pub type PMEMORY_BASIC_INFORMATION64 = *mut _MEMORY_BASIC_INFORMATION64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CFG_CALL_TARGET_INFO {
    pub Offset: ULONG_PTR,
    pub Flags: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__CFG_CALL_TARGET_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_CFG_CALL_TARGET_INFO>(),
        16usize,
        concat!("Size of: ", stringify!(_CFG_CALL_TARGET_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_CFG_CALL_TARGET_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(_CFG_CALL_TARGET_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CFG_CALL_TARGET_INFO>())).Offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CFG_CALL_TARGET_INFO),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_CFG_CALL_TARGET_INFO>())).Flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CFG_CALL_TARGET_INFO),
            "::",
            stringify!(Flags)
        )
    );
}
pub type CFG_CALL_TARGET_INFO = _CFG_CALL_TARGET_INFO;
pub type PCFG_CALL_TARGET_INFO = *mut _CFG_CALL_TARGET_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MEM_ADDRESS_REQUIREMENTS {
    pub LowestStartingAddress: PVOID,
    pub HighestEndingAddress: PVOID,
    pub Alignment: SIZE_T,
}
#[test]
fn bindgen_test_layout__MEM_ADDRESS_REQUIREMENTS() {
    assert_eq!(
        ::std::mem::size_of::<_MEM_ADDRESS_REQUIREMENTS>(),
        24usize,
        concat!("Size of: ", stringify!(_MEM_ADDRESS_REQUIREMENTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_MEM_ADDRESS_REQUIREMENTS>(),
        8usize,
        concat!("Alignment of ", stringify!(_MEM_ADDRESS_REQUIREMENTS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEM_ADDRESS_REQUIREMENTS>())).LowestStartingAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEM_ADDRESS_REQUIREMENTS),
            "::",
            stringify!(LowestStartingAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEM_ADDRESS_REQUIREMENTS>())).HighestEndingAddress as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEM_ADDRESS_REQUIREMENTS),
            "::",
            stringify!(HighestEndingAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MEM_ADDRESS_REQUIREMENTS>())).Alignment as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_MEM_ADDRESS_REQUIREMENTS),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type MEM_ADDRESS_REQUIREMENTS = _MEM_ADDRESS_REQUIREMENTS;
pub type PMEM_ADDRESS_REQUIREMENTS = *mut _MEM_ADDRESS_REQUIREMENTS;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterInvalidType: MEM_EXTENDED_PARAMETER_TYPE =
    0;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAddressRequirements:
    MEM_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterNumaNode: MEM_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterPartitionHandle:
    MEM_EXTENDED_PARAMETER_TYPE = 3;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterUserPhysicalHandle:
    MEM_EXTENDED_PARAMETER_TYPE = 4;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterAttributeFlags:
    MEM_EXTENDED_PARAMETER_TYPE = 5;
pub const MEM_EXTENDED_PARAMETER_TYPE_MemExtendedParameterMax: MEM_EXTENDED_PARAMETER_TYPE = 6;
pub type MEM_EXTENDED_PARAMETER_TYPE = i32;
pub type PMEM_EXTENDED_PARAMETER_TYPE = *mut MEM_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER {
    pub __bindgen_anon_1: MEM_EXTENDED_PARAMETER__bindgen_ty_1,
    pub __bindgen_anon_2: MEM_EXTENDED_PARAMETER__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_MEM_EXTENDED_PARAMETER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_1)
        )
    );
}
impl MEM_EXTENDED_PARAMETER__bindgen_ty_1 {
    #[inline]
    pub fn Type(&self) -> DWORD64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: DWORD64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 56u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 56u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: DWORD64,
        Reserved: DWORD64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 56u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union MEM_EXTENDED_PARAMETER__bindgen_ty_2 {
    pub ULong64: DWORD64,
    pub Pointer: PVOID,
    pub Size: SIZE_T,
    pub Handle: HANDLE,
    pub ULong: DWORD,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_MEM_EXTENDED_PARAMETER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>())).ULong64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(ULong64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>())).Pointer as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(Pointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>())).Size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>())).Handle as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(Handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MEM_EXTENDED_PARAMETER__bindgen_ty_2>())).ULong as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MEM_EXTENDED_PARAMETER__bindgen_ty_2),
            "::",
            stringify!(ULong)
        )
    );
}
#[test]
fn bindgen_test_layout_MEM_EXTENDED_PARAMETER() {
    assert_eq!(
        ::std::mem::size_of::<MEM_EXTENDED_PARAMETER>(),
        16usize,
        concat!("Size of: ", stringify!(MEM_EXTENDED_PARAMETER))
    );
    assert_eq!(
        ::std::mem::align_of::<MEM_EXTENDED_PARAMETER>(),
        8usize,
        concat!("Alignment of ", stringify!(MEM_EXTENDED_PARAMETER))
    );
}
pub type PMEM_EXTENDED_PARAMETER = *mut MEM_EXTENDED_PARAMETER;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterInvalidType:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 0;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterUserPhysicalFlags:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 1;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterNumaNode:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 2;
pub const MEM_SECTION_EXTENDED_PARAMETER_TYPE_MemSectionExtendedParameterMax:
    MEM_SECTION_EXTENDED_PARAMETER_TYPE = 3;
pub type MEM_SECTION_EXTENDED_PARAMETER_TYPE = i32;
pub type PMEM_SECTION_EXTENDED_PARAMETER_TYPE = *mut MEM_SECTION_EXTENDED_PARAMETER_TYPE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_SGX {
    pub Secs: [BYTE; 4096usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_SGX() {
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_CREATE_INFO_SGX>(),
        4096usize,
        concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_SGX))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_CREATE_INFO_SGX>(),
        1usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_SGX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ENCLAVE_CREATE_INFO_SGX>())).Secs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_SGX),
            "::",
            stringify!(Secs)
        )
    );
}
pub type ENCLAVE_CREATE_INFO_SGX = _ENCLAVE_CREATE_INFO_SGX;
pub type PENCLAVE_CREATE_INFO_SGX = *mut _ENCLAVE_CREATE_INFO_SGX;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_SGX {
    pub SigStruct: [BYTE; 1808usize],
    pub Reserved1: [BYTE; 240usize],
    pub EInitToken: [BYTE; 304usize],
    pub Reserved2: [BYTE; 1744usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_SGX() {
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_INIT_INFO_SGX>(),
        4096usize,
        concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_SGX))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_INIT_INFO_SGX>(),
        1usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_SGX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).SigStruct as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(SigStruct)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).Reserved1 as *const _ as usize
        },
        1808usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).EInitToken as *const _ as usize
        },
        2048usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(EInitToken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENCLAVE_INIT_INFO_SGX>())).Reserved2 as *const _ as usize
        },
        2352usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_SGX),
            "::",
            stringify!(Reserved2)
        )
    );
}
pub type ENCLAVE_INIT_INFO_SGX = _ENCLAVE_INIT_INFO_SGX;
pub type PENCLAVE_INIT_INFO_SGX = *mut _ENCLAVE_INIT_INFO_SGX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_CREATE_INFO_VBS {
    pub Flags: DWORD,
    pub OwnerID: [BYTE; 32usize],
}
#[test]
fn bindgen_test_layout__ENCLAVE_CREATE_INFO_VBS() {
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_CREATE_INFO_VBS>(),
        36usize,
        concat!("Size of: ", stringify!(_ENCLAVE_CREATE_INFO_VBS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_CREATE_INFO_VBS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_CREATE_INFO_VBS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ENCLAVE_CREATE_INFO_VBS>())).Flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_VBS),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENCLAVE_CREATE_INFO_VBS>())).OwnerID as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_CREATE_INFO_VBS),
            "::",
            stringify!(OwnerID)
        )
    );
}
pub type ENCLAVE_CREATE_INFO_VBS = _ENCLAVE_CREATE_INFO_VBS;
pub type PENCLAVE_CREATE_INFO_VBS = *mut _ENCLAVE_CREATE_INFO_VBS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENCLAVE_INIT_INFO_VBS {
    pub Length: DWORD,
    pub ThreadCount: DWORD,
}
#[test]
fn bindgen_test_layout__ENCLAVE_INIT_INFO_VBS() {
    assert_eq!(
        ::std::mem::size_of::<_ENCLAVE_INIT_INFO_VBS>(),
        8usize,
        concat!("Size of: ", stringify!(_ENCLAVE_INIT_INFO_VBS))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENCLAVE_INIT_INFO_VBS>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENCLAVE_INIT_INFO_VBS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ENCLAVE_INIT_INFO_VBS>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENCLAVE_INIT_INFO_VBS>())).ThreadCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENCLAVE_INIT_INFO_VBS),
            "::",
            stringify!(ThreadCount)
        )
    );
}
pub type ENCLAVE_INIT_INFO_VBS = _ENCLAVE_INIT_INFO_VBS;
pub type PENCLAVE_INIT_INFO_VBS = *mut _ENCLAVE_INIT_INFO_VBS;
pub type ENCLAVE_TARGET_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(arg1: PVOID) -> PVOID>;
pub type PENCLAVE_TARGET_FUNCTION = ENCLAVE_TARGET_FUNCTION;
pub type LPENCLAVE_TARGET_FUNCTION = PENCLAVE_TARGET_FUNCTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_ID_128 {
    pub Identifier: [BYTE; 16usize],
}
#[test]
fn bindgen_test_layout__FILE_ID_128() {
    assert_eq!(
        ::std::mem::size_of::<_FILE_ID_128>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_ID_128))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_ID_128>(),
        1usize,
        concat!("Alignment of ", stringify!(_FILE_ID_128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FILE_ID_128>())).Identifier as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_ID_128),
            "::",
            stringify!(Identifier)
        )
    );
}
pub type FILE_ID_128 = _FILE_ID_128;
pub type PFILE_ID_128 = *mut _FILE_ID_128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILE_NOTIFY_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_FILE_NOTIFY_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILE_NOTIFY_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_INFORMATION>())).NextEntryOffset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FILE_NOTIFY_INFORMATION>())).Action as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_INFORMATION>())).FileNameLength as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_INFORMATION>())).FileName as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NOTIFY_INFORMATION = _FILE_NOTIFY_INFORMATION;
pub type PFILE_NOTIFY_INFORMATION = *mut _FILE_NOTIFY_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _FILE_NOTIFY_EXTENDED_INFORMATION {
    pub NextEntryOffset: DWORD,
    pub Action: DWORD,
    pub CreationTime: LARGE_INTEGER,
    pub LastModificationTime: LARGE_INTEGER,
    pub LastChangeTime: LARGE_INTEGER,
    pub LastAccessTime: LARGE_INTEGER,
    pub AllocatedLength: LARGE_INTEGER,
    pub FileSize: LARGE_INTEGER,
    pub FileAttributes: DWORD,
    pub ReparsePointTag: DWORD,
    pub FileId: LARGE_INTEGER,
    pub ParentFileId: LARGE_INTEGER,
    pub FileNameLength: DWORD,
    pub FileName: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__FILE_NOTIFY_EXTENDED_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_FILE_NOTIFY_EXTENDED_INFORMATION>(),
        88usize,
        concat!("Size of: ", stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_NOTIFY_EXTENDED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).NextEntryOffset
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(NextEntryOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).Action as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).CreationTime as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(CreationTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).LastModificationTime
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(LastModificationTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).LastChangeTime as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(LastChangeTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).LastAccessTime as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(LastAccessTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).AllocatedLength
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(AllocatedLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileSize as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileAttributes as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileAttributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).ReparsePointTag
                as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(ReparsePointTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileId as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).ParentFileId as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(ParentFileId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileNameLength as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileNameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_FILE_NOTIFY_EXTENDED_INFORMATION>())).FileName as *const _
                as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_NOTIFY_EXTENDED_INFORMATION),
            "::",
            stringify!(FileName)
        )
    );
}
pub type FILE_NOTIFY_EXTENDED_INFORMATION = _FILE_NOTIFY_EXTENDED_INFORMATION;
pub type PFILE_NOTIFY_EXTENDED_INFORMATION = *mut _FILE_NOTIFY_EXTENDED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _FILE_SEGMENT_ELEMENT {
    pub Buffer: *mut ::std::os::raw::c_void,
    pub Alignment: ULONGLONG,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__FILE_SEGMENT_ELEMENT() {
    assert_eq!(
        ::std::mem::size_of::<_FILE_SEGMENT_ELEMENT>(),
        8usize,
        concat!("Size of: ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILE_SEGMENT_ELEMENT>(),
        8usize,
        concat!("Alignment of ", stringify!(_FILE_SEGMENT_ELEMENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FILE_SEGMENT_ELEMENT>())).Buffer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FILE_SEGMENT_ELEMENT>())).Alignment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILE_SEGMENT_ELEMENT),
            "::",
            stringify!(Alignment)
        )
    );
}
pub type FILE_SEGMENT_ELEMENT = _FILE_SEGMENT_ELEMENT;
pub type PFILE_SEGMENT_ELEMENT = *mut _FILE_SEGMENT_ELEMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER {
    pub ReparseTag: DWORD,
    pub ReparseDataLength: WORD,
    pub Reserved: WORD,
    pub ReparseGuid: GUID,
    pub GenericReparseBuffer: _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REPARSE_GUID_DATA_BUFFER__bindgen_ty_1 {
    pub DataBuffer: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__REPARSE_GUID_DATA_BUFFER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1>())).DataBuffer
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER__bindgen_ty_1),
            "::",
            stringify!(DataBuffer)
        )
    );
}
#[test]
fn bindgen_test_layout__REPARSE_GUID_DATA_BUFFER() {
    assert_eq!(
        ::std::mem::size_of::<_REPARSE_GUID_DATA_BUFFER>(),
        28usize,
        concat!("Size of: ", stringify!(_REPARSE_GUID_DATA_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_REPARSE_GUID_DATA_BUFFER>(),
        4usize,
        concat!("Alignment of ", stringify!(_REPARSE_GUID_DATA_BUFFER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).ReparseTag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(ReparseTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).ReparseDataLength as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(ReparseDataLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).Reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).ReparseGuid as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(ReparseGuid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REPARSE_GUID_DATA_BUFFER>())).GenericReparseBuffer as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_REPARSE_GUID_DATA_BUFFER),
            "::",
            stringify!(GenericReparseBuffer)
        )
    );
}
pub type REPARSE_GUID_DATA_BUFFER = _REPARSE_GUID_DATA_BUFFER;
pub type PREPARSE_GUID_DATA_BUFFER = *mut _REPARSE_GUID_DATA_BUFFER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_INPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub MaximumIos: DWORD,
    pub ObjectId: [DWORD; 4usize],
    pub Reserved: [DWORD; 25usize],
    pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_INPUT() {
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_DATA_INPUT>(),
        944usize,
        concat!("Size of: ", stringify!(_SCRUB_DATA_INPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_DATA_INPUT>(),
        4usize,
        concat!("Alignment of ", stringify!(_SCRUB_DATA_INPUT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).MaximumIos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(MaximumIos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).ObjectId as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(ObjectId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).Reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_INPUT>())).ResumeContext as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_INPUT),
            "::",
            stringify!(ResumeContext)
        )
    );
}
pub type SCRUB_DATA_INPUT = _SCRUB_DATA_INPUT;
pub type PSCRUB_DATA_INPUT = *mut _SCRUB_DATA_INPUT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT {
    pub Offset: LONGLONG,
    pub Length: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT() {
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_PARITY_EXTENT>(),
        16usize,
        concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_PARITY_EXTENT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT>())).Offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT),
            "::",
            stringify!(Length)
        )
    );
}
pub type SCRUB_PARITY_EXTENT = _SCRUB_PARITY_EXTENT;
pub type PSCRUB_PARITY_EXTENT = *mut _SCRUB_PARITY_EXTENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SCRUB_PARITY_EXTENT_DATA {
    pub Size: WORD,
    pub Flags: WORD,
    pub NumberOfParityExtents: WORD,
    pub MaximumNumberOfParityExtents: WORD,
    pub ParityExtents: [SCRUB_PARITY_EXTENT; 1usize],
}
#[test]
fn bindgen_test_layout__SCRUB_PARITY_EXTENT_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_PARITY_EXTENT_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_PARITY_EXTENT_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_SCRUB_PARITY_EXTENT_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).Flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).NumberOfParityExtents as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(NumberOfParityExtents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).MaximumNumberOfParityExtents
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(MaximumNumberOfParityExtents)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_PARITY_EXTENT_DATA>())).ParityExtents as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_PARITY_EXTENT_DATA),
            "::",
            stringify!(ParityExtents)
        )
    );
}
pub type SCRUB_PARITY_EXTENT_DATA = _SCRUB_PARITY_EXTENT_DATA;
pub type PSCRUB_PARITY_EXTENT_DATA = *mut _SCRUB_PARITY_EXTENT_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _SCRUB_DATA_OUTPUT {
    pub Size: DWORD,
    pub Flags: DWORD,
    pub Status: DWORD,
    pub ErrorFileOffset: ULONGLONG,
    pub ErrorLength: ULONGLONG,
    pub NumberOfBytesRepaired: ULONGLONG,
    pub NumberOfBytesFailed: ULONGLONG,
    pub InternalFileReference: ULONGLONG,
    pub ResumeContextLength: WORD,
    pub ParityExtentDataOffset: WORD,
    pub Reserved: [DWORD; 9usize],
    pub NumberOfMetadataBytesProcessed: ULONGLONG,
    pub NumberOfDataBytesProcessed: ULONGLONG,
    pub TotalNumberOfMetadataBytesInUse: ULONGLONG,
    pub TotalNumberOfDataBytesInUse: ULONGLONG,
    pub ResumeContext: [BYTE; 816usize],
}
#[test]
fn bindgen_test_layout__SCRUB_DATA_OUTPUT() {
    assert_eq!(
        ::std::mem::size_of::<_SCRUB_DATA_OUTPUT>(),
        944usize,
        concat!("Size of: ", stringify!(_SCRUB_DATA_OUTPUT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SCRUB_DATA_OUTPUT>(),
        8usize,
        concat!("Alignment of ", stringify!(_SCRUB_DATA_OUTPUT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorFileOffset as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ErrorFileOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ErrorLength as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ErrorLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesRepaired as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfBytesRepaired)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfBytesFailed as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfBytesFailed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).InternalFileReference as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(InternalFileReference)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContextLength as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ResumeContextLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ParityExtentDataOffset as *const _
                as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ParityExtentDataOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).Reserved as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfMetadataBytesProcessed
                as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfMetadataBytesProcessed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).NumberOfDataBytesProcessed as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(NumberOfDataBytesProcessed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).TotalNumberOfMetadataBytesInUse
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(TotalNumberOfMetadataBytesInUse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).TotalNumberOfDataBytesInUse as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(TotalNumberOfDataBytesInUse)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SCRUB_DATA_OUTPUT>())).ResumeContext as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_SCRUB_DATA_OUTPUT),
            "::",
            stringify!(ResumeContext)
        )
    );
}
pub type SCRUB_DATA_OUTPUT = _SCRUB_DATA_OUTPUT;
pub type PSCRUB_DATA_OUTPUT = *mut _SCRUB_DATA_OUTPUT;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksUnsupported:
    _SharedVirtualDiskSupportType = 0;
pub const _SharedVirtualDiskSupportType_SharedVirtualDisksSupported: _SharedVirtualDiskSupportType =
    1;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskSnapshotsSupported:
    _SharedVirtualDiskSupportType = 3;
pub const _SharedVirtualDiskSupportType_SharedVirtualDiskCDPSnapshotsSupported:
    _SharedVirtualDiskSupportType = 7;
pub type _SharedVirtualDiskSupportType = i32;
pub use self::_SharedVirtualDiskSupportType as SharedVirtualDiskSupportType;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateNone:
    _SharedVirtualDiskHandleState = 0;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateFileShared:
    _SharedVirtualDiskHandleState = 1;
pub const _SharedVirtualDiskHandleState_SharedVirtualDiskHandleStateHandleShared:
    _SharedVirtualDiskHandleState = 3;
pub type _SharedVirtualDiskHandleState = i32;
pub use self::_SharedVirtualDiskHandleState as SharedVirtualDiskHandleState;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHARED_VIRTUAL_DISK_SUPPORT {
    pub SharedVirtualDiskSupport: SharedVirtualDiskSupportType,
    pub HandleState: SharedVirtualDiskHandleState,
}
#[test]
fn bindgen_test_layout__SHARED_VIRTUAL_DISK_SUPPORT() {
    assert_eq!(
        ::std::mem::size_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
        8usize,
        concat!("Size of: ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<_SHARED_VIRTUAL_DISK_SUPPORT>(),
        4usize,
        concat!("Alignment of ", stringify!(_SHARED_VIRTUAL_DISK_SUPPORT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).SharedVirtualDiskSupport
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
            "::",
            stringify!(SharedVirtualDiskSupport)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SHARED_VIRTUAL_DISK_SUPPORT>())).HandleState as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHARED_VIRTUAL_DISK_SUPPORT),
            "::",
            stringify!(HandleState)
        )
    );
}
pub type SHARED_VIRTUAL_DISK_SUPPORT = _SHARED_VIRTUAL_DISK_SUPPORT;
pub type PSHARED_VIRTUAL_DISK_SUPPORT = *mut _SHARED_VIRTUAL_DISK_SUPPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REARRANGE_FILE_DATA {
    pub SourceStartingOffset: ULONGLONG,
    pub TargetOffset: ULONGLONG,
    pub SourceFileHandle: HANDLE,
    pub Length: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__REARRANGE_FILE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_REARRANGE_FILE_DATA>(),
        32usize,
        concat!("Size of: ", stringify!(_REARRANGE_FILE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_REARRANGE_FILE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_REARRANGE_FILE_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REARRANGE_FILE_DATA>())).SourceStartingOffset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA),
            "::",
            stringify!(SourceStartingOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REARRANGE_FILE_DATA>())).TargetOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA),
            "::",
            stringify!(TargetOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REARRANGE_FILE_DATA>())).SourceFileHandle as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA),
            "::",
            stringify!(SourceFileHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_REARRANGE_FILE_DATA>())).Length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_REARRANGE_FILE_DATA>())).Flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA),
            "::",
            stringify!(Flags)
        )
    );
}
pub type REARRANGE_FILE_DATA = _REARRANGE_FILE_DATA;
pub type PREARRANGE_FILE_DATA = *mut _REARRANGE_FILE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _REARRANGE_FILE_DATA32 {
    pub SourceStartingOffset: ULONGLONG,
    pub TargetOffset: ULONGLONG,
    pub SourceFileHandle: UINT32,
    pub Length: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__REARRANGE_FILE_DATA32() {
    assert_eq!(
        ::std::mem::size_of::<_REARRANGE_FILE_DATA32>(),
        32usize,
        concat!("Size of: ", stringify!(_REARRANGE_FILE_DATA32))
    );
    assert_eq!(
        ::std::mem::align_of::<_REARRANGE_FILE_DATA32>(),
        8usize,
        concat!("Alignment of ", stringify!(_REARRANGE_FILE_DATA32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REARRANGE_FILE_DATA32>())).SourceStartingOffset as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA32),
            "::",
            stringify!(SourceStartingOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REARRANGE_FILE_DATA32>())).TargetOffset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA32),
            "::",
            stringify!(TargetOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_REARRANGE_FILE_DATA32>())).SourceFileHandle as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA32),
            "::",
            stringify!(SourceFileHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_REARRANGE_FILE_DATA32>())).Length as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA32),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_REARRANGE_FILE_DATA32>())).Flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_REARRANGE_FILE_DATA32),
            "::",
            stringify!(Flags)
        )
    );
}
pub type REARRANGE_FILE_DATA32 = _REARRANGE_FILE_DATA32;
pub type PREARRANGE_FILE_DATA32 = *mut _REARRANGE_FILE_DATA32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SHUFFLE_FILE_DATA {
    pub StartingOffset: LONGLONG,
    pub Length: LONGLONG,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__SHUFFLE_FILE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_SHUFFLE_FILE_DATA>(),
        24usize,
        concat!("Size of: ", stringify!(_SHUFFLE_FILE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_SHUFFLE_FILE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_SHUFFLE_FILE_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).StartingOffset as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHUFFLE_FILE_DATA),
            "::",
            stringify!(StartingOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHUFFLE_FILE_DATA),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SHUFFLE_FILE_DATA>())).Flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SHUFFLE_FILE_DATA),
            "::",
            stringify!(Flags)
        )
    );
}
pub type SHUFFLE_FILE_DATA = _SHUFFLE_FILE_DATA;
pub type PSHUFFLE_FILE_DATA = *mut _SHUFFLE_FILE_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NETWORK_APP_INSTANCE_EA {
    pub AppInstanceID: GUID,
    pub CsvFlags: DWORD,
}
#[test]
fn bindgen_test_layout__NETWORK_APP_INSTANCE_EA() {
    assert_eq!(
        ::std::mem::size_of::<_NETWORK_APP_INSTANCE_EA>(),
        20usize,
        concat!("Size of: ", stringify!(_NETWORK_APP_INSTANCE_EA))
    );
    assert_eq!(
        ::std::mem::align_of::<_NETWORK_APP_INSTANCE_EA>(),
        4usize,
        concat!("Alignment of ", stringify!(_NETWORK_APP_INSTANCE_EA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NETWORK_APP_INSTANCE_EA>())).AppInstanceID as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NETWORK_APP_INSTANCE_EA),
            "::",
            stringify!(AppInstanceID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_NETWORK_APP_INSTANCE_EA>())).CsvFlags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_NETWORK_APP_INSTANCE_EA),
            "::",
            stringify!(CsvFlags)
        )
    );
}
pub type NETWORK_APP_INSTANCE_EA = _NETWORK_APP_INSTANCE_EA;
pub type PNETWORK_APP_INSTANCE_EA = *mut _NETWORK_APP_INSTANCE_EA;
extern "C" {
    #[link_name = "\u{1}GUID_MAX_POWER_SAVINGS"]
    pub static GUID_MAX_POWER_SAVINGS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_MIN_POWER_SAVINGS"]
    pub static GUID_MIN_POWER_SAVINGS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_TYPICAL_POWER_SAVINGS"]
    pub static GUID_TYPICAL_POWER_SAVINGS: GUID;
}
extern "C" {
    #[link_name = "\u{1}NO_SUBGROUP_GUID"]
    pub static NO_SUBGROUP_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}ALL_POWERSCHEMES_GUID"]
    pub static ALL_POWERSCHEMES_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_POWERSCHEME_PERSONALITY"]
    pub static GUID_POWERSCHEME_PERSONALITY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ACTIVE_POWERSCHEME"]
    pub static GUID_ACTIVE_POWERSCHEME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_IDLE_RESILIENCY_SUBGROUP"]
    pub static GUID_IDLE_RESILIENCY_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_IDLE_RESILIENCY_PERIOD"]
    pub static GUID_IDLE_RESILIENCY_PERIOD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DEEP_SLEEP_ENABLED"]
    pub static GUID_DEEP_SLEEP_ENABLED: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DEEP_SLEEP_PLATFORM_STATE"]
    pub static GUID_DEEP_SLEEP_PLATFORM_STATE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_COALESCING_POWERDOWN_TIMEOUT"]
    pub static GUID_DISK_COALESCING_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT"]
    pub static GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_SUBGROUP"]
    pub static GUID_VIDEO_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_POWERDOWN_TIMEOUT"]
    pub static GUID_VIDEO_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_ANNOYANCE_TIMEOUT"]
    pub static GUID_VIDEO_ANNOYANCE_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE"]
    pub static GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_DIM_TIMEOUT"]
    pub static GUID_VIDEO_DIM_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_ADAPTIVE_POWERDOWN"]
    pub static GUID_VIDEO_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_MONITOR_POWER_ON"]
    pub static GUID_MONITOR_POWER_ON: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS"]
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS"]
    pub static GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS"]
    pub static GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS"]
    pub static GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_CONSOLE_DISPLAY_STATE"]
    pub static GUID_CONSOLE_DISPLAY_STATE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ALLOW_DISPLAY_REQUIRED"]
    pub static GUID_ALLOW_DISPLAY_REQUIRED: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_VIDEO_CONSOLE_LOCK_TIMEOUT"]
    pub static GUID_VIDEO_CONSOLE_LOCK_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ADVANCED_COLOR_QUALITY_BIAS"]
    pub static GUID_ADVANCED_COLOR_QUALITY_BIAS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP"]
    pub static GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_NON_ADAPTIVE_INPUT_TIMEOUT"]
    pub static GUID_NON_ADAPTIVE_INPUT_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ADAPTIVE_INPUT_CONTROLLER_STATE"]
    pub static GUID_ADAPTIVE_INPUT_CONTROLLER_STATE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_SUBGROUP"]
    pub static GUID_DISK_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_MAX_POWER"]
    pub static GUID_DISK_MAX_POWER: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_POWERDOWN_TIMEOUT"]
    pub static GUID_DISK_POWERDOWN_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_IDLE_TIMEOUT"]
    pub static GUID_DISK_IDLE_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_BURST_IGNORE_THRESHOLD"]
    pub static GUID_DISK_BURST_IGNORE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISK_ADAPTIVE_POWERDOWN"]
    pub static GUID_DISK_ADAPTIVE_POWERDOWN: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SLEEP_SUBGROUP"]
    pub static GUID_SLEEP_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SLEEP_IDLE_THRESHOLD"]
    pub static GUID_SLEEP_IDLE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_STANDBY_TIMEOUT"]
    pub static GUID_STANDBY_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_UNATTEND_SLEEP_TIMEOUT"]
    pub static GUID_UNATTEND_SLEEP_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_HIBERNATE_TIMEOUT"]
    pub static GUID_HIBERNATE_TIMEOUT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_HIBERNATE_FASTS4_POLICY"]
    pub static GUID_HIBERNATE_FASTS4_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_CRITICAL_POWER_TRANSITION"]
    pub static GUID_CRITICAL_POWER_TRANSITION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SYSTEM_AWAYMODE"]
    pub static GUID_SYSTEM_AWAYMODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ALLOW_AWAYMODE"]
    pub static GUID_ALLOW_AWAYMODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_USER_PRESENCE_PREDICTION"]
    pub static GUID_USER_PRESENCE_PREDICTION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_STANDBY_BUDGET_GRACE_PERIOD"]
    pub static GUID_STANDBY_BUDGET_GRACE_PERIOD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_STANDBY_BUDGET_PERCENT"]
    pub static GUID_STANDBY_BUDGET_PERCENT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_STANDBY_RESERVE_GRACE_PERIOD"]
    pub static GUID_STANDBY_RESERVE_GRACE_PERIOD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_STANDBY_RESERVE_TIME"]
    pub static GUID_STANDBY_RESERVE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_STANDBY_RESET_PERCENT"]
    pub static GUID_STANDBY_RESET_PERCENT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ALLOW_STANDBY_STATES"]
    pub static GUID_ALLOW_STANDBY_STATES: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ALLOW_RTC_WAKE"]
    pub static GUID_ALLOW_RTC_WAKE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_LEGACY_RTC_MITIGATION"]
    pub static GUID_LEGACY_RTC_MITIGATION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ALLOW_SYSTEM_REQUIRED"]
    pub static GUID_ALLOW_SYSTEM_REQUIRED: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_POWER_SAVING_STATUS"]
    pub static GUID_POWER_SAVING_STATUS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ENERGY_SAVER_SUBGROUP"]
    pub static GUID_ENERGY_SAVER_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ENERGY_SAVER_BATTERY_THRESHOLD"]
    pub static GUID_ENERGY_SAVER_BATTERY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ENERGY_SAVER_BRIGHTNESS"]
    pub static GUID_ENERGY_SAVER_BRIGHTNESS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ENERGY_SAVER_POLICY"]
    pub static GUID_ENERGY_SAVER_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SYSTEM_BUTTON_SUBGROUP"]
    pub static GUID_SYSTEM_BUTTON_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_POWERBUTTON_ACTION"]
    pub static GUID_POWERBUTTON_ACTION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SLEEPBUTTON_ACTION"]
    pub static GUID_SLEEPBUTTON_ACTION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_USERINTERFACEBUTTON_ACTION"]
    pub static GUID_USERINTERFACEBUTTON_ACTION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_LIDCLOSE_ACTION"]
    pub static GUID_LIDCLOSE_ACTION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_LIDOPEN_POWERSTATE"]
    pub static GUID_LIDOPEN_POWERSTATE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_SUBGROUP"]
    pub static GUID_BATTERY_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_0"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_0: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_0"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_0: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_0"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_0: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_1"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_1"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_1"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_2"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_2: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_2"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_2: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_2"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_2: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_ACTION_3"]
    pub static GUID_BATTERY_DISCHARGE_ACTION_3: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_LEVEL_3"]
    pub static GUID_BATTERY_DISCHARGE_LEVEL_3: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_DISCHARGE_FLAGS_3"]
    pub static GUID_BATTERY_DISCHARGE_FLAGS_3: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_SETTINGS_SUBGROUP"]
    pub static GUID_PROCESSOR_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_POLICY"]
    pub static GUID_PROCESSOR_THROTTLE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MAXIMUM"]
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MAXIMUM_1"]
    pub static GUID_PROCESSOR_THROTTLE_MAXIMUM_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MINIMUM"]
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_THROTTLE_MINIMUM_1"]
    pub static GUID_PROCESSOR_THROTTLE_MINIMUM_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_FREQUENCY_LIMIT"]
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_FREQUENCY_LIMIT_1"]
    pub static GUID_PROCESSOR_FREQUENCY_LIMIT_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_ALLOW_THROTTLING"]
    pub static GUID_PROCESSOR_ALLOW_THROTTLING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLESTATE_POLICY"]
    pub static GUID_PROCESSOR_IDLESTATE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERFSTATE_POLICY"]
    pub static GUID_PROCESSOR_PERFSTATE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1"]
    pub static GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1"]
    pub static GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_POLICY"]
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_POLICY_1"]
    pub static GUID_PROCESSOR_PERF_INCREASE_POLICY_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_POLICY"]
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_POLICY_1"]
    pub static GUID_PROCESSOR_PERF_DECREASE_POLICY_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_TIME"]
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_TIME_1"]
    pub static GUID_PROCESSOR_PERF_INCREASE_TIME_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_TIME"]
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_TIME_1"]
    pub static GUID_PROCESSOR_PERF_DECREASE_TIME_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_TIME_CHECK"]
    pub static GUID_PROCESSOR_PERF_TIME_CHECK: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_BOOST_POLICY"]
    pub static GUID_PROCESSOR_PERF_BOOST_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_BOOST_MODE"]
    pub static GUID_PROCESSOR_PERF_BOOST_MODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_AUTONOMOUS_MODE"]
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_MODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE"]
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1"]
    pub static GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW"]
    pub static GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_DUTY_CYCLING"]
    pub static GUID_PROCESSOR_DUTY_CYCLING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLE_ALLOW_SCALING"]
    pub static GUID_PROCESSOR_IDLE_ALLOW_SCALING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLE_DISABLE"]
    pub static GUID_PROCESSOR_IDLE_DISABLE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLE_STATE_MAXIMUM"]
    pub static GUID_PROCESSOR_IDLE_STATE_MAXIMUM: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLE_TIME_CHECK"]
    pub static GUID_PROCESSOR_IDLE_TIME_CHECK: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD"]
    pub static GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD"]
    pub static GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY"]
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY"]
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MAX_CORES"]
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1"]
    pub static GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MIN_CORES"]
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1"]
    pub static GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME"]
    pub static GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME"]
    pub static GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR"]
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING"]
    pub static GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD"]
    pub static GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PARKING_CORE_OVERRIDE"]
    pub static GUID_PROCESSOR_PARKING_CORE_OVERRIDE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PARKING_PERF_STATE"]
    pub static GUID_PROCESSOR_PARKING_PERF_STATE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PARKING_PERF_STATE_1"]
    pub static GUID_PROCESSOR_PARKING_PERF_STATE_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD"]
    pub static GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD"]
    pub static GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD"]
    pub static GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_HISTORY"]
    pub static GUID_PROCESSOR_PERF_HISTORY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_HISTORY_1"]
    pub static GUID_PROCESSOR_PERF_HISTORY_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_INCREASE_HISTORY"]
    pub static GUID_PROCESSOR_PERF_INCREASE_HISTORY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_DECREASE_HISTORY"]
    pub static GUID_PROCESSOR_PERF_DECREASE_HISTORY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY"]
    pub static GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT"]
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT_PERF"]
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1"]
    pub static GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK"]
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1"]
    pub static GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_DISTRIBUTE_UTILITY"]
    pub static GUID_PROCESSOR_DISTRIBUTE_UTILITY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_HETEROGENEOUS_POLICY"]
    pub static GUID_PROCESSOR_HETEROGENEOUS_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_HETERO_DECREASE_TIME"]
    pub static GUID_PROCESSOR_HETERO_DECREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_HETERO_INCREASE_TIME"]
    pub static GUID_PROCESSOR_HETERO_INCREASE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD"]
    pub static GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CLASS0_FLOOR_PERF"]
    pub static GUID_PROCESSOR_CLASS0_FLOOR_PERF: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_CLASS1_INITIAL_PERF"]
    pub static GUID_PROCESSOR_CLASS1_INITIAL_PERF: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_THREAD_SCHEDULING_POLICY"]
    pub static GUID_PROCESSOR_THREAD_SCHEDULING_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY"]
    pub static GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SYSTEM_COOLING_POLICY"]
    pub static GUID_SYSTEM_COOLING_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1"]
    pub static GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_LOCK_CONSOLE_ON_WAKE"]
    pub static GUID_LOCK_CONSOLE_ON_WAKE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DEVICE_IDLE_POLICY"]
    pub static GUID_DEVICE_IDLE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_CONNECTIVITY_IN_STANDBY"]
    pub static GUID_CONNECTIVITY_IN_STANDBY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_DISCONNECTED_STANDBY_MODE"]
    pub static GUID_DISCONNECTED_STANDBY_MODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ACDC_POWER_SOURCE"]
    pub static GUID_ACDC_POWER_SOURCE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_LIDSWITCH_STATE_CHANGE"]
    pub static GUID_LIDSWITCH_STATE_CHANGE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_PERCENTAGE_REMAINING"]
    pub static GUID_BATTERY_PERCENTAGE_REMAINING: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BATTERY_COUNT"]
    pub static GUID_BATTERY_COUNT: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_GLOBAL_USER_PRESENCE"]
    pub static GUID_GLOBAL_USER_PRESENCE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SESSION_DISPLAY_STATUS"]
    pub static GUID_SESSION_DISPLAY_STATUS: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SESSION_USER_PRESENCE"]
    pub static GUID_SESSION_USER_PRESENCE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_IDLE_BACKGROUND_TASK"]
    pub static GUID_IDLE_BACKGROUND_TASK: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_BACKGROUND_TASK_NOTIFICATION"]
    pub static GUID_BACKGROUND_TASK_NOTIFICATION: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_APPLAUNCH_BUTTON"]
    pub static GUID_APPLAUNCH_BUTTON: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PCIEXPRESS_SETTINGS_SUBGROUP"]
    pub static GUID_PCIEXPRESS_SETTINGS_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_PCIEXPRESS_ASPM_POLICY"]
    pub static GUID_PCIEXPRESS_ASPM_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_ENABLE_SWITCH_FORCED_SHUTDOWN"]
    pub static GUID_ENABLE_SWITCH_FORCED_SHUTDOWN: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_INTSTEER_SUBGROUP"]
    pub static GUID_INTSTEER_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_INTSTEER_MODE"]
    pub static GUID_INTSTEER_MODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_INTSTEER_LOAD_PER_PROC_TRIGGER"]
    pub static GUID_INTSTEER_LOAD_PER_PROC_TRIGGER: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_INTSTEER_TIME_UNPARK_TRIGGER"]
    pub static GUID_INTSTEER_TIME_UNPARK_TRIGGER: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_GRAPHICS_SUBGROUP"]
    pub static GUID_GRAPHICS_SUBGROUP: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_GPU_PREFERENCE_POLICY"]
    pub static GUID_GPU_PREFERENCE_POLICY: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_MIXED_REALITY_MODE"]
    pub static GUID_MIXED_REALITY_MODE: GUID;
}
extern "C" {
    #[link_name = "\u{1}GUID_SPR_ACTIVE_SESSION_CHANGE"]
    pub static GUID_SPR_ACTIVE_SESSION_CHANGE: GUID;
}
pub const _SYSTEM_POWER_STATE_PowerSystemUnspecified: _SYSTEM_POWER_STATE = 0;
pub const _SYSTEM_POWER_STATE_PowerSystemWorking: _SYSTEM_POWER_STATE = 1;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping1: _SYSTEM_POWER_STATE = 2;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping2: _SYSTEM_POWER_STATE = 3;
pub const _SYSTEM_POWER_STATE_PowerSystemSleeping3: _SYSTEM_POWER_STATE = 4;
pub const _SYSTEM_POWER_STATE_PowerSystemHibernate: _SYSTEM_POWER_STATE = 5;
pub const _SYSTEM_POWER_STATE_PowerSystemShutdown: _SYSTEM_POWER_STATE = 6;
pub const _SYSTEM_POWER_STATE_PowerSystemMaximum: _SYSTEM_POWER_STATE = 7;
pub type _SYSTEM_POWER_STATE = i32;
pub use self::_SYSTEM_POWER_STATE as SYSTEM_POWER_STATE;
pub type PSYSTEM_POWER_STATE = *mut _SYSTEM_POWER_STATE;
pub const POWER_ACTION_PowerActionNone: POWER_ACTION = 0;
pub const POWER_ACTION_PowerActionReserved: POWER_ACTION = 1;
pub const POWER_ACTION_PowerActionSleep: POWER_ACTION = 2;
pub const POWER_ACTION_PowerActionHibernate: POWER_ACTION = 3;
pub const POWER_ACTION_PowerActionShutdown: POWER_ACTION = 4;
pub const POWER_ACTION_PowerActionShutdownReset: POWER_ACTION = 5;
pub const POWER_ACTION_PowerActionShutdownOff: POWER_ACTION = 6;
pub const POWER_ACTION_PowerActionWarmEject: POWER_ACTION = 7;
pub const POWER_ACTION_PowerActionDisplayOff: POWER_ACTION = 8;
pub type POWER_ACTION = i32;
pub type PPOWER_ACTION = *mut POWER_ACTION;
pub const _DEVICE_POWER_STATE_PowerDeviceUnspecified: _DEVICE_POWER_STATE = 0;
pub const _DEVICE_POWER_STATE_PowerDeviceD0: _DEVICE_POWER_STATE = 1;
pub const _DEVICE_POWER_STATE_PowerDeviceD1: _DEVICE_POWER_STATE = 2;
pub const _DEVICE_POWER_STATE_PowerDeviceD2: _DEVICE_POWER_STATE = 3;
pub const _DEVICE_POWER_STATE_PowerDeviceD3: _DEVICE_POWER_STATE = 4;
pub const _DEVICE_POWER_STATE_PowerDeviceMaximum: _DEVICE_POWER_STATE = 5;
pub type _DEVICE_POWER_STATE = i32;
pub use self::_DEVICE_POWER_STATE as DEVICE_POWER_STATE;
pub type PDEVICE_POWER_STATE = *mut _DEVICE_POWER_STATE;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOff: _MONITOR_DISPLAY_STATE = 0;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorOn: _MONITOR_DISPLAY_STATE = 1;
pub const _MONITOR_DISPLAY_STATE_PowerMonitorDim: _MONITOR_DISPLAY_STATE = 2;
pub type _MONITOR_DISPLAY_STATE = i32;
pub use self::_MONITOR_DISPLAY_STATE as MONITOR_DISPLAY_STATE;
pub type PMONITOR_DISPLAY_STATE = *mut _MONITOR_DISPLAY_STATE;
pub const _USER_ACTIVITY_PRESENCE_PowerUserPresent: _USER_ACTIVITY_PRESENCE = 0;
pub const _USER_ACTIVITY_PRESENCE_PowerUserNotPresent: _USER_ACTIVITY_PRESENCE = 1;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInactive: _USER_ACTIVITY_PRESENCE = 2;
pub const _USER_ACTIVITY_PRESENCE_PowerUserMaximum: _USER_ACTIVITY_PRESENCE = 3;
pub const _USER_ACTIVITY_PRESENCE_PowerUserInvalid: _USER_ACTIVITY_PRESENCE = 3;
pub type _USER_ACTIVITY_PRESENCE = i32;
pub use self::_USER_ACTIVITY_PRESENCE as USER_ACTIVITY_PRESENCE;
pub type PUSER_ACTIVITY_PRESENCE = *mut _USER_ACTIVITY_PRESENCE;
pub type EXECUTION_STATE = DWORD;
pub type PEXECUTION_STATE = *mut DWORD;
pub const LATENCY_TIME_LT_DONT_CARE: LATENCY_TIME = 0;
pub const LATENCY_TIME_LT_LOWEST_LATENCY: LATENCY_TIME = 1;
pub type LATENCY_TIME = i32;
pub const _POWER_REQUEST_TYPE_PowerRequestDisplayRequired: _POWER_REQUEST_TYPE = 0;
pub const _POWER_REQUEST_TYPE_PowerRequestSystemRequired: _POWER_REQUEST_TYPE = 1;
pub const _POWER_REQUEST_TYPE_PowerRequestAwayModeRequired: _POWER_REQUEST_TYPE = 2;
pub const _POWER_REQUEST_TYPE_PowerRequestExecutionRequired: _POWER_REQUEST_TYPE = 3;
pub type _POWER_REQUEST_TYPE = i32;
pub use self::_POWER_REQUEST_TYPE as POWER_REQUEST_TYPE;
pub type PPOWER_REQUEST_TYPE = *mut _POWER_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CM_Power_Data_s {
    pub PD_Size: DWORD,
    pub PD_MostRecentPowerState: DEVICE_POWER_STATE,
    pub PD_Capabilities: DWORD,
    pub PD_D1Latency: DWORD,
    pub PD_D2Latency: DWORD,
    pub PD_D3Latency: DWORD,
    pub PD_PowerStateMapping: [DEVICE_POWER_STATE; 7usize],
    pub PD_DeepestSystemWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_CM_Power_Data_s() {
    assert_eq!(
        ::std::mem::size_of::<CM_Power_Data_s>(),
        56usize,
        concat!("Size of: ", stringify!(CM_Power_Data_s))
    );
    assert_eq!(
        ::std::mem::align_of::<CM_Power_Data_s>(),
        4usize,
        concat!("Alignment of ", stringify!(CM_Power_Data_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_MostRecentPowerState as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_MostRecentPowerState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_Capabilities as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_Capabilities)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_D1Latency as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_D1Latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_D2Latency as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_D2Latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_D3Latency as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_D3Latency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_PowerStateMapping as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_PowerStateMapping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CM_Power_Data_s>())).PD_DeepestSystemWake as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(CM_Power_Data_s),
            "::",
            stringify!(PD_DeepestSystemWake)
        )
    );
}
pub type CM_POWER_DATA = CM_Power_Data_s;
pub type PCM_POWER_DATA = *mut CM_Power_Data_s;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyAc: POWER_INFORMATION_LEVEL = 0;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyDc: POWER_INFORMATION_LEVEL = 1;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyAc: POWER_INFORMATION_LEVEL = 2;
pub const POWER_INFORMATION_LEVEL_VerifySystemPolicyDc: POWER_INFORMATION_LEVEL = 3;
pub const POWER_INFORMATION_LEVEL_SystemPowerCapabilities: POWER_INFORMATION_LEVEL = 4;
pub const POWER_INFORMATION_LEVEL_SystemBatteryState: POWER_INFORMATION_LEVEL = 5;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateHandler: POWER_INFORMATION_LEVEL = 6;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler: POWER_INFORMATION_LEVEL = 7;
pub const POWER_INFORMATION_LEVEL_SystemPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 8;
pub const POWER_INFORMATION_LEVEL_AdministratorPowerPolicy: POWER_INFORMATION_LEVEL = 9;
pub const POWER_INFORMATION_LEVEL_SystemReserveHiberFile: POWER_INFORMATION_LEVEL = 10;
pub const POWER_INFORMATION_LEVEL_ProcessorInformation: POWER_INFORMATION_LEVEL = 11;
pub const POWER_INFORMATION_LEVEL_SystemPowerInformation: POWER_INFORMATION_LEVEL = 12;
pub const POWER_INFORMATION_LEVEL_ProcessorStateHandler2: POWER_INFORMATION_LEVEL = 13;
pub const POWER_INFORMATION_LEVEL_LastWakeTime: POWER_INFORMATION_LEVEL = 14;
pub const POWER_INFORMATION_LEVEL_LastSleepTime: POWER_INFORMATION_LEVEL = 15;
pub const POWER_INFORMATION_LEVEL_SystemExecutionState: POWER_INFORMATION_LEVEL = 16;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateNotifyHandler: POWER_INFORMATION_LEVEL = 17;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 18;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 19;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyAc: POWER_INFORMATION_LEVEL = 20;
pub const POWER_INFORMATION_LEVEL_VerifyProcessorPowerPolicyDc: POWER_INFORMATION_LEVEL = 21;
pub const POWER_INFORMATION_LEVEL_ProcessorPowerPolicyCurrent: POWER_INFORMATION_LEVEL = 22;
pub const POWER_INFORMATION_LEVEL_SystemPowerStateLogging: POWER_INFORMATION_LEVEL = 23;
pub const POWER_INFORMATION_LEVEL_SystemPowerLoggingEntry: POWER_INFORMATION_LEVEL = 24;
pub const POWER_INFORMATION_LEVEL_SetPowerSettingValue: POWER_INFORMATION_LEVEL = 25;
pub const POWER_INFORMATION_LEVEL_NotifyUserPowerSetting: POWER_INFORMATION_LEVEL = 26;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelUnused0: POWER_INFORMATION_LEVEL = 27;
pub const POWER_INFORMATION_LEVEL_SystemMonitorHiberBootPowerOff: POWER_INFORMATION_LEVEL = 28;
pub const POWER_INFORMATION_LEVEL_SystemVideoState: POWER_INFORMATION_LEVEL = 29;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessage: POWER_INFORMATION_LEVEL = 30;
pub const POWER_INFORMATION_LEVEL_TraceApplicationPowerMessageEnd: POWER_INFORMATION_LEVEL = 31;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStates: POWER_INFORMATION_LEVEL = 32;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStates: POWER_INFORMATION_LEVEL = 33;
pub const POWER_INFORMATION_LEVEL_ProcessorCap: POWER_INFORMATION_LEVEL = 34;
pub const POWER_INFORMATION_LEVEL_SystemWakeSource: POWER_INFORMATION_LEVEL = 35;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileInformation: POWER_INFORMATION_LEVEL = 36;
pub const POWER_INFORMATION_LEVEL_TraceServicePowerMessage: POWER_INFORMATION_LEVEL = 37;
pub const POWER_INFORMATION_LEVEL_ProcessorLoad: POWER_INFORMATION_LEVEL = 38;
pub const POWER_INFORMATION_LEVEL_PowerShutdownNotification: POWER_INFORMATION_LEVEL = 39;
pub const POWER_INFORMATION_LEVEL_MonitorCapabilities: POWER_INFORMATION_LEVEL = 40;
pub const POWER_INFORMATION_LEVEL_SessionPowerInit: POWER_INFORMATION_LEVEL = 41;
pub const POWER_INFORMATION_LEVEL_SessionDisplayState: POWER_INFORMATION_LEVEL = 42;
pub const POWER_INFORMATION_LEVEL_PowerRequestCreate: POWER_INFORMATION_LEVEL = 43;
pub const POWER_INFORMATION_LEVEL_PowerRequestAction: POWER_INFORMATION_LEVEL = 44;
pub const POWER_INFORMATION_LEVEL_GetPowerRequestList: POWER_INFORMATION_LEVEL = 45;
pub const POWER_INFORMATION_LEVEL_ProcessorInformationEx: POWER_INFORMATION_LEVEL = 46;
pub const POWER_INFORMATION_LEVEL_NotifyUserModeLegacyPowerEvent: POWER_INFORMATION_LEVEL = 47;
pub const POWER_INFORMATION_LEVEL_GroupPark: POWER_INFORMATION_LEVEL = 48;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleDomains: POWER_INFORMATION_LEVEL = 49;
pub const POWER_INFORMATION_LEVEL_WakeTimerList: POWER_INFORMATION_LEVEL = 50;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileSize: POWER_INFORMATION_LEVEL = 51;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleStatesHv: POWER_INFORMATION_LEVEL = 52;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfStatesHv: POWER_INFORMATION_LEVEL = 53;
pub const POWER_INFORMATION_LEVEL_ProcessorPerfCapHv: POWER_INFORMATION_LEVEL = 54;
pub const POWER_INFORMATION_LEVEL_ProcessorSetIdle: POWER_INFORMATION_LEVEL = 55;
pub const POWER_INFORMATION_LEVEL_LogicalProcessorIdling: POWER_INFORMATION_LEVEL = 56;
pub const POWER_INFORMATION_LEVEL_UserPresence: POWER_INFORMATION_LEVEL = 57;
pub const POWER_INFORMATION_LEVEL_PowerSettingNotificationName: POWER_INFORMATION_LEVEL = 58;
pub const POWER_INFORMATION_LEVEL_GetPowerSettingValue: POWER_INFORMATION_LEVEL = 59;
pub const POWER_INFORMATION_LEVEL_IdleResiliency: POWER_INFORMATION_LEVEL = 60;
pub const POWER_INFORMATION_LEVEL_SessionRITState: POWER_INFORMATION_LEVEL = 61;
pub const POWER_INFORMATION_LEVEL_SessionConnectNotification: POWER_INFORMATION_LEVEL = 62;
pub const POWER_INFORMATION_LEVEL_SessionPowerCleanup: POWER_INFORMATION_LEVEL = 63;
pub const POWER_INFORMATION_LEVEL_SessionLockState: POWER_INFORMATION_LEVEL = 64;
pub const POWER_INFORMATION_LEVEL_SystemHiberbootState: POWER_INFORMATION_LEVEL = 65;
pub const POWER_INFORMATION_LEVEL_PlatformInformation: POWER_INFORMATION_LEVEL = 66;
pub const POWER_INFORMATION_LEVEL_PdcInvocation: POWER_INFORMATION_LEVEL = 67;
pub const POWER_INFORMATION_LEVEL_MonitorInvocation: POWER_INFORMATION_LEVEL = 68;
pub const POWER_INFORMATION_LEVEL_FirmwareTableInformationRegistered: POWER_INFORMATION_LEVEL = 69;
pub const POWER_INFORMATION_LEVEL_SetShutdownSelectedTime: POWER_INFORMATION_LEVEL = 70;
pub const POWER_INFORMATION_LEVEL_SuspendResumeInvocation: POWER_INFORMATION_LEVEL = 71;
pub const POWER_INFORMATION_LEVEL_PlmPowerRequestCreate: POWER_INFORMATION_LEVEL = 72;
pub const POWER_INFORMATION_LEVEL_ScreenOff: POWER_INFORMATION_LEVEL = 73;
pub const POWER_INFORMATION_LEVEL_CsDeviceNotification: POWER_INFORMATION_LEVEL = 74;
pub const POWER_INFORMATION_LEVEL_PlatformRole: POWER_INFORMATION_LEVEL = 75;
pub const POWER_INFORMATION_LEVEL_LastResumePerformance: POWER_INFORMATION_LEVEL = 76;
pub const POWER_INFORMATION_LEVEL_DisplayBurst: POWER_INFORMATION_LEVEL = 77;
pub const POWER_INFORMATION_LEVEL_ExitLatencySamplingPercentage: POWER_INFORMATION_LEVEL = 78;
pub const POWER_INFORMATION_LEVEL_RegisterSpmPowerSettings: POWER_INFORMATION_LEVEL = 79;
pub const POWER_INFORMATION_LEVEL_PlatformIdleStates: POWER_INFORMATION_LEVEL = 80;
pub const POWER_INFORMATION_LEVEL_ProcessorIdleVeto: POWER_INFORMATION_LEVEL = 81;
pub const POWER_INFORMATION_LEVEL_PlatformIdleVeto: POWER_INFORMATION_LEVEL = 82;
pub const POWER_INFORMATION_LEVEL_SystemBatteryStatePrecise: POWER_INFORMATION_LEVEL = 83;
pub const POWER_INFORMATION_LEVEL_ThermalEvent: POWER_INFORMATION_LEVEL = 84;
pub const POWER_INFORMATION_LEVEL_PowerRequestActionInternal: POWER_INFORMATION_LEVEL = 85;
pub const POWER_INFORMATION_LEVEL_BatteryDeviceState: POWER_INFORMATION_LEVEL = 86;
pub const POWER_INFORMATION_LEVEL_PowerInformationInternal: POWER_INFORMATION_LEVEL = 87;
pub const POWER_INFORMATION_LEVEL_ThermalStandby: POWER_INFORMATION_LEVEL = 88;
pub const POWER_INFORMATION_LEVEL_SystemHiberFileType: POWER_INFORMATION_LEVEL = 89;
pub const POWER_INFORMATION_LEVEL_PhysicalPowerButtonPress: POWER_INFORMATION_LEVEL = 90;
pub const POWER_INFORMATION_LEVEL_QueryPotentialDripsConstraint: POWER_INFORMATION_LEVEL = 91;
pub const POWER_INFORMATION_LEVEL_EnergyTrackerCreate: POWER_INFORMATION_LEVEL = 92;
pub const POWER_INFORMATION_LEVEL_EnergyTrackerQuery: POWER_INFORMATION_LEVEL = 93;
pub const POWER_INFORMATION_LEVEL_UpdateBlackBoxRecorder: POWER_INFORMATION_LEVEL = 94;
pub const POWER_INFORMATION_LEVEL_PowerInformationLevelMaximum: POWER_INFORMATION_LEVEL = 95;
pub type POWER_INFORMATION_LEVEL = i32;
pub const POWER_USER_PRESENCE_TYPE_UserNotPresent: POWER_USER_PRESENCE_TYPE = 0;
pub const POWER_USER_PRESENCE_TYPE_UserPresent: POWER_USER_PRESENCE_TYPE = 1;
pub const POWER_USER_PRESENCE_TYPE_UserUnknown: POWER_USER_PRESENCE_TYPE = 255;
pub type POWER_USER_PRESENCE_TYPE = i32;
pub type PPOWER_USER_PRESENCE_TYPE = *mut POWER_USER_PRESENCE_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_USER_PRESENCE {
    pub UserPresence: POWER_USER_PRESENCE_TYPE,
}
#[test]
fn bindgen_test_layout__POWER_USER_PRESENCE() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_USER_PRESENCE>(),
        4usize,
        concat!("Size of: ", stringify!(_POWER_USER_PRESENCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_USER_PRESENCE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_USER_PRESENCE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_USER_PRESENCE>())).UserPresence as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_USER_PRESENCE),
            "::",
            stringify!(UserPresence)
        )
    );
}
pub type POWER_USER_PRESENCE = _POWER_USER_PRESENCE;
pub type PPOWER_USER_PRESENCE = *mut _POWER_USER_PRESENCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_CONNECT {
    pub Connected: BOOLEAN,
    pub Console: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_CONNECT() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_CONNECT>(),
        2usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_CONNECT))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_CONNECT>(),
        1usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_CONNECT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_SESSION_CONNECT>())).Connected as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_CONNECT),
            "::",
            stringify!(Connected)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_POWER_SESSION_CONNECT>())).Console as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_CONNECT),
            "::",
            stringify!(Console)
        )
    );
}
pub type POWER_SESSION_CONNECT = _POWER_SESSION_CONNECT;
pub type PPOWER_SESSION_CONNECT = *mut _POWER_SESSION_CONNECT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_TIMEOUTS {
    pub InputTimeout: DWORD,
    pub DisplayTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_TIMEOUTS() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_TIMEOUTS>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_TIMEOUTS))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_TIMEOUTS>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_TIMEOUTS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_SESSION_TIMEOUTS>())).InputTimeout as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_TIMEOUTS),
            "::",
            stringify!(InputTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_SESSION_TIMEOUTS>())).DisplayTimeout as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_TIMEOUTS),
            "::",
            stringify!(DisplayTimeout)
        )
    );
}
pub type POWER_SESSION_TIMEOUTS = _POWER_SESSION_TIMEOUTS;
pub type PPOWER_SESSION_TIMEOUTS = *mut _POWER_SESSION_TIMEOUTS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_RIT_STATE {
    pub Active: BOOLEAN,
    pub LastInputTime: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_RIT_STATE() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_RIT_STATE>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_RIT_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_RIT_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_RIT_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_POWER_SESSION_RIT_STATE>())).Active as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_RIT_STATE),
            "::",
            stringify!(Active)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_SESSION_RIT_STATE>())).LastInputTime as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_RIT_STATE),
            "::",
            stringify!(LastInputTime)
        )
    );
}
pub type POWER_SESSION_RIT_STATE = _POWER_SESSION_RIT_STATE;
pub type PPOWER_SESSION_RIT_STATE = *mut _POWER_SESSION_RIT_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_SESSION_WINLOGON {
    pub SessionId: DWORD,
    pub Console: BOOLEAN,
    pub Locked: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_SESSION_WINLOGON() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_SESSION_WINLOGON>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_SESSION_WINLOGON))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_SESSION_WINLOGON>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_SESSION_WINLOGON))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_SESSION_WINLOGON>())).SessionId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_WINLOGON),
            "::",
            stringify!(SessionId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_POWER_SESSION_WINLOGON>())).Console as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_WINLOGON),
            "::",
            stringify!(Console)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_POWER_SESSION_WINLOGON>())).Locked as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_SESSION_WINLOGON),
            "::",
            stringify!(Locked)
        )
    );
}
pub type POWER_SESSION_WINLOGON = _POWER_SESSION_WINLOGON;
pub type PPOWER_SESSION_WINLOGON = *mut _POWER_SESSION_WINLOGON;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_IDLE_RESILIENCY {
    pub CoalescingTimeout: DWORD,
    pub IdleResiliencyPeriod: DWORD,
}
#[test]
fn bindgen_test_layout__POWER_IDLE_RESILIENCY() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_IDLE_RESILIENCY>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_IDLE_RESILIENCY))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_IDLE_RESILIENCY>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_IDLE_RESILIENCY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_IDLE_RESILIENCY>())).CoalescingTimeout as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_IDLE_RESILIENCY),
            "::",
            stringify!(CoalescingTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_IDLE_RESILIENCY>())).IdleResiliencyPeriod as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_IDLE_RESILIENCY),
            "::",
            stringify!(IdleResiliencyPeriod)
        )
    );
}
pub type POWER_IDLE_RESILIENCY = _POWER_IDLE_RESILIENCY;
pub type PPOWER_IDLE_RESILIENCY = *mut _POWER_IDLE_RESILIENCY;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUnknown: POWER_MONITOR_REQUEST_REASON =
    0;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPowerButton:
    POWER_MONITOR_REQUEST_REASON = 1;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonRemoteConnection:
    POWER_MONITOR_REQUEST_REASON = 2;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScMonitorpower:
    POWER_MONITOR_REQUEST_REASON = 3;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInput: POWER_MONITOR_REQUEST_REASON =
    4;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurst:
    POWER_MONITOR_REQUEST_REASON = 5;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserDisplayBurst:
    POWER_MONITOR_REQUEST_REASON = 6;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPoSetSystemState:
    POWER_MONITOR_REQUEST_REASON = 7;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSetThreadExecutionState:
    POWER_MONITOR_REQUEST_REASON = 8;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonFullWake: POWER_MONITOR_REQUEST_REASON =
    9;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSessionUnlock:
    POWER_MONITOR_REQUEST_REASON = 10;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonScreenOffRequest:
    POWER_MONITOR_REQUEST_REASON = 11;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonIdleTimeout:
    POWER_MONITOR_REQUEST_REASON = 12;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPolicyChange:
    POWER_MONITOR_REQUEST_REASON = 13;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSleepButton:
    POWER_MONITOR_REQUEST_REASON = 14;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonLid: POWER_MONITOR_REQUEST_REASON = 15;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonBatteryCountChange:
    POWER_MONITOR_REQUEST_REASON = 16;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonGracePeriod:
    POWER_MONITOR_REQUEST_REASON = 17;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPnP: POWER_MONITOR_REQUEST_REASON = 18;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDP: POWER_MONITOR_REQUEST_REASON = 19;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSxTransition:
    POWER_MONITOR_REQUEST_REASON = 20;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemIdle:
    POWER_MONITOR_REQUEST_REASON = 21;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonNearProximity:
    POWER_MONITOR_REQUEST_REASON = 22;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonThermalStandby:
    POWER_MONITOR_REQUEST_REASON = 23;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumePdc: POWER_MONITOR_REQUEST_REASON =
    24;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonResumeS4: POWER_MONITOR_REQUEST_REASON =
    25;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonTerminal: POWER_MONITOR_REQUEST_REASON =
    26;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignal: POWER_MONITOR_REQUEST_REASON =
    27;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonAcDcDisplayBurstSuppressed:
    POWER_MONITOR_REQUEST_REASON = 28;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonSystemStateEntered:
    POWER_MONITOR_REQUEST_REASON = 29;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonWinrt: POWER_MONITOR_REQUEST_REASON = 30;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputKeyboard:
    POWER_MONITOR_REQUEST_REASON = 31;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputMouse:
    POWER_MONITOR_REQUEST_REASON = 32;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputTouch:
    POWER_MONITOR_REQUEST_REASON = 33;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPen:
    POWER_MONITOR_REQUEST_REASON = 34;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputAccelerometer:
    POWER_MONITOR_REQUEST_REASON = 35;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputHid:
    POWER_MONITOR_REQUEST_REASON = 36;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputPoUserPresent:
    POWER_MONITOR_REQUEST_REASON = 37;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputSessionSwitch:
    POWER_MONITOR_REQUEST_REASON = 38;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonUserInputInitialization:
    POWER_MONITOR_REQUEST_REASON = 39;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobilePwrNotif:
    POWER_MONITOR_REQUEST_REASON = 40;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalWindowsMobileShell:
    POWER_MONITOR_REQUEST_REASON = 41;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHeyCortana:
    POWER_MONITOR_REQUEST_REASON = 42;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalHolographicShell:
    POWER_MONITOR_REQUEST_REASON = 43;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonPdcSignalFingerprint:
    POWER_MONITOR_REQUEST_REASON = 44;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonDirectedDrips:
    POWER_MONITOR_REQUEST_REASON = 45;
pub const POWER_MONITOR_REQUEST_REASON_MonitorRequestReasonMax: POWER_MONITOR_REQUEST_REASON = 46;
pub type POWER_MONITOR_REQUEST_REASON = i32;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOff: _POWER_MONITOR_REQUEST_TYPE = 0;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeOnAndPresent: _POWER_MONITOR_REQUEST_TYPE =
    1;
pub const _POWER_MONITOR_REQUEST_TYPE_MonitorRequestTypeToggleOn: _POWER_MONITOR_REQUEST_TYPE = 2;
pub type _POWER_MONITOR_REQUEST_TYPE = i32;
pub use self::_POWER_MONITOR_REQUEST_TYPE as POWER_MONITOR_REQUEST_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_MONITOR_INVOCATION {
    pub Console: BOOLEAN,
    pub RequestReason: POWER_MONITOR_REQUEST_REASON,
}
#[test]
fn bindgen_test_layout__POWER_MONITOR_INVOCATION() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_MONITOR_INVOCATION>(),
        8usize,
        concat!("Size of: ", stringify!(_POWER_MONITOR_INVOCATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_MONITOR_INVOCATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_POWER_MONITOR_INVOCATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_MONITOR_INVOCATION>())).Console as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_MONITOR_INVOCATION),
            "::",
            stringify!(Console)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_MONITOR_INVOCATION>())).RequestReason as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_MONITOR_INVOCATION),
            "::",
            stringify!(RequestReason)
        )
    );
}
pub type POWER_MONITOR_INVOCATION = _POWER_MONITOR_INVOCATION;
pub type PPOWER_MONITOR_INVOCATION = *mut _POWER_MONITOR_INVOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESUME_PERFORMANCE {
    pub PostTimeMs: DWORD,
    pub TotalResumeTimeMs: ULONGLONG,
    pub ResumeCompleteTimestamp: ULONGLONG,
}
#[test]
fn bindgen_test_layout__RESUME_PERFORMANCE() {
    assert_eq!(
        ::std::mem::size_of::<_RESUME_PERFORMANCE>(),
        24usize,
        concat!("Size of: ", stringify!(_RESUME_PERFORMANCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_RESUME_PERFORMANCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_RESUME_PERFORMANCE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RESUME_PERFORMANCE>())).PostTimeMs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESUME_PERFORMANCE),
            "::",
            stringify!(PostTimeMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESUME_PERFORMANCE>())).TotalResumeTimeMs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESUME_PERFORMANCE),
            "::",
            stringify!(TotalResumeTimeMs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESUME_PERFORMANCE>())).ResumeCompleteTimestamp as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESUME_PERFORMANCE),
            "::",
            stringify!(ResumeCompleteTimestamp)
        )
    );
}
pub type RESUME_PERFORMANCE = _RESUME_PERFORMANCE;
pub type PRESUME_PERFORMANCE = *mut _RESUME_PERFORMANCE;
pub const SYSTEM_POWER_CONDITION_PoAc: SYSTEM_POWER_CONDITION = 0;
pub const SYSTEM_POWER_CONDITION_PoDc: SYSTEM_POWER_CONDITION = 1;
pub const SYSTEM_POWER_CONDITION_PoHot: SYSTEM_POWER_CONDITION = 2;
pub const SYSTEM_POWER_CONDITION_PoConditionMaximum: SYSTEM_POWER_CONDITION = 3;
pub type SYSTEM_POWER_CONDITION = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SET_POWER_SETTING_VALUE {
    pub Version: DWORD,
    pub Guid: GUID,
    pub PowerCondition: SYSTEM_POWER_CONDITION,
    pub DataLength: DWORD,
    pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout_SET_POWER_SETTING_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<SET_POWER_SETTING_VALUE>(),
        32usize,
        concat!("Size of: ", stringify!(SET_POWER_SETTING_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<SET_POWER_SETTING_VALUE>(),
        4usize,
        concat!("Alignment of ", stringify!(SET_POWER_SETTING_VALUE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Guid as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(Guid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).PowerCondition as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(PowerCondition)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).DataLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SET_POWER_SETTING_VALUE>())).Data as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SET_POWER_SETTING_VALUE),
            "::",
            stringify!(Data)
        )
    );
}
pub type PSET_POWER_SETTING_VALUE = *mut SET_POWER_SETTING_VALUE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NOTIFY_USER_POWER_SETTING {
    pub Guid: GUID,
}
#[test]
fn bindgen_test_layout_NOTIFY_USER_POWER_SETTING() {
    assert_eq!(
        ::std::mem::size_of::<NOTIFY_USER_POWER_SETTING>(),
        16usize,
        concat!("Size of: ", stringify!(NOTIFY_USER_POWER_SETTING))
    );
    assert_eq!(
        ::std::mem::align_of::<NOTIFY_USER_POWER_SETTING>(),
        4usize,
        concat!("Alignment of ", stringify!(NOTIFY_USER_POWER_SETTING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<NOTIFY_USER_POWER_SETTING>())).Guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NOTIFY_USER_POWER_SETTING),
            "::",
            stringify!(Guid)
        )
    );
}
pub type PNOTIFY_USER_POWER_SETTING = *mut NOTIFY_USER_POWER_SETTING;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _APPLICATIONLAUNCH_SETTING_VALUE {
    pub ActivationTime: LARGE_INTEGER,
    pub Flags: DWORD,
    pub ButtonInstanceID: DWORD,
}
#[test]
fn bindgen_test_layout__APPLICATIONLAUNCH_SETTING_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<_APPLICATIONLAUNCH_SETTING_VALUE>(),
        16usize,
        concat!("Size of: ", stringify!(_APPLICATIONLAUNCH_SETTING_VALUE))
    );
    assert_eq!(
        ::std::mem::align_of::<_APPLICATIONLAUNCH_SETTING_VALUE>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_APPLICATIONLAUNCH_SETTING_VALUE>())).ActivationTime as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
            "::",
            stringify!(ActivationTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_APPLICATIONLAUNCH_SETTING_VALUE>())).Flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_APPLICATIONLAUNCH_SETTING_VALUE>())).ButtonInstanceID
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_APPLICATIONLAUNCH_SETTING_VALUE),
            "::",
            stringify!(ButtonInstanceID)
        )
    );
}
pub type APPLICATIONLAUNCH_SETTING_VALUE = _APPLICATIONLAUNCH_SETTING_VALUE;
pub type PAPPLICATIONLAUNCH_SETTING_VALUE = *mut _APPLICATIONLAUNCH_SETTING_VALUE;
pub const _POWER_PLATFORM_ROLE_PlatformRoleUnspecified: _POWER_PLATFORM_ROLE = 0;
pub const _POWER_PLATFORM_ROLE_PlatformRoleDesktop: _POWER_PLATFORM_ROLE = 1;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMobile: _POWER_PLATFORM_ROLE = 2;
pub const _POWER_PLATFORM_ROLE_PlatformRoleWorkstation: _POWER_PLATFORM_ROLE = 3;
pub const _POWER_PLATFORM_ROLE_PlatformRoleEnterpriseServer: _POWER_PLATFORM_ROLE = 4;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSOHOServer: _POWER_PLATFORM_ROLE = 5;
pub const _POWER_PLATFORM_ROLE_PlatformRoleAppliancePC: _POWER_PLATFORM_ROLE = 6;
pub const _POWER_PLATFORM_ROLE_PlatformRolePerformanceServer: _POWER_PLATFORM_ROLE = 7;
pub const _POWER_PLATFORM_ROLE_PlatformRoleSlate: _POWER_PLATFORM_ROLE = 8;
pub const _POWER_PLATFORM_ROLE_PlatformRoleMaximum: _POWER_PLATFORM_ROLE = 9;
pub type _POWER_PLATFORM_ROLE = i32;
pub use self::_POWER_PLATFORM_ROLE as POWER_PLATFORM_ROLE;
pub type PPOWER_PLATFORM_ROLE = *mut _POWER_PLATFORM_ROLE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _POWER_PLATFORM_INFORMATION {
    pub AoAc: BOOLEAN,
}
#[test]
fn bindgen_test_layout__POWER_PLATFORM_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_POWER_PLATFORM_INFORMATION>(),
        1usize,
        concat!("Size of: ", stringify!(_POWER_PLATFORM_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_POWER_PLATFORM_INFORMATION>(),
        1usize,
        concat!("Alignment of ", stringify!(_POWER_PLATFORM_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_POWER_PLATFORM_INFORMATION>())).AoAc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_POWER_PLATFORM_INFORMATION),
            "::",
            stringify!(AoAc)
        )
    );
}
pub type POWER_PLATFORM_INFORMATION = _POWER_PLATFORM_INFORMATION;
pub type PPOWER_PLATFORM_INFORMATION = *mut _POWER_PLATFORM_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BATTERY_REPORTING_SCALE {
    pub Granularity: DWORD,
    pub Capacity: DWORD,
}
#[test]
fn bindgen_test_layout_BATTERY_REPORTING_SCALE() {
    assert_eq!(
        ::std::mem::size_of::<BATTERY_REPORTING_SCALE>(),
        8usize,
        concat!("Size of: ", stringify!(BATTERY_REPORTING_SCALE))
    );
    assert_eq!(
        ::std::mem::align_of::<BATTERY_REPORTING_SCALE>(),
        4usize,
        concat!("Alignment of ", stringify!(BATTERY_REPORTING_SCALE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BATTERY_REPORTING_SCALE>())).Granularity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BATTERY_REPORTING_SCALE),
            "::",
            stringify!(Granularity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BATTERY_REPORTING_SCALE>())).Capacity as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BATTERY_REPORTING_SCALE),
            "::",
            stringify!(Capacity)
        )
    );
}
pub type PBATTERY_REPORTING_SCALE = *mut BATTERY_REPORTING_SCALE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_LEGACY_PERFSTATE {
    pub Frequency: DWORD,
    pub Flags: DWORD,
    pub PercentFrequency: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_WMI_LEGACY_PERFSTATE() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_LEGACY_PERFSTATE>(),
        12usize,
        concat!("Size of: ", stringify!(PPM_WMI_LEGACY_PERFSTATE))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_LEGACY_PERFSTATE>(),
        4usize,
        concat!("Alignment of ", stringify!(PPM_WMI_LEGACY_PERFSTATE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_LEGACY_PERFSTATE>())).Frequency as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_LEGACY_PERFSTATE),
            "::",
            stringify!(Frequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_LEGACY_PERFSTATE>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_LEGACY_PERFSTATE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_LEGACY_PERFSTATE>())).PercentFrequency as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_LEGACY_PERFSTATE),
            "::",
            stringify!(PercentFrequency)
        )
    );
}
pub type PPPM_WMI_LEGACY_PERFSTATE = *mut PPM_WMI_LEGACY_PERFSTATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATE {
    pub Latency: DWORD,
    pub Power: DWORD,
    pub TimeCheck: DWORD,
    pub PromotePercent: BYTE,
    pub DemotePercent: BYTE,
    pub StateType: BYTE,
    pub Reserved: BYTE,
    pub StateFlags: DWORD,
    pub Context: DWORD,
    pub IdleHandler: DWORD,
    pub Reserved1: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATE() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_IDLE_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_IDLE_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).Latency as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).Power as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Power)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).TimeCheck as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).PromotePercent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(PromotePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).DemotePercent as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(DemotePercent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).StateType as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(StateType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).Reserved as *const _ as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).StateFlags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(StateFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).Context as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).IdleHandler as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(IdleHandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATE>())).Reserved1 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATE),
            "::",
            stringify!(Reserved1)
        )
    );
}
pub type PPPM_WMI_IDLE_STATE = *mut PPM_WMI_IDLE_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATES {
    pub Type: DWORD,
    pub Count: DWORD,
    pub TargetState: DWORD,
    pub OldState: DWORD,
    pub TargetProcessors: DWORD64,
    pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATES() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_IDLE_STATES>(),
        56usize,
        concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATES))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_IDLE_STATES>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES>())).Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES>())).TargetState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(TargetState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES>())).OldState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(OldState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES>())).TargetProcessors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES>())).State as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_IDLE_STATES = *mut PPM_WMI_IDLE_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_IDLE_STATES_EX {
    pub Type: DWORD,
    pub Count: DWORD,
    pub TargetState: DWORD,
    pub OldState: DWORD,
    pub TargetProcessors: PVOID,
    pub State: [PPM_WMI_IDLE_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_IDLE_STATES_EX() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_IDLE_STATES_EX>(),
        56usize,
        concat!("Size of: ", stringify!(PPM_WMI_IDLE_STATES_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_IDLE_STATES_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_IDLE_STATES_EX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).TargetState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(TargetState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).OldState as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(OldState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).TargetProcessors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_IDLE_STATES_EX>())).State as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_IDLE_STATES_EX),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_IDLE_STATES_EX = *mut PPM_WMI_IDLE_STATES_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATE {
    pub Frequency: DWORD,
    pub Power: DWORD,
    pub PercentFrequency: BYTE,
    pub IncreaseLevel: BYTE,
    pub DecreaseLevel: BYTE,
    pub Type: BYTE,
    pub IncreaseTime: DWORD,
    pub DecreaseTime: DWORD,
    pub Control: DWORD64,
    pub Status: DWORD64,
    pub HitCount: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub Reserved3: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATE() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_PERF_STATE>(),
        64usize,
        concat!("Size of: ", stringify!(PPM_WMI_PERF_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_PERF_STATE>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Frequency as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Frequency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Power as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Power)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).PercentFrequency as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(PercentFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).IncreaseLevel as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(IncreaseLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).DecreaseLevel as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(DecreaseLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Type as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).IncreaseTime as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(IncreaseTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).DecreaseTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(DecreaseTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Control as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Status as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).HitCount as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(HitCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Reserved1 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Reserved2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATE>())).Reserved3 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATE),
            "::",
            stringify!(Reserved3)
        )
    );
}
pub type PPPM_WMI_PERF_STATE = *mut PPM_WMI_PERF_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATES {
    pub Count: DWORD,
    pub MaxFrequency: DWORD,
    pub CurrentState: DWORD,
    pub MaxPerfState: DWORD,
    pub MinPerfState: DWORD,
    pub LowestPerfState: DWORD,
    pub ThermalConstraint: DWORD,
    pub BusyAdjThreshold: BYTE,
    pub PolicyType: BYTE,
    pub Type: BYTE,
    pub Reserved: BYTE,
    pub TimerInterval: DWORD,
    pub TargetProcessors: DWORD64,
    pub PStateHandler: DWORD,
    pub PStateContext: DWORD,
    pub TStateHandler: DWORD,
    pub TStateContext: DWORD,
    pub FeedbackHandler: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub State: [PPM_WMI_PERF_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATES() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_PERF_STATES>(),
        144usize,
        concat!("Size of: ", stringify!(PPM_WMI_PERF_STATES))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_PERF_STATES>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).MaxFrequency as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(MaxFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).CurrentState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(CurrentState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).MaxPerfState as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(MaxPerfState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).MinPerfState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(MinPerfState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).LowestPerfState as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(LowestPerfState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).ThermalConstraint as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(ThermalConstraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).BusyAdjThreshold as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(BusyAdjThreshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).PolicyType as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(PolicyType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).Type as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).Reserved as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).TimerInterval as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TimerInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).TargetProcessors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).PStateHandler as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(PStateHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).PStateContext as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(PStateContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).TStateHandler as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TStateHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).TStateContext as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(TStateContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).FeedbackHandler as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(FeedbackHandler)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).Reserved1 as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).Reserved2 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES>())).State as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_PERF_STATES = *mut PPM_WMI_PERF_STATES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_WMI_PERF_STATES_EX {
    pub Count: DWORD,
    pub MaxFrequency: DWORD,
    pub CurrentState: DWORD,
    pub MaxPerfState: DWORD,
    pub MinPerfState: DWORD,
    pub LowestPerfState: DWORD,
    pub ThermalConstraint: DWORD,
    pub BusyAdjThreshold: BYTE,
    pub PolicyType: BYTE,
    pub Type: BYTE,
    pub Reserved: BYTE,
    pub TimerInterval: DWORD,
    pub TargetProcessors: PVOID,
    pub PStateHandler: DWORD,
    pub PStateContext: DWORD,
    pub TStateHandler: DWORD,
    pub TStateContext: DWORD,
    pub FeedbackHandler: DWORD,
    pub Reserved1: DWORD,
    pub Reserved2: DWORD64,
    pub State: [PPM_WMI_PERF_STATE; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_WMI_PERF_STATES_EX() {
    assert_eq!(
        ::std::mem::size_of::<PPM_WMI_PERF_STATES_EX>(),
        144usize,
        concat!("Size of: ", stringify!(PPM_WMI_PERF_STATES_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_WMI_PERF_STATES_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_WMI_PERF_STATES_EX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).MaxFrequency as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(MaxFrequency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).CurrentState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(CurrentState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).MaxPerfState as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(MaxPerfState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).MinPerfState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(MinPerfState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).LowestPerfState as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(LowestPerfState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).ThermalConstraint as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(ThermalConstraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).BusyAdjThreshold as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(BusyAdjThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).PolicyType as *const _ as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(PolicyType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Type as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Reserved as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TimerInterval as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TimerInterval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TargetProcessors as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TargetProcessors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).PStateHandler as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(PStateHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).PStateContext as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(PStateContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TStateHandler as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TStateHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).TStateContext as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(TStateContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).FeedbackHandler as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(FeedbackHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Reserved1 as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).Reserved2 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_WMI_PERF_STATES_EX>())).State as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_WMI_PERF_STATES_EX),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_WMI_PERF_STATES_EX = *mut PPM_WMI_PERF_STATES_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_ACCOUNTING {
    pub IdleTransitions: DWORD,
    pub FailedTransitions: DWORD,
    pub InvalidBucketIndex: DWORD,
    pub TotalTime: DWORD64,
    pub IdleTimeBuckets: [DWORD; 6usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_ACCOUNTING() {
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_STATE_ACCOUNTING>(),
        48usize,
        concat!("Size of: ", stringify!(PPM_IDLE_STATE_ACCOUNTING))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_STATE_ACCOUNTING>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_STATE_ACCOUNTING))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).IdleTransitions as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(IdleTransitions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).FailedTransitions as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(FailedTransitions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).InvalidBucketIndex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(InvalidBucketIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).TotalTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(TotalTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING>())).IdleTimeBuckets as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING),
            "::",
            stringify!(IdleTimeBuckets)
        )
    );
}
pub type PPPM_IDLE_STATE_ACCOUNTING = *mut PPM_IDLE_STATE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_ACCOUNTING {
    pub StateCount: DWORD,
    pub TotalTransitions: DWORD,
    pub ResetCount: DWORD,
    pub StartTime: DWORD64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_ACCOUNTING() {
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_ACCOUNTING>(),
        72usize,
        concat!("Size of: ", stringify!(PPM_IDLE_ACCOUNTING))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_ACCOUNTING>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_ACCOUNTING))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING>())).StateCount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(StateCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING>())).TotalTransitions as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(TotalTransitions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING>())).ResetCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(ResetCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING>())).StartTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING>())).State as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_IDLE_ACCOUNTING = *mut PPM_IDLE_ACCOUNTING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_BUCKET_EX {
    pub TotalTimeUs: DWORD64,
    pub MinTimeUs: DWORD,
    pub MaxTimeUs: DWORD,
    pub Count: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_BUCKET_EX() {
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_STATE_BUCKET_EX>(),
        24usize,
        concat!("Size of: ", stringify!(PPM_IDLE_STATE_BUCKET_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_STATE_BUCKET_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_STATE_BUCKET_EX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).TotalTimeUs as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(TotalTimeUs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).MinTimeUs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(MinTimeUs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).MaxTimeUs as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(MaxTimeUs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLE_STATE_BUCKET_EX>())).Count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_BUCKET_EX),
            "::",
            stringify!(Count)
        )
    );
}
pub type PPPM_IDLE_STATE_BUCKET_EX = *mut PPM_IDLE_STATE_BUCKET_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_STATE_ACCOUNTING_EX {
    pub TotalTime: DWORD64,
    pub IdleTransitions: DWORD,
    pub FailedTransitions: DWORD,
    pub InvalidBucketIndex: DWORD,
    pub MinTimeUs: DWORD,
    pub MaxTimeUs: DWORD,
    pub CancelledTransitions: DWORD,
    pub IdleTimeBuckets: [PPM_IDLE_STATE_BUCKET_EX; 16usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_STATE_ACCOUNTING_EX() {
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_STATE_ACCOUNTING_EX>(),
        416usize,
        concat!("Size of: ", stringify!(PPM_IDLE_STATE_ACCOUNTING_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_STATE_ACCOUNTING_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_STATE_ACCOUNTING_EX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).TotalTime as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(TotalTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).IdleTransitions as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(IdleTransitions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).FailedTransitions as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(FailedTransitions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).InvalidBucketIndex as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(InvalidBucketIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).MinTimeUs as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(MinTimeUs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).MaxTimeUs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(MaxTimeUs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).CancelledTransitions
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(CancelledTransitions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_STATE_ACCOUNTING_EX>())).IdleTimeBuckets as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_STATE_ACCOUNTING_EX),
            "::",
            stringify!(IdleTimeBuckets)
        )
    );
}
pub type PPPM_IDLE_STATE_ACCOUNTING_EX = *mut PPM_IDLE_STATE_ACCOUNTING_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLE_ACCOUNTING_EX {
    pub StateCount: DWORD,
    pub TotalTransitions: DWORD,
    pub ResetCount: DWORD,
    pub AbortCount: DWORD,
    pub StartTime: DWORD64,
    pub State: [PPM_IDLE_STATE_ACCOUNTING_EX; 1usize],
}
#[test]
fn bindgen_test_layout_PPM_IDLE_ACCOUNTING_EX() {
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLE_ACCOUNTING_EX>(),
        440usize,
        concat!("Size of: ", stringify!(PPM_IDLE_ACCOUNTING_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLE_ACCOUNTING_EX>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLE_ACCOUNTING_EX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).StateCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(StateCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).TotalTransitions as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(TotalTransitions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).ResetCount as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(ResetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).AbortCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(AbortCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).StartTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(StartTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLE_ACCOUNTING_EX>())).State as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLE_ACCOUNTING_EX),
            "::",
            stringify!(State)
        )
    );
}
pub type PPPM_IDLE_ACCOUNTING_EX = *mut PPM_IDLE_ACCOUNTING_EX;
extern "C" {
    #[link_name = "\u{1}PPM_PERFSTATE_CHANGE_GUID"]
    pub static PPM_PERFSTATE_CHANGE_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_PERFSTATE_DOMAIN_CHANGE_GUID"]
    pub static PPM_PERFSTATE_DOMAIN_CHANGE_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_IDLESTATE_CHANGE_GUID"]
    pub static PPM_IDLESTATE_CHANGE_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_PERFSTATES_DATA_GUID"]
    pub static PPM_PERFSTATES_DATA_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_IDLESTATES_DATA_GUID"]
    pub static PPM_IDLESTATES_DATA_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_IDLE_ACCOUNTING_GUID"]
    pub static PPM_IDLE_ACCOUNTING_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_IDLE_ACCOUNTING_EX_GUID"]
    pub static PPM_IDLE_ACCOUNTING_EX_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_THERMALCONSTRAINT_GUID"]
    pub static PPM_THERMALCONSTRAINT_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_PERFMON_PERFSTATE_GUID"]
    pub static PPM_PERFMON_PERFSTATE_GUID: GUID;
}
extern "C" {
    #[link_name = "\u{1}PPM_THERMAL_POLICY_CHANGE_GUID"]
    pub static PPM_THERMAL_POLICY_CHANGE_GUID: GUID;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_PERFSTATE_EVENT {
    pub State: DWORD,
    pub Status: DWORD,
    pub Latency: DWORD,
    pub Speed: DWORD,
    pub Processor: DWORD,
}
#[test]
fn bindgen_test_layout_PPM_PERFSTATE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<PPM_PERFSTATE_EVENT>(),
        20usize,
        concat!("Size of: ", stringify!(PPM_PERFSTATE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_PERFSTATE_EVENT>(),
        4usize,
        concat!("Alignment of ", stringify!(PPM_PERFSTATE_EVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_PERFSTATE_EVENT>())).State as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_PERFSTATE_EVENT>())).Status as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_PERFSTATE_EVENT>())).Latency as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Latency)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_PERFSTATE_EVENT>())).Speed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_PERFSTATE_EVENT>())).Processor as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_EVENT),
            "::",
            stringify!(Processor)
        )
    );
}
pub type PPPM_PERFSTATE_EVENT = *mut PPM_PERFSTATE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_PERFSTATE_DOMAIN_EVENT {
    pub State: DWORD,
    pub Latency: DWORD,
    pub Speed: DWORD,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_PERFSTATE_DOMAIN_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<PPM_PERFSTATE_DOMAIN_EVENT>(),
        24usize,
        concat!("Size of: ", stringify!(PPM_PERFSTATE_DOMAIN_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_PERFSTATE_DOMAIN_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_PERFSTATE_DOMAIN_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).State as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).Latency as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(Latency)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).Speed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(Speed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_PERFSTATE_DOMAIN_EVENT>())).Processors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_PERFSTATE_DOMAIN_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_PERFSTATE_DOMAIN_EVENT = *mut PPM_PERFSTATE_DOMAIN_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_IDLESTATE_EVENT {
    pub NewState: DWORD,
    pub OldState: DWORD,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_IDLESTATE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<PPM_IDLESTATE_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(PPM_IDLESTATE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_IDLESTATE_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_IDLESTATE_EVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLESTATE_EVENT>())).NewState as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLESTATE_EVENT),
            "::",
            stringify!(NewState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLESTATE_EVENT>())).OldState as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLESTATE_EVENT),
            "::",
            stringify!(OldState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_IDLESTATE_EVENT>())).Processors as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_IDLESTATE_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_IDLESTATE_EVENT = *mut PPM_IDLESTATE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_THERMALCHANGE_EVENT {
    pub ThermalConstraint: DWORD,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_THERMALCHANGE_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<PPM_THERMALCHANGE_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(PPM_THERMALCHANGE_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_THERMALCHANGE_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_THERMALCHANGE_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_THERMALCHANGE_EVENT>())).ThermalConstraint as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMALCHANGE_EVENT),
            "::",
            stringify!(ThermalConstraint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_THERMALCHANGE_EVENT>())).Processors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMALCHANGE_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_THERMALCHANGE_EVENT = *mut PPM_THERMALCHANGE_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PPM_THERMAL_POLICY_EVENT {
    pub Mode: BYTE,
    pub Processors: DWORD64,
}
#[test]
fn bindgen_test_layout_PPM_THERMAL_POLICY_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<PPM_THERMAL_POLICY_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(PPM_THERMAL_POLICY_EVENT))
    );
    assert_eq!(
        ::std::mem::align_of::<PPM_THERMAL_POLICY_EVENT>(),
        8usize,
        concat!("Alignment of ", stringify!(PPM_THERMAL_POLICY_EVENT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PPM_THERMAL_POLICY_EVENT>())).Mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMAL_POLICY_EVENT),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PPM_THERMAL_POLICY_EVENT>())).Processors as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PPM_THERMAL_POLICY_EVENT),
            "::",
            stringify!(Processors)
        )
    );
}
pub type PPPM_THERMAL_POLICY_EVENT = *mut PPM_THERMAL_POLICY_EVENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POWER_ACTION_POLICY {
    pub Action: POWER_ACTION,
    pub Flags: DWORD,
    pub EventCode: DWORD,
}
#[test]
fn bindgen_test_layout_POWER_ACTION_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<POWER_ACTION_POLICY>(),
        12usize,
        concat!("Size of: ", stringify!(POWER_ACTION_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<POWER_ACTION_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(POWER_ACTION_POLICY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).Action as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POWER_ACTION_POLICY),
            "::",
            stringify!(Action)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(POWER_ACTION_POLICY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<POWER_ACTION_POLICY>())).EventCode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POWER_ACTION_POLICY),
            "::",
            stringify!(EventCode)
        )
    );
}
pub type PPOWER_ACTION_POLICY = *mut POWER_ACTION_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_LEVEL {
    pub Enable: BOOLEAN,
    pub Spare: [BYTE; 3usize],
    pub BatteryLevel: DWORD,
    pub PowerPolicy: POWER_ACTION_POLICY,
    pub MinSystemState: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_LEVEL() {
    assert_eq!(
        ::std::mem::size_of::<SYSTEM_POWER_LEVEL>(),
        24usize,
        concat!("Size of: ", stringify!(SYSTEM_POWER_LEVEL))
    );
    assert_eq!(
        ::std::mem::align_of::<SYSTEM_POWER_LEVEL>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSTEM_POWER_LEVEL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).Enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(Enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).Spare as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).BatteryLevel as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(BatteryLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).PowerPolicy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(PowerPolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_LEVEL>())).MinSystemState as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_LEVEL),
            "::",
            stringify!(MinSystemState)
        )
    );
}
pub type PSYSTEM_POWER_LEVEL = *mut SYSTEM_POWER_LEVEL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SYSTEM_POWER_POLICY {
    pub Revision: DWORD,
    pub PowerButton: POWER_ACTION_POLICY,
    pub SleepButton: POWER_ACTION_POLICY,
    pub LidClose: POWER_ACTION_POLICY,
    pub LidOpenWake: SYSTEM_POWER_STATE,
    pub Reserved: DWORD,
    pub Idle: POWER_ACTION_POLICY,
    pub IdleTimeout: DWORD,
    pub IdleSensitivity: BYTE,
    pub DynamicThrottle: BYTE,
    pub Spare2: [BYTE; 2usize],
    pub MinSleep: SYSTEM_POWER_STATE,
    pub MaxSleep: SYSTEM_POWER_STATE,
    pub ReducedLatencySleep: SYSTEM_POWER_STATE,
    pub WinLogonFlags: DWORD,
    pub Spare3: DWORD,
    pub DozeS4Timeout: DWORD,
    pub BroadcastCapacityResolution: DWORD,
    pub DischargePolicy: [SYSTEM_POWER_LEVEL; 4usize],
    pub VideoTimeout: DWORD,
    pub VideoDimDisplay: BOOLEAN,
    pub VideoReserved: [DWORD; 3usize],
    pub SpindownTimeout: DWORD,
    pub OptimizeForPower: BOOLEAN,
    pub FanThrottleTolerance: BYTE,
    pub ForcedThrottle: BYTE,
    pub MinThrottle: BYTE,
    pub OverThrottled: POWER_ACTION_POLICY,
}
#[test]
fn bindgen_test_layout__SYSTEM_POWER_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_SYSTEM_POWER_POLICY>(),
        232usize,
        concat!("Size of: ", stringify!(_SYSTEM_POWER_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_SYSTEM_POWER_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_SYSTEM_POWER_POLICY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Revision as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).PowerButton as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(PowerButton)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).SleepButton as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(SleepButton)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).LidClose as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(LidClose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).LidOpenWake as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(LidOpenWake)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Reserved as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Idle as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Idle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleTimeout as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(IdleTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).IdleSensitivity as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(IdleSensitivity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DynamicThrottle as *const _ as usize
        },
        65usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(DynamicThrottle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare2 as *const _ as usize },
        66usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MinSleep as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(MinSleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MaxSleep as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(MaxSleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).ReducedLatencySleep as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(ReducedLatencySleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).WinLogonFlags as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(WinLogonFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).Spare3 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(Spare3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DozeS4Timeout as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(DozeS4Timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).BroadcastCapacityResolution as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(BroadcastCapacityResolution)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).DischargePolicy as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(DischargePolicy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoTimeout as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(VideoTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoDimDisplay as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(VideoDimDisplay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).VideoReserved as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(VideoReserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).SpindownTimeout as *const _ as usize
        },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(SpindownTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).OptimizeForPower as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(OptimizeForPower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).FanThrottleTolerance as *const _
                as usize
        },
        217usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(FanThrottleTolerance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).ForcedThrottle as *const _ as usize
        },
        218usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(ForcedThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).MinThrottle as *const _ as usize
        },
        219usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(MinThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SYSTEM_POWER_POLICY>())).OverThrottled as *const _ as usize
        },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(_SYSTEM_POWER_POLICY),
            "::",
            stringify!(OverThrottled)
        )
    );
}
pub type SYSTEM_POWER_POLICY = _SYSTEM_POWER_POLICY;
pub type PSYSTEM_POWER_POLICY = *mut _SYSTEM_POWER_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_INFO {
    pub TimeCheck: DWORD,
    pub DemotePercent: BYTE,
    pub PromotePercent: BYTE,
    pub Spare: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_INFO() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_INFO>(),
        8usize,
        concat!("Size of: ", stringify!(PROCESSOR_IDLESTATE_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(PROCESSOR_IDLESTATE_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).TimeCheck as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).DemotePercent as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(DemotePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).PromotePercent as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(PromotePercent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_INFO>())).Spare as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_INFO),
            "::",
            stringify!(Spare)
        )
    );
}
pub type PPROCESSOR_IDLESTATE_INFO = *mut PROCESSOR_IDLESTATE_INFO;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY {
    pub Revision: WORD,
    pub Flags: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1,
    pub PolicyCount: DWORD,
    pub Policy: [PROCESSOR_IDLESTATE_INFO; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1 {
    pub AsWORD: WORD,
    pub __bindgen_anon_1: PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn AllowScaling(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_AllowScaling(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Disabled(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Disabled(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 14u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 14u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowScaling: WORD,
        Disabled: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowScaling: u16 = unsafe { ::std::mem::transmute(AllowScaling) };
            AllowScaling as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Disabled: u16 = unsafe { ::std::mem::transmute(Disabled) };
            Disabled as u64
        });
        __bindgen_bitfield_unit.set(2usize, 14u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1>())).AsWORD as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY__bindgen_ty_1),
            "::",
            stringify!(AsWORD)
        )
    );
}
#[test]
fn bindgen_test_layout_PROCESSOR_IDLESTATE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_IDLESTATE_POLICY>(),
        32usize,
        concat!("Size of: ", stringify!(PROCESSOR_IDLESTATE_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_IDLESTATE_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(PROCESSOR_IDLESTATE_POLICY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).Revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).Flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).PolicyCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(PolicyCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_IDLESTATE_POLICY>())).Policy as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_IDLESTATE_POLICY),
            "::",
            stringify!(Policy)
        )
    );
}
pub type PPROCESSOR_IDLESTATE_POLICY = *mut PROCESSOR_IDLESTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_POWER_POLICY_INFO {
    pub TimeCheck: DWORD,
    pub DemoteLimit: DWORD,
    pub PromoteLimit: DWORD,
    pub DemotePercent: BYTE,
    pub PromotePercent: BYTE,
    pub Spare: [BYTE; 2usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__PROCESSOR_POWER_POLICY_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_POWER_POLICY_INFO>(),
        20usize,
        concat!("Size of: ", stringify!(_PROCESSOR_POWER_POLICY_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_POWER_POLICY_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_POWER_POLICY_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).TimeCheck as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).DemoteLimit as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(DemoteLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).PromoteLimit as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(PromoteLimit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).DemotePercent as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(DemotePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).PromotePercent as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(PromotePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY_INFO>())).Spare as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY_INFO),
            "::",
            stringify!(Spare)
        )
    );
}
impl _PROCESSOR_POWER_POLICY_INFO {
    #[inline]
    pub fn AllowDemotion(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowDemotion(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AllowPromotion(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AllowPromotion(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AllowDemotion: DWORD,
        AllowPromotion: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AllowDemotion: u32 = unsafe { ::std::mem::transmute(AllowDemotion) };
            AllowDemotion as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let AllowPromotion: u32 = unsafe { ::std::mem::transmute(AllowPromotion) };
            AllowPromotion as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESSOR_POWER_POLICY_INFO = _PROCESSOR_POWER_POLICY_INFO;
pub type PPROCESSOR_POWER_POLICY_INFO = *mut _PROCESSOR_POWER_POLICY_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PROCESSOR_POWER_POLICY {
    pub Revision: DWORD,
    pub DynamicThrottle: BYTE,
    pub Spare: [BYTE; 3usize],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub PolicyCount: DWORD,
    pub Policy: [PROCESSOR_POWER_POLICY_INFO; 3usize],
}
#[test]
fn bindgen_test_layout__PROCESSOR_POWER_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_PROCESSOR_POWER_POLICY>(),
        76usize,
        concat!("Size of: ", stringify!(_PROCESSOR_POWER_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_PROCESSOR_POWER_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_PROCESSOR_POWER_POLICY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY>())).Revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY>())).DynamicThrottle as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(DynamicThrottle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY>())).Spare as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY>())).PolicyCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(PolicyCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PROCESSOR_POWER_POLICY>())).Policy as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PROCESSOR_POWER_POLICY),
            "::",
            stringify!(Policy)
        )
    );
}
impl _PROCESSOR_POWER_POLICY {
    #[inline]
    pub fn DisableCStates(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DisableCStates(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        DisableCStates: DWORD,
        Reserved: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let DisableCStates: u32 = unsafe { ::std::mem::transmute(DisableCStates) };
            DisableCStates as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type PROCESSOR_POWER_POLICY = _PROCESSOR_POWER_POLICY;
pub type PPROCESSOR_POWER_POLICY = *mut _PROCESSOR_POWER_POLICY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY {
    pub Revision: DWORD,
    pub MaxThrottle: BYTE,
    pub MinThrottle: BYTE,
    pub BusyAdjThreshold: BYTE,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1,
    pub TimeCheck: DWORD,
    pub IncreaseTime: DWORD,
    pub DecreaseTime: DWORD,
    pub IncreasePercent: DWORD,
    pub DecreasePercent: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1 {
    pub Spare: BYTE,
    pub Flags: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1 {
    pub AsBYTE: BYTE,
    pub __bindgen_anon_1: PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u8,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(
        ),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NoDomainAccounting(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u8) }
    }
    #[inline]
    pub fn set_NoDomainAccounting(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IncreasePolicy(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_IncreasePolicy(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn DecreasePolicy(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 2u8) as u8) }
    }
    #[inline]
    pub fn set_DecreasePolicy(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> BYTE {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 3u8) as u8) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: BYTE) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NoDomainAccounting: BYTE,
        IncreasePolicy: BYTE,
        DecreasePolicy: BYTE,
        Reserved: BYTE,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NoDomainAccounting: u8 = unsafe { ::std::mem::transmute(NoDomainAccounting) };
            NoDomainAccounting as u64
        });
        __bindgen_bitfield_unit.set(1usize, 2u8, {
            let IncreasePolicy: u8 = unsafe { ::std::mem::transmute(IncreasePolicy) };
            IncreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(3usize, 2u8, {
            let DecreasePolicy: u8 = unsafe { ::std::mem::transmute(DecreasePolicy) };
            DecreasePolicy as u64
        });
        __bindgen_bitfield_unit.set(5usize, 3u8, {
            let Reserved: u8 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1>()))
                .AsBYTE as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(AsBYTE)
        )
    );
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>())).Spare as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1>())).Flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
}
#[test]
fn bindgen_test_layout_PROCESSOR_PERFSTATE_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<PROCESSOR_PERFSTATE_POLICY>(),
        28usize,
        concat!("Size of: ", stringify!(PROCESSOR_PERFSTATE_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<PROCESSOR_PERFSTATE_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(PROCESSOR_PERFSTATE_POLICY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).Revision as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(Revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).MaxThrottle as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(MaxThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).MinThrottle as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(MinThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).BusyAdjThreshold as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(BusyAdjThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).TimeCheck as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(TimeCheck)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).IncreaseTime as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(IncreaseTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).DecreaseTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(DecreaseTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).IncreasePercent as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(IncreasePercent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<PROCESSOR_PERFSTATE_POLICY>())).DecreasePercent as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PROCESSOR_PERFSTATE_POLICY),
            "::",
            stringify!(DecreasePercent)
        )
    );
}
pub type PPROCESSOR_PERFSTATE_POLICY = *mut PROCESSOR_PERFSTATE_POLICY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ADMINISTRATOR_POWER_POLICY {
    pub MinSleep: SYSTEM_POWER_STATE,
    pub MaxSleep: SYSTEM_POWER_STATE,
    pub MinVideoTimeout: DWORD,
    pub MaxVideoTimeout: DWORD,
    pub MinSpindownTimeout: DWORD,
    pub MaxSpindownTimeout: DWORD,
}
#[test]
fn bindgen_test_layout__ADMINISTRATOR_POWER_POLICY() {
    assert_eq!(
        ::std::mem::size_of::<_ADMINISTRATOR_POWER_POLICY>(),
        24usize,
        concat!("Size of: ", stringify!(_ADMINISTRATOR_POWER_POLICY))
    );
    assert_eq!(
        ::std::mem::align_of::<_ADMINISTRATOR_POWER_POLICY>(),
        4usize,
        concat!("Alignment of ", stringify!(_ADMINISTRATOR_POWER_POLICY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MinSleep as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MinSleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MaxSleep as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MaxSleep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MinVideoTimeout as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MinVideoTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MaxVideoTimeout as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MaxVideoTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MinSpindownTimeout as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MinSpindownTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ADMINISTRATOR_POWER_POLICY>())).MaxSpindownTimeout as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ADMINISTRATOR_POWER_POLICY),
            "::",
            stringify!(MaxSpindownTimeout)
        )
    );
}
pub type ADMINISTRATOR_POWER_POLICY = _ADMINISTRATOR_POWER_POLICY;
pub type PADMINISTRATOR_POWER_POLICY = *mut _ADMINISTRATOR_POWER_POLICY;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucket1GB: _HIBERFILE_BUCKET_SIZE = 0;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucket2GB: _HIBERFILE_BUCKET_SIZE = 1;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucket4GB: _HIBERFILE_BUCKET_SIZE = 2;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucket8GB: _HIBERFILE_BUCKET_SIZE = 3;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucket16GB: _HIBERFILE_BUCKET_SIZE = 4;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucket32GB: _HIBERFILE_BUCKET_SIZE = 5;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucketUnlimited: _HIBERFILE_BUCKET_SIZE = 6;
pub const _HIBERFILE_BUCKET_SIZE_HiberFileBucketMax: _HIBERFILE_BUCKET_SIZE = 7;
pub type _HIBERFILE_BUCKET_SIZE = i32;
pub use self::_HIBERFILE_BUCKET_SIZE as HIBERFILE_BUCKET_SIZE;
pub type PHIBERFILE_BUCKET_SIZE = *mut _HIBERFILE_BUCKET_SIZE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HIBERFILE_BUCKET {
    pub MaxPhysicalMemory: DWORD64,
    pub PhysicalMemoryPercent: [DWORD; 3usize],
}
#[test]
fn bindgen_test_layout__HIBERFILE_BUCKET() {
    assert_eq!(
        ::std::mem::size_of::<_HIBERFILE_BUCKET>(),
        24usize,
        concat!("Size of: ", stringify!(_HIBERFILE_BUCKET))
    );
    assert_eq!(
        ::std::mem::align_of::<_HIBERFILE_BUCKET>(),
        8usize,
        concat!("Alignment of ", stringify!(_HIBERFILE_BUCKET))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HIBERFILE_BUCKET>())).MaxPhysicalMemory as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HIBERFILE_BUCKET),
            "::",
            stringify!(MaxPhysicalMemory)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HIBERFILE_BUCKET>())).PhysicalMemoryPercent as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HIBERFILE_BUCKET),
            "::",
            stringify!(PhysicalMemoryPercent)
        )
    );
}
pub type HIBERFILE_BUCKET = _HIBERFILE_BUCKET;
pub type PHIBERFILE_BUCKET = *mut _HIBERFILE_BUCKET;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_POWER_CAPABILITIES {
    pub PowerButtonPresent: BOOLEAN,
    pub SleepButtonPresent: BOOLEAN,
    pub LidPresent: BOOLEAN,
    pub SystemS1: BOOLEAN,
    pub SystemS2: BOOLEAN,
    pub SystemS3: BOOLEAN,
    pub SystemS4: BOOLEAN,
    pub SystemS5: BOOLEAN,
    pub HiberFilePresent: BOOLEAN,
    pub FullWake: BOOLEAN,
    pub VideoDimPresent: BOOLEAN,
    pub ApmPresent: BOOLEAN,
    pub UpsPresent: BOOLEAN,
    pub ThermalControl: BOOLEAN,
    pub ProcessorThrottle: BOOLEAN,
    pub ProcessorMinThrottle: BYTE,
    pub ProcessorMaxThrottle: BYTE,
    pub FastSystemS4: BOOLEAN,
    pub Hiberboot: BOOLEAN,
    pub WakeAlarmPresent: BOOLEAN,
    pub AoAc: BOOLEAN,
    pub DiskSpinDown: BOOLEAN,
    pub HiberFileType: BYTE,
    pub AoAcConnectivitySupported: BOOLEAN,
    pub spare3: [BYTE; 6usize],
    pub SystemBatteriesPresent: BOOLEAN,
    pub BatteriesAreShortTerm: BOOLEAN,
    pub BatteryScale: [BATTERY_REPORTING_SCALE; 3usize],
    pub AcOnLineWake: SYSTEM_POWER_STATE,
    pub SoftLidWake: SYSTEM_POWER_STATE,
    pub RtcWake: SYSTEM_POWER_STATE,
    pub MinDeviceWakeState: SYSTEM_POWER_STATE,
    pub DefaultLowLatencyWake: SYSTEM_POWER_STATE,
}
#[test]
fn bindgen_test_layout_SYSTEM_POWER_CAPABILITIES() {
    assert_eq!(
        ::std::mem::size_of::<SYSTEM_POWER_CAPABILITIES>(),
        76usize,
        concat!("Size of: ", stringify!(SYSTEM_POWER_CAPABILITIES))
    );
    assert_eq!(
        ::std::mem::align_of::<SYSTEM_POWER_CAPABILITIES>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSTEM_POWER_CAPABILITIES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).PowerButtonPresent as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(PowerButtonPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SleepButtonPresent as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SleepButtonPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).LidPresent as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(LidPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS1 as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS3 as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS4 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemS5 as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemS5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFilePresent as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(HiberFilePresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FullWake as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(FullWake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).VideoDimPresent as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(VideoDimPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ApmPresent as *const _ as usize
        },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ApmPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).UpsPresent as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(UpsPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ThermalControl as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ThermalControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorThrottle as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ProcessorThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMinThrottle as *const _
                as usize
        },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ProcessorMinThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).ProcessorMaxThrottle as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(ProcessorMaxThrottle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).FastSystemS4 as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(FastSystemS4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).Hiberboot as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(Hiberboot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).WakeAlarmPresent as *const _
                as usize
        },
        19usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(WakeAlarmPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(AoAc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DiskSpinDown as *const _ as usize
        },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(DiskSpinDown)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).HiberFileType as *const _ as usize
        },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(HiberFileType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AoAcConnectivitySupported
                as *const _ as usize
        },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(AoAcConnectivitySupported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).spare3 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(spare3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SystemBatteriesPresent as *const _
                as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SystemBatteriesPresent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteriesAreShortTerm as *const _
                as usize
        },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(BatteriesAreShortTerm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).BatteryScale as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(BatteryScale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).AcOnLineWake as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(AcOnLineWake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).SoftLidWake as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(SoftLidWake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).RtcWake as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(RtcWake)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).MinDeviceWakeState as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(MinDeviceWakeState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_POWER_CAPABILITIES>())).DefaultLowLatencyWake as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_POWER_CAPABILITIES),
            "::",
            stringify!(DefaultLowLatencyWake)
        )
    );
}
pub type PSYSTEM_POWER_CAPABILITIES = *mut SYSTEM_POWER_CAPABILITIES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SYSTEM_BATTERY_STATE {
    pub AcOnLine: BOOLEAN,
    pub BatteryPresent: BOOLEAN,
    pub Charging: BOOLEAN,
    pub Discharging: BOOLEAN,
    pub Spare1: [BOOLEAN; 3usize],
    pub Tag: BYTE,
    pub MaxCapacity: DWORD,
    pub RemainingCapacity: DWORD,
    pub Rate: DWORD,
    pub EstimatedTime: DWORD,
    pub DefaultAlert1: DWORD,
    pub DefaultAlert2: DWORD,
}
#[test]
fn bindgen_test_layout_SYSTEM_BATTERY_STATE() {
    assert_eq!(
        ::std::mem::size_of::<SYSTEM_BATTERY_STATE>(),
        32usize,
        concat!("Size of: ", stringify!(SYSTEM_BATTERY_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<SYSTEM_BATTERY_STATE>(),
        4usize,
        concat!("Alignment of ", stringify!(SYSTEM_BATTERY_STATE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).AcOnLine as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(AcOnLine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).BatteryPresent as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(BatteryPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Charging as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Charging)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Discharging as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Discharging)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Spare1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Tag as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).MaxCapacity as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(MaxCapacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).RemainingCapacity as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(RemainingCapacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).Rate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(Rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).EstimatedTime as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(EstimatedTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert1 as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(DefaultAlert1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SYSTEM_BATTERY_STATE>())).DefaultAlert2 as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SYSTEM_BATTERY_STATE),
            "::",
            stringify!(DefaultAlert2)
        )
    );
}
pub type PSYSTEM_BATTERY_STATE = *mut SYSTEM_BATTERY_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DOS_HEADER {
    pub _bindgen_opaque_blob: [u16; 32usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DOS_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DOS_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_IMAGE_DOS_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DOS_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_DOS_HEADER))
    );
}
pub type IMAGE_DOS_HEADER = _IMAGE_DOS_HEADER;
pub type PIMAGE_DOS_HEADER = *mut _IMAGE_DOS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OS2_HEADER {
    pub _bindgen_opaque_blob: [u16; 32usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OS2_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OS2_HEADER>(),
        64usize,
        concat!("Size of: ", stringify!(_IMAGE_OS2_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OS2_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_OS2_HEADER))
    );
}
pub type IMAGE_OS2_HEADER = _IMAGE_OS2_HEADER;
pub type PIMAGE_OS2_HEADER = *mut _IMAGE_OS2_HEADER;
#[repr(C)]
pub struct _IMAGE_VXD_HEADER {
    pub _bindgen_opaque_blob: [u16; 98usize],
}
#[test]
fn bindgen_test_layout__IMAGE_VXD_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_VXD_HEADER>(),
        196usize,
        concat!("Size of: ", stringify!(_IMAGE_VXD_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_VXD_HEADER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_VXD_HEADER))
    );
}
pub type IMAGE_VXD_HEADER = _IMAGE_VXD_HEADER;
pub type PIMAGE_VXD_HEADER = *mut _IMAGE_VXD_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FILE_HEADER {
    pub Machine: WORD,
    pub NumberOfSections: WORD,
    pub TimeDateStamp: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
    pub SizeOfOptionalHeader: WORD,
    pub Characteristics: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_FILE_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FILE_HEADER>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FILE_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FILE_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).Machine as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).NumberOfSections as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).TimeDateStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).PointerToSymbolTable as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).NumberOfSymbols as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).SizeOfOptionalHeader as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(SizeOfOptionalHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FILE_HEADER>())).Characteristics as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FILE_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_FILE_HEADER = _IMAGE_FILE_HEADER;
pub type PIMAGE_FILE_HEADER = *mut _IMAGE_FILE_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DATA_DIRECTORY {
    pub VirtualAddress: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DATA_DIRECTORY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DATA_DIRECTORY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DATA_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DATA_DIRECTORY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DATA_DIRECTORY>())).VirtualAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DATA_DIRECTORY>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DATA_DIRECTORY),
            "::",
            stringify!(Size)
        )
    );
}
pub type IMAGE_DATA_DIRECTORY = _IMAGE_DATA_DIRECTORY;
pub type PIMAGE_DATA_DIRECTORY = *mut _IMAGE_DATA_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub ImageBase: DWORD,
    pub SectionAlignment: DWORD,
    pub FileAlignment: DWORD,
    pub MajorOperatingSystemVersion: WORD,
    pub MinorOperatingSystemVersion: WORD,
    pub MajorImageVersion: WORD,
    pub MinorImageVersion: WORD,
    pub MajorSubsystemVersion: WORD,
    pub MinorSubsystemVersion: WORD,
    pub Win32VersionValue: DWORD,
    pub SizeOfImage: DWORD,
    pub SizeOfHeaders: DWORD,
    pub CheckSum: DWORD,
    pub Subsystem: WORD,
    pub DllCharacteristics: WORD,
    pub SizeOfStackReserve: DWORD,
    pub SizeOfStackCommit: DWORD,
    pub SizeOfHeapReserve: DWORD,
    pub SizeOfHeapCommit: DWORD,
    pub LoaderFlags: DWORD,
    pub NumberOfRvaAndSizes: DWORD,
    pub DataDirectory: [IMAGE_DATA_DIRECTORY; 16usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OPTIONAL_HEADER>(),
        224usize,
        concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OPTIONAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).Magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MajorLinkerVersion as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MinorLinkerVersion as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfInitializedData as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfUninitializedData as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).AddressOfEntryPoint as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).BaseOfCode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).BaseOfData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).ImageBase as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SectionAlignment as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).FileAlignment as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(FileAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MajorOperatingSystemVersion
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MinorOperatingSystemVersion
                as *const _ as usize
        },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorOperatingSystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MajorImageVersion as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MinorImageVersion as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MajorSubsystemVersion as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MajorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).MinorSubsystemVersion as *const _
                as usize
        },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(MinorSubsystemVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).Win32VersionValue as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Win32VersionValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfImage as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfHeaders as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).CheckSum as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).Subsystem as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(Subsystem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).DllCharacteristics as *const _
                as usize
        },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(DllCharacteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfStackReserve as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfStackReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfStackCommit as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfStackCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfHeapReserve as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeapReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).SizeOfHeapCommit as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfHeapCommit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).LoaderFlags as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(LoaderFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).NumberOfRvaAndSizes as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(NumberOfRvaAndSizes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_OPTIONAL_HEADER>())).DataDirectory as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_OPTIONAL_HEADER),
            "::",
            stringify!(DataDirectory)
        )
    );
}
pub type IMAGE_OPTIONAL_HEADER32 = _IMAGE_OPTIONAL_HEADER;
pub type PIMAGE_OPTIONAL_HEADER32 = *mut _IMAGE_OPTIONAL_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ROM_OPTIONAL_HEADER {
    pub Magic: WORD,
    pub MajorLinkerVersion: BYTE,
    pub MinorLinkerVersion: BYTE,
    pub SizeOfCode: DWORD,
    pub SizeOfInitializedData: DWORD,
    pub SizeOfUninitializedData: DWORD,
    pub AddressOfEntryPoint: DWORD,
    pub BaseOfCode: DWORD,
    pub BaseOfData: DWORD,
    pub BaseOfBss: DWORD,
    pub GprMask: DWORD,
    pub CprMask: [DWORD; 4usize],
    pub GpValue: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_ROM_OPTIONAL_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ROM_OPTIONAL_HEADER>(),
        56usize,
        concat!("Size of: ", stringify!(_IMAGE_ROM_OPTIONAL_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ROM_OPTIONAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ROM_OPTIONAL_HEADER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).Magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(Magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).MajorLinkerVersion as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(MajorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).MinorLinkerVersion as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(MinorLinkerVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).SizeOfCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).SizeOfInitializedData as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfInitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).SizeOfUninitializedData
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(SizeOfUninitializedData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).AddressOfEntryPoint as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(AddressOfEntryPoint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).BaseOfCode as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).BaseOfData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).BaseOfBss as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(BaseOfBss)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).GprMask as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(GprMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).CprMask as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(CprMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_OPTIONAL_HEADER>())).GpValue as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_OPTIONAL_HEADER),
            "::",
            stringify!(GpValue)
        )
    );
}
pub type IMAGE_ROM_OPTIONAL_HEADER = _IMAGE_ROM_OPTIONAL_HEADER;
pub type PIMAGE_ROM_OPTIONAL_HEADER = *mut _IMAGE_ROM_OPTIONAL_HEADER;
#[repr(C)]
pub struct _IMAGE_OPTIONAL_HEADER64 {
    pub _bindgen_opaque_blob: [u32; 60usize],
}
#[test]
fn bindgen_test_layout__IMAGE_OPTIONAL_HEADER64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_OPTIONAL_HEADER64>(),
        240usize,
        concat!("Size of: ", stringify!(_IMAGE_OPTIONAL_HEADER64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_OPTIONAL_HEADER64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_OPTIONAL_HEADER64))
    );
}
pub type IMAGE_OPTIONAL_HEADER64 = _IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER64 = *mut _IMAGE_OPTIONAL_HEADER64;
pub type IMAGE_OPTIONAL_HEADER = IMAGE_OPTIONAL_HEADER64;
pub type PIMAGE_OPTIONAL_HEADER = PIMAGE_OPTIONAL_HEADER64;
#[repr(C)]
pub struct _IMAGE_NT_HEADERS64 {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER64,
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_NT_HEADERS64>(),
        264usize,
        concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_NT_HEADERS64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_NT_HEADERS64>())).Signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_NT_HEADERS64>())).FileHeader as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_NT_HEADERS64>())).OptionalHeader as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS64),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_NT_HEADERS64 = _IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS64 = *mut _IMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_NT_HEADERS {
    pub Signature: DWORD,
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_OPTIONAL_HEADER32,
}
#[test]
fn bindgen_test_layout__IMAGE_NT_HEADERS() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_NT_HEADERS>(),
        248usize,
        concat!("Size of: ", stringify!(_IMAGE_NT_HEADERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_NT_HEADERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_NT_HEADERS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_NT_HEADERS>())).Signature as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_NT_HEADERS>())).FileHeader as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_NT_HEADERS>())).OptionalHeader as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_NT_HEADERS),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_NT_HEADERS32 = _IMAGE_NT_HEADERS;
pub type PIMAGE_NT_HEADERS32 = *mut _IMAGE_NT_HEADERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ROM_HEADERS {
    pub FileHeader: IMAGE_FILE_HEADER,
    pub OptionalHeader: IMAGE_ROM_OPTIONAL_HEADER,
}
#[test]
fn bindgen_test_layout__IMAGE_ROM_HEADERS() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ROM_HEADERS>(),
        76usize,
        concat!("Size of: ", stringify!(_IMAGE_ROM_HEADERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ROM_HEADERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ROM_HEADERS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ROM_HEADERS>())).FileHeader as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_HEADERS),
            "::",
            stringify!(FileHeader)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ROM_HEADERS>())).OptionalHeader as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ROM_HEADERS),
            "::",
            stringify!(OptionalHeader)
        )
    );
}
pub type IMAGE_ROM_HEADERS = _IMAGE_ROM_HEADERS;
pub type PIMAGE_ROM_HEADERS = *mut _IMAGE_ROM_HEADERS;
pub type IMAGE_NT_HEADERS = IMAGE_NT_HEADERS64;
pub type PIMAGE_NT_HEADERS = PIMAGE_NT_HEADERS64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<ANON_OBJECT_HEADER>(),
        32usize,
        concat!("Size of: ", stringify!(ANON_OBJECT_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<ANON_OBJECT_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).Sig1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).Sig2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).Version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).Machine as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).TimeDateStamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).ClassID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(ClassID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER>())).SizeOfData as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER),
            "::",
            stringify!(SizeOfData)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER_V2 {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
    pub Flags: DWORD,
    pub MetaDataSize: DWORD,
    pub MetaDataOffset: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER_V2() {
    assert_eq!(
        ::std::mem::size_of::<ANON_OBJECT_HEADER_V2>(),
        44usize,
        concat!("Size of: ", stringify!(ANON_OBJECT_HEADER_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<ANON_OBJECT_HEADER_V2>(),
        4usize,
        concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER_V2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).Sig1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).Sig2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).Version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).Machine as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).TimeDateStamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).ClassID as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(ClassID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).SizeOfData as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(SizeOfData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).Flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).MetaDataSize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(MetaDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_V2>())).MetaDataOffset as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_V2),
            "::",
            stringify!(MetaDataOffset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ANON_OBJECT_HEADER_BIGOBJ {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub ClassID: CLSID,
    pub SizeOfData: DWORD,
    pub Flags: DWORD,
    pub MetaDataSize: DWORD,
    pub MetaDataOffset: DWORD,
    pub NumberOfSections: DWORD,
    pub PointerToSymbolTable: DWORD,
    pub NumberOfSymbols: DWORD,
}
#[test]
fn bindgen_test_layout_ANON_OBJECT_HEADER_BIGOBJ() {
    assert_eq!(
        ::std::mem::size_of::<ANON_OBJECT_HEADER_BIGOBJ>(),
        56usize,
        concat!("Size of: ", stringify!(ANON_OBJECT_HEADER_BIGOBJ))
    );
    assert_eq!(
        ::std::mem::align_of::<ANON_OBJECT_HEADER_BIGOBJ>(),
        4usize,
        concat!("Alignment of ", stringify!(ANON_OBJECT_HEADER_BIGOBJ))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Sig1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Sig2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Machine as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).TimeDateStamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).ClassID as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(ClassID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).SizeOfData as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(SizeOfData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).Flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).MetaDataSize as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(MetaDataSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).MetaDataOffset as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(MetaDataOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).NumberOfSections as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).PointerToSymbolTable as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(PointerToSymbolTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ANON_OBJECT_HEADER_BIGOBJ>())).NumberOfSymbols as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ANON_OBJECT_HEADER_BIGOBJ),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_SECTION_HEADER {
    pub Name: [BYTE; 8usize],
    pub Misc: _IMAGE_SECTION_HEADER__bindgen_ty_1,
    pub VirtualAddress: DWORD,
    pub SizeOfRawData: DWORD,
    pub PointerToRawData: DWORD,
    pub PointerToRelocations: DWORD,
    pub PointerToLinenumbers: DWORD,
    pub NumberOfRelocations: WORD,
    pub NumberOfLinenumbers: WORD,
    pub Characteristics: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SECTION_HEADER__bindgen_ty_1 {
    pub PhysicalAddress: DWORD,
    pub VirtualSize: DWORD,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SECTION_HEADER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER__bindgen_ty_1>())).PhysicalAddress
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1),
            "::",
            stringify!(PhysicalAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER__bindgen_ty_1>())).VirtualSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER__bindgen_ty_1),
            "::",
            stringify!(VirtualSize)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SECTION_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SECTION_HEADER>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_SECTION_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SECTION_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_SECTION_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).Name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).Misc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Misc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).VirtualAddress as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).SizeOfRawData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(SizeOfRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).PointerToRawData as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).PointerToRelocations as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToRelocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).PointerToLinenumbers as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(PointerToLinenumbers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).NumberOfRelocations as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(NumberOfRelocations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).NumberOfLinenumbers as *const _
                as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SECTION_HEADER>())).Characteristics as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SECTION_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
}
pub type IMAGE_SECTION_HEADER = _IMAGE_SECTION_HEADER;
pub type PIMAGE_SECTION_HEADER = *mut _IMAGE_SECTION_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL {
    pub _bindgen_opaque_blob: [u16; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL))
    );
}
pub type IMAGE_SYMBOL = _IMAGE_SYMBOL;
pub type PIMAGE_SYMBOL = *mut IMAGE_SYMBOL;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL_EX {
    pub _bindgen_opaque_blob: [u16; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_SYMBOL_EX__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL_EX__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL_EX__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__IMAGE_SYMBOL_EX() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SYMBOL_EX>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_SYMBOL_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SYMBOL_EX>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_SYMBOL_EX))
    );
}
pub type IMAGE_SYMBOL_EX = _IMAGE_SYMBOL_EX;
pub type PIMAGE_SYMBOL_EX = *mut IMAGE_SYMBOL_EX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    pub _bindgen_opaque_blob: [u16; 9usize],
}
#[test]
fn bindgen_test_layout_IMAGE_AUX_SYMBOL_TOKEN_DEF() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_AUX_SYMBOL_TOKEN_DEF>(),
        18usize,
        concat!("Size of: ", stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_AUX_SYMBOL_TOKEN_DEF>(),
        2usize,
        concat!("Alignment of ", stringify!(IMAGE_AUX_SYMBOL_TOKEN_DEF))
    );
}
pub type PIMAGE_AUX_SYMBOL_TOKEN_DEF = *mut IMAGE_AUX_SYMBOL_TOKEN_DEF;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL {
    pub Sym: _IMAGE_AUX_SYMBOL__bindgen_ty_1,
    pub File: _IMAGE_AUX_SYMBOL__bindgen_ty_2,
    pub Section: _IMAGE_AUX_SYMBOL__bindgen_ty_3,
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub CRC: _IMAGE_AUX_SYMBOL__bindgen_ty_4,
    _bindgen_union_align: [u16; 9usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 9usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub Linenumber: WORD,
    pub Size: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .Linenumber as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Linenumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1>()))
                .Size as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(Size)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2 {
    pub Function: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1,
    pub Array: _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2,
    _bindgen_union_align: [u16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2 {
    pub Dimension: [WORD; 4usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2>()))
                .Dimension as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(Dimension)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>())).Function
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2>())).Array
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(Array)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_1))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_2 {
    pub Name: [BYTE; 18usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL__bindgen_ty_2>())).Name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_2),
            "::",
            stringify!(Name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_3 {
    pub _bindgen_opaque_blob: [u16; 9usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_3>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_3>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_3))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL__bindgen_ty_4 {
    pub _bindgen_opaque_blob: [u16; 9usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_4>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL__bindgen_ty_4>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL__bindgen_ty_4))
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL>(),
        18usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL>())).Sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(Sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL>())).File as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(File)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL>())).Section as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(Section)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL>())).TokenDef as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(TokenDef)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL>())).CRC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL),
            "::",
            stringify!(CRC)
        )
    );
}
pub type IMAGE_AUX_SYMBOL = _IMAGE_AUX_SYMBOL;
pub type PIMAGE_AUX_SYMBOL = *mut IMAGE_AUX_SYMBOL;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_AUX_SYMBOL_EX {
    pub Sym: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1,
    pub File: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2,
    pub Section: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3,
    pub __bindgen_anon_1: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4,
    pub CRC: _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5,
    _bindgen_union_align: [u16; 10usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_2 {
    pub Name: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2>())).Name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_2),
            "::",
            stringify!(Name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_3 {
    pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_4 {
    pub TokenDef: IMAGE_AUX_SYMBOL_TOKEN_DEF,
    pub rgbReserved: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>())).TokenDef as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4),
            "::",
            stringify!(TokenDef)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4>())).rgbReserved as *const _
                as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_4),
            "::",
            stringify!(rgbReserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_AUX_SYMBOL_EX__bindgen_ty_5 {
    pub _bindgen_opaque_blob: [u16; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_AUX_SYMBOL_EX__bindgen_ty_5)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_AUX_SYMBOL_EX() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_AUX_SYMBOL_EX>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_AUX_SYMBOL_EX))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_AUX_SYMBOL_EX>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_AUX_SYMBOL_EX))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX>())).Sym as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(Sym)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX>())).File as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(File)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX>())).Section as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(Section)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_AUX_SYMBOL_EX>())).CRC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_AUX_SYMBOL_EX),
            "::",
            stringify!(CRC)
        )
    );
}
pub type IMAGE_AUX_SYMBOL_EX = _IMAGE_AUX_SYMBOL_EX;
pub type PIMAGE_AUX_SYMBOL_EX = *mut IMAGE_AUX_SYMBOL_EX;
pub const IMAGE_AUX_SYMBOL_TYPE_IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF: IMAGE_AUX_SYMBOL_TYPE = 1;
pub type IMAGE_AUX_SYMBOL_TYPE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RELOCATION {
    pub _bindgen_opaque_blob: [u16; 5usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RELOCATION__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RELOCATION__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RELOCATION__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_RELOCATION__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RELOCATION__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_RELOCATION__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__IMAGE_RELOCATION() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RELOCATION>(),
        10usize,
        concat!("Size of: ", stringify!(_IMAGE_RELOCATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RELOCATION>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_RELOCATION))
    );
}
pub type IMAGE_RELOCATION = _IMAGE_RELOCATION;
pub type PIMAGE_RELOCATION = *mut IMAGE_RELOCATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_LINENUMBER {
    pub Type: _IMAGE_LINENUMBER__bindgen_ty_1,
    pub Linenumber: WORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_LINENUMBER__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u16; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_LINENUMBER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LINENUMBER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_LINENUMBER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LINENUMBER__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_LINENUMBER__bindgen_ty_1))
    );
}
#[test]
fn bindgen_test_layout__IMAGE_LINENUMBER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LINENUMBER>(),
        6usize,
        concat!("Size of: ", stringify!(_IMAGE_LINENUMBER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LINENUMBER>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_LINENUMBER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_LINENUMBER>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LINENUMBER),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_LINENUMBER>())).Linenumber as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LINENUMBER),
            "::",
            stringify!(Linenumber)
        )
    );
}
pub type IMAGE_LINENUMBER = _IMAGE_LINENUMBER;
pub type PIMAGE_LINENUMBER = *mut IMAGE_LINENUMBER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BASE_RELOCATION {
    pub VirtualAddress: DWORD,
    pub SizeOfBlock: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_BASE_RELOCATION() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_BASE_RELOCATION>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_BASE_RELOCATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_BASE_RELOCATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_BASE_RELOCATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BASE_RELOCATION>())).VirtualAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BASE_RELOCATION),
            "::",
            stringify!(VirtualAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BASE_RELOCATION>())).SizeOfBlock as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BASE_RELOCATION),
            "::",
            stringify!(SizeOfBlock)
        )
    );
}
pub type IMAGE_BASE_RELOCATION = _IMAGE_BASE_RELOCATION;
pub type PIMAGE_BASE_RELOCATION = *mut IMAGE_BASE_RELOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    pub Name: [BYTE; 16usize],
    pub Date: [BYTE; 12usize],
    pub UserID: [BYTE; 6usize],
    pub GroupID: [BYTE; 6usize],
    pub Mode: [BYTE; 8usize],
    pub Size: [BYTE; 10usize],
    pub EndHeader: [BYTE; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ARCHIVE_MEMBER_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARCHIVE_MEMBER_HEADER>(),
        60usize,
        concat!("Size of: ", stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARCHIVE_MEMBER_HEADER>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).Name as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).Date as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Date)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).UserID as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(UserID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).GroupID as *const _ as usize
        },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(GroupID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).Mode as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).Size as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARCHIVE_MEMBER_HEADER>())).EndHeader as *const _ as usize
        },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARCHIVE_MEMBER_HEADER),
            "::",
            stringify!(EndHeader)
        )
    );
}
pub type IMAGE_ARCHIVE_MEMBER_HEADER = _IMAGE_ARCHIVE_MEMBER_HEADER;
pub type PIMAGE_ARCHIVE_MEMBER_HEADER = *mut _IMAGE_ARCHIVE_MEMBER_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_EXPORT_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Name: DWORD,
    pub Base: DWORD,
    pub NumberOfFunctions: DWORD,
    pub NumberOfNames: DWORD,
    pub AddressOfFunctions: DWORD,
    pub AddressOfNames: DWORD,
    pub AddressOfNameOrdinals: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_EXPORT_DIRECTORY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_EXPORT_DIRECTORY>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_EXPORT_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_EXPORT_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_EXPORT_DIRECTORY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).Characteristics as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).TimeDateStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).MajorVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).MinorVersion as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).Name as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).Base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).NumberOfFunctions as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(NumberOfFunctions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).NumberOfNames as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(NumberOfNames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).AddressOfFunctions as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfFunctions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).AddressOfNames as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfNames)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EXPORT_DIRECTORY>())).AddressOfNameOrdinals as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EXPORT_DIRECTORY),
            "::",
            stringify!(AddressOfNameOrdinals)
        )
    );
}
pub type IMAGE_EXPORT_DIRECTORY = _IMAGE_EXPORT_DIRECTORY;
pub type PIMAGE_EXPORT_DIRECTORY = *mut _IMAGE_EXPORT_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_IMPORT_BY_NAME {
    pub Hint: WORD,
    pub Name: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_BY_NAME() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_BY_NAME>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_IMPORT_BY_NAME))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_BY_NAME>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_IMPORT_BY_NAME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_IMPORT_BY_NAME>())).Hint as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_BY_NAME),
            "::",
            stringify!(Hint)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_IMPORT_BY_NAME>())).Name as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_BY_NAME),
            "::",
            stringify!(Name)
        )
    );
}
pub type IMAGE_IMPORT_BY_NAME = _IMAGE_IMPORT_BY_NAME;
pub type PIMAGE_IMPORT_BY_NAME = *mut _IMAGE_IMPORT_BY_NAME;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA64 {
    pub u1: _IMAGE_THUNK_DATA64__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA64__bindgen_ty_1 {
    pub ForwarderString: ULONGLONG,
    pub Function: ULONGLONG,
    pub Ordinal: ULONGLONG,
    pub AddressOfData: ULONGLONG,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA64__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA64__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA64__bindgen_ty_1>())).ForwarderString
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(ForwarderString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA64__bindgen_ty_1>())).Function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA64__bindgen_ty_1>())).Ordinal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA64__bindgen_ty_1>())).AddressOfData as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64__bindgen_ty_1),
            "::",
            stringify!(AddressOfData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA64>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA64>(),
        8usize,
        concat!("Alignment of ", stringify!(_IMAGE_THUNK_DATA64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_THUNK_DATA64>())).u1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA64),
            "::",
            stringify!(u1)
        )
    );
}
pub type IMAGE_THUNK_DATA64 = _IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA64 = *mut IMAGE_THUNK_DATA64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_THUNK_DATA32 {
    pub u1: _IMAGE_THUNK_DATA32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_THUNK_DATA32__bindgen_ty_1 {
    pub ForwarderString: DWORD,
    pub Function: DWORD,
    pub Ordinal: DWORD,
    pub AddressOfData: DWORD,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA32__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA32__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA32__bindgen_ty_1>())).ForwarderString
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(ForwarderString)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA32__bindgen_ty_1>())).Function as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA32__bindgen_ty_1>())).Ordinal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_THUNK_DATA32__bindgen_ty_1>())).AddressOfData as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32__bindgen_ty_1),
            "::",
            stringify!(AddressOfData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_THUNK_DATA32() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_THUNK_DATA32>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_THUNK_DATA32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_THUNK_DATA32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_THUNK_DATA32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_THUNK_DATA32>())).u1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_THUNK_DATA32),
            "::",
            stringify!(u1)
        )
    );
}
pub type IMAGE_THUNK_DATA32 = _IMAGE_THUNK_DATA32;
pub type PIMAGE_THUNK_DATA32 = *mut IMAGE_THUNK_DATA32;
pub type PIMAGE_TLS_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(DllHandle: PVOID, Reason: DWORD, Reserved: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY64 {
    pub _bindgen_opaque_blob: [u32; 10usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY64__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_TLS_DIRECTORY64__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn Alignment(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Alignment(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: DWORD,
        Alignment: DWORD,
        Reserved1: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let Alignment: u32 = unsafe { ::std::mem::transmute(Alignment) };
            Alignment as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY64__bindgen_ty_1>())).Characteristics
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY64__bindgen_ty_1),
            "::",
            stringify!(Characteristics)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY64>(),
        40usize,
        concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY64))
    );
}
pub type IMAGE_TLS_DIRECTORY64 = _IMAGE_TLS_DIRECTORY64;
pub type PIMAGE_TLS_DIRECTORY64 = *mut IMAGE_TLS_DIRECTORY64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32 {
    pub StartAddressOfRawData: DWORD,
    pub EndAddressOfRawData: DWORD,
    pub AddressOfIndex: DWORD,
    pub AddressOfCallBacks: DWORD,
    pub SizeOfZeroFill: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY32__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_TLS_DIRECTORY32__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub __bindgen_anon_1: _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_TLS_DIRECTORY32__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Reserved0(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 20u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 20u8, val as u64)
        }
    }
    #[inline]
    pub fn Alignment(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Alignment(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Reserved0: DWORD,
        Alignment: DWORD,
        Reserved1: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 20u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(20usize, 4u8, {
            let Alignment: u32 = unsafe { ::std::mem::transmute(Alignment) };
            Alignment as u64
        });
        __bindgen_bitfield_unit.set(24usize, 8u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY32__bindgen_ty_1>())).Characteristics
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32__bindgen_ty_1),
            "::",
            stringify!(Characteristics)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_TLS_DIRECTORY32() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_TLS_DIRECTORY32>(),
        24usize,
        concat!("Size of: ", stringify!(_IMAGE_TLS_DIRECTORY32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_TLS_DIRECTORY32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_TLS_DIRECTORY32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY32>())).StartAddressOfRawData as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(StartAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY32>())).EndAddressOfRawData as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(EndAddressOfRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY32>())).AddressOfIndex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(AddressOfIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY32>())).AddressOfCallBacks as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(AddressOfCallBacks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_TLS_DIRECTORY32>())).SizeOfZeroFill as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_TLS_DIRECTORY32),
            "::",
            stringify!(SizeOfZeroFill)
        )
    );
}
pub type IMAGE_TLS_DIRECTORY32 = _IMAGE_TLS_DIRECTORY32;
pub type PIMAGE_TLS_DIRECTORY32 = *mut IMAGE_TLS_DIRECTORY32;
pub type IMAGE_THUNK_DATA = IMAGE_THUNK_DATA64;
pub type PIMAGE_THUNK_DATA = PIMAGE_THUNK_DATA64;
pub type IMAGE_TLS_DIRECTORY = IMAGE_TLS_DIRECTORY64;
pub type PIMAGE_TLS_DIRECTORY = PIMAGE_TLS_DIRECTORY64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_IMPORT_DESCRIPTOR {
    pub __bindgen_anon_1: _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1,
    pub TimeDateStamp: DWORD,
    pub ForwarderChain: DWORD,
    pub Name: DWORD,
    pub FirstThunk: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1 {
    pub Characteristics: DWORD,
    pub OriginalFirstThunk: DWORD,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>())).Characteristics
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1>())).OriginalFirstThunk
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(OriginalFirstThunk)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_IMPORT_DESCRIPTOR>())).TimeDateStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_IMPORT_DESCRIPTOR>())).ForwarderChain as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(ForwarderChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_IMPORT_DESCRIPTOR>())).Name as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_IMPORT_DESCRIPTOR>())).FirstThunk as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_IMPORT_DESCRIPTOR),
            "::",
            stringify!(FirstThunk)
        )
    );
}
pub type IMAGE_IMPORT_DESCRIPTOR = _IMAGE_IMPORT_DESCRIPTOR;
pub type PIMAGE_IMPORT_DESCRIPTOR = *mut IMAGE_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    pub TimeDateStamp: DWORD,
    pub OffsetModuleName: WORD,
    pub NumberOfModuleForwarderRefs: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_BOUND_IMPORT_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>())).TimeDateStamp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>())).OffsetModuleName as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR),
            "::",
            stringify!(OffsetModuleName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BOUND_IMPORT_DESCRIPTOR>())).NumberOfModuleForwarderRefs
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_IMPORT_DESCRIPTOR),
            "::",
            stringify!(NumberOfModuleForwarderRefs)
        )
    );
}
pub type IMAGE_BOUND_IMPORT_DESCRIPTOR = _IMAGE_BOUND_IMPORT_DESCRIPTOR;
pub type PIMAGE_BOUND_IMPORT_DESCRIPTOR = *mut _IMAGE_BOUND_IMPORT_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_BOUND_FORWARDER_REF {
    pub TimeDateStamp: DWORD,
    pub OffsetModuleName: WORD,
    pub Reserved: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_BOUND_FORWARDER_REF() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_BOUND_FORWARDER_REF>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_BOUND_FORWARDER_REF))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_BOUND_FORWARDER_REF>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_BOUND_FORWARDER_REF))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BOUND_FORWARDER_REF>())).TimeDateStamp as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_FORWARDER_REF),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BOUND_FORWARDER_REF>())).OffsetModuleName as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_FORWARDER_REF),
            "::",
            stringify!(OffsetModuleName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_BOUND_FORWARDER_REF>())).Reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_BOUND_FORWARDER_REF),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_BOUND_FORWARDER_REF = _IMAGE_BOUND_FORWARDER_REF;
pub type PIMAGE_BOUND_FORWARDER_REF = *mut _IMAGE_BOUND_FORWARDER_REF;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    pub Attributes: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1,
    pub DllNameRVA: DWORD,
    pub ModuleHandleRVA: DWORD,
    pub ImportAddressTableRVA: DWORD,
    pub ImportNameTableRVA: DWORD,
    pub BoundImportAddressTableRVA: DWORD,
    pub UnloadInformationTableRVA: DWORD,
    pub TimeDateStamp: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1 {
    pub AllAttributes: DWORD,
    pub __bindgen_anon_1: _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn RvaBased(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RvaBased(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ReservedAttributes(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_ReservedAttributes(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        RvaBased: DWORD,
        ReservedAttributes: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let RvaBased: u32 = unsafe { ::std::mem::transmute(RvaBased) };
            RvaBased as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let ReservedAttributes: u32 = unsafe { ::std::mem::transmute(ReservedAttributes) };
            ReservedAttributes as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1>())).AllAttributes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR__bindgen_ty_1),
            "::",
            stringify!(AllAttributes)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_DELAYLOAD_DESCRIPTOR() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DELAYLOAD_DESCRIPTOR>(),
        32usize,
        concat!("Size of: ", stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DELAYLOAD_DESCRIPTOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).Attributes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(Attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).DllNameRVA as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(DllNameRVA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).ModuleHandleRVA as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(ModuleHandleRVA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).ImportAddressTableRVA
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(ImportAddressTableRVA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).ImportNameTableRVA as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(ImportNameTableRVA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).BoundImportAddressTableRVA
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(BoundImportAddressTableRVA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).UnloadInformationTableRVA
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(UnloadInformationTableRVA)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DELAYLOAD_DESCRIPTOR>())).TimeDateStamp as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DELAYLOAD_DESCRIPTOR),
            "::",
            stringify!(TimeDateStamp)
        )
    );
}
pub type IMAGE_DELAYLOAD_DESCRIPTOR = _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PIMAGE_DELAYLOAD_DESCRIPTOR = *mut _IMAGE_DELAYLOAD_DESCRIPTOR;
pub type PCIMAGE_DELAYLOAD_DESCRIPTOR = *const IMAGE_DELAYLOAD_DESCRIPTOR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub NumberOfNamedEntries: WORD,
    pub NumberOfIdEntries: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIRECTORY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY>())).Characteristics as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY>())).TimeDateStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY>())).MajorVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY>())).MinorVersion as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY>())).NumberOfNamedEntries as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(NumberOfNamedEntries)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY>())).NumberOfIdEntries as *const _
                as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY),
            "::",
            stringify!(NumberOfIdEntries)
        )
    );
}
pub type IMAGE_RESOURCE_DIRECTORY = _IMAGE_RESOURCE_DIRECTORY;
pub type PIMAGE_RESOURCE_DIRECTORY = *mut _IMAGE_RESOURCE_DIRECTORY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1,
    pub __bindgen_anon_2: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1 {
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1,
    pub Name: DWORD,
    pub Id: WORD,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn NameOffset(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_NameOffset(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn NameIsString(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NameIsString(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NameOffset: DWORD,
        NameIsString: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let NameOffset: u32 = unsafe { ::std::mem::transmute(NameOffset) };
            NameOffset as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let NameIsString: u32 = unsafe { ::std::mem::transmute(NameIsString) };
            NameIsString as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>())).Name
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Name)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1>())).Id as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2 {
    pub OffsetToData: DWORD,
    pub __bindgen_anon_1: _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1)
        )
    );
}
impl _IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2__bindgen_ty_1 {
    #[inline]
    pub fn OffsetToDirectory(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_OffsetToDirectory(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn DataIsDirectory(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DataIsDirectory(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        OffsetToDirectory: DWORD,
        DataIsDirectory: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 31u8, {
            let OffsetToDirectory: u32 = unsafe { ::std::mem::transmute(OffsetToDirectory) };
            OffsetToDirectory as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DataIsDirectory: u32 = unsafe { ::std::mem::transmute(DataIsDirectory) };
            DataIsDirectory as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2>())).OffsetToData
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY__bindgen_ty_2),
            "::",
            stringify!(OffsetToData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIRECTORY_ENTRY))
    );
}
pub type IMAGE_RESOURCE_DIRECTORY_ENTRY = _IMAGE_RESOURCE_DIRECTORY_ENTRY;
pub type PIMAGE_RESOURCE_DIRECTORY_ENTRY = *mut _IMAGE_RESOURCE_DIRECTORY_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    pub Length: WORD,
    pub NameString: [CHAR; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIRECTORY_STRING() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIRECTORY_STRING>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIRECTORY_STRING>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY_STRING>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIRECTORY_STRING>())).NameString as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIRECTORY_STRING),
            "::",
            stringify!(NameString)
        )
    );
}
pub type IMAGE_RESOURCE_DIRECTORY_STRING = _IMAGE_RESOURCE_DIRECTORY_STRING;
pub type PIMAGE_RESOURCE_DIRECTORY_STRING = *mut _IMAGE_RESOURCE_DIRECTORY_STRING;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DIR_STRING_U {
    pub Length: WORD,
    pub NameString: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DIR_STRING_U() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DIR_STRING_U>(),
        4usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DIR_STRING_U))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DIR_STRING_U>(),
        2usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DIR_STRING_U))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIR_STRING_U>())).Length as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIR_STRING_U),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DIR_STRING_U>())).NameString as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DIR_STRING_U),
            "::",
            stringify!(NameString)
        )
    );
}
pub type IMAGE_RESOURCE_DIR_STRING_U = _IMAGE_RESOURCE_DIR_STRING_U;
pub type PIMAGE_RESOURCE_DIR_STRING_U = *mut _IMAGE_RESOURCE_DIR_STRING_U;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_RESOURCE_DATA_ENTRY {
    pub OffsetToData: DWORD,
    pub Size: DWORD,
    pub CodePage: DWORD,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_RESOURCE_DATA_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RESOURCE_DATA_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_RESOURCE_DATA_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RESOURCE_DATA_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RESOURCE_DATA_ENTRY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DATA_ENTRY>())).OffsetToData as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(OffsetToData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_RESOURCE_DATA_ENTRY>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DATA_ENTRY>())).CodePage as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(CodePage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RESOURCE_DATA_ENTRY>())).Reserved as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RESOURCE_DATA_ENTRY),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_RESOURCE_DATA_ENTRY = _IMAGE_RESOURCE_DATA_ENTRY;
pub type PIMAGE_RESOURCE_DATA_ENTRY = *mut _IMAGE_RESOURCE_DATA_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY {
    pub Flags: WORD,
    pub Catalog: WORD,
    pub CatalogOffset: DWORD,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_LOAD_CONFIG_CODE_INTEGRITY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>(),
        12usize,
        concat!("Size of: ", stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>())).Flags as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>())).Catalog as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY),
            "::",
            stringify!(Catalog)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>())).CatalogOffset as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY),
            "::",
            stringify!(CatalogOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_CODE_INTEGRITY>())).Reserved as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_CODE_INTEGRITY),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_LOAD_CONFIG_CODE_INTEGRITY = _IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
pub type PIMAGE_LOAD_CONFIG_CODE_INTEGRITY = *mut _IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION_TABLE {
    pub Version: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION_TABLE() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION_TABLE>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION_TABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION_TABLE>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION_TABLE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION_TABLE>())).Version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION_TABLE),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION_TABLE>())).Size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION_TABLE),
            "::",
            stringify!(Size)
        )
    );
}
pub type IMAGE_DYNAMIC_RELOCATION_TABLE = _IMAGE_DYNAMIC_RELOCATION_TABLE;
pub type PIMAGE_DYNAMIC_RELOCATION_TABLE = *mut _IMAGE_DYNAMIC_RELOCATION_TABLE;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION32 {
    pub Symbol: DWORD,
    pub BaseRelocSize: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION32() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION32>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION32>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32>())).Symbol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32),
            "::",
            stringify!(Symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32>())).BaseRelocSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32),
            "::",
            stringify!(BaseRelocSize)
        )
    );
}
pub type IMAGE_DYNAMIC_RELOCATION32 = _IMAGE_DYNAMIC_RELOCATION32;
pub type PIMAGE_DYNAMIC_RELOCATION32 = *mut _IMAGE_DYNAMIC_RELOCATION32;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION64 {
    pub Symbol: ULONGLONG,
    pub BaseRelocSize: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION64>(),
        12usize,
        concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION64>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION64))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64>())).Symbol as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64),
            "::",
            stringify!(Symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64>())).BaseRelocSize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64),
            "::",
            stringify!(BaseRelocSize)
        )
    );
}
pub type IMAGE_DYNAMIC_RELOCATION64 = _IMAGE_DYNAMIC_RELOCATION64;
pub type PIMAGE_DYNAMIC_RELOCATION64 = *mut _IMAGE_DYNAMIC_RELOCATION64;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION32_V2 {
    pub HeaderSize: DWORD,
    pub FixupInfoSize: DWORD,
    pub Symbol: DWORD,
    pub SymbolGroup: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION32_V2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION32_V2>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION32_V2>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32_V2>())).HeaderSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2),
            "::",
            stringify!(HeaderSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32_V2>())).FixupInfoSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2),
            "::",
            stringify!(FixupInfoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32_V2>())).Symbol as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2),
            "::",
            stringify!(Symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32_V2>())).SymbolGroup as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2),
            "::",
            stringify!(SymbolGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION32_V2>())).Flags as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION32_V2),
            "::",
            stringify!(Flags)
        )
    );
}
pub type IMAGE_DYNAMIC_RELOCATION32_V2 = _IMAGE_DYNAMIC_RELOCATION32_V2;
pub type PIMAGE_DYNAMIC_RELOCATION32_V2 = *mut _IMAGE_DYNAMIC_RELOCATION32_V2;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DYNAMIC_RELOCATION64_V2 {
    pub HeaderSize: DWORD,
    pub FixupInfoSize: DWORD,
    pub Symbol: ULONGLONG,
    pub SymbolGroup: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DYNAMIC_RELOCATION64_V2() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DYNAMIC_RELOCATION64_V2>(),
        24usize,
        concat!("Size of: ", stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DYNAMIC_RELOCATION64_V2>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64_V2>())).HeaderSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2),
            "::",
            stringify!(HeaderSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64_V2>())).FixupInfoSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2),
            "::",
            stringify!(FixupInfoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64_V2>())).Symbol as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2),
            "::",
            stringify!(Symbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64_V2>())).SymbolGroup as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2),
            "::",
            stringify!(SymbolGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DYNAMIC_RELOCATION64_V2>())).Flags as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DYNAMIC_RELOCATION64_V2),
            "::",
            stringify!(Flags)
        )
    );
}
pub type IMAGE_DYNAMIC_RELOCATION64_V2 = _IMAGE_DYNAMIC_RELOCATION64_V2;
pub type PIMAGE_DYNAMIC_RELOCATION64_V2 = *mut _IMAGE_DYNAMIC_RELOCATION64_V2;
pub type IMAGE_DYNAMIC_RELOCATION = IMAGE_DYNAMIC_RELOCATION64;
pub type PIMAGE_DYNAMIC_RELOCATION = PIMAGE_DYNAMIC_RELOCATION64;
pub type IMAGE_DYNAMIC_RELOCATION_V2 = IMAGE_DYNAMIC_RELOCATION64_V2;
pub type PIMAGE_DYNAMIC_RELOCATION_V2 = PIMAGE_DYNAMIC_RELOCATION64_V2;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER {
    pub PrologueByteCount: BYTE,
}
#[test]
fn bindgen_test_layout__IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER>(),
        1usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER>())).PrologueByteCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER),
            "::",
            stringify!(PrologueByteCount)
        )
    );
}
pub type IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
pub type PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER = *mut IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER {
    pub EpilogueCount: DWORD,
    pub EpilogueByteCount: BYTE,
    pub BranchDescriptorElementSize: BYTE,
    pub BranchDescriptorCount: WORD,
}
#[test]
fn bindgen_test_layout__IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>())).EpilogueCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER),
            "::",
            stringify!(EpilogueCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>())).EpilogueByteCount
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER),
            "::",
            stringify!(EpilogueByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>()))
                .BranchDescriptorElementSize as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER),
            "::",
            stringify!(BranchDescriptorElementSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER>()))
                .BranchDescriptorCount as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER),
            "::",
            stringify!(BranchDescriptorCount)
        )
    );
}
pub type IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
pub type PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER = *mut IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION)
        )
    );
}
impl _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    #[inline]
    pub fn PageRelativeOffset(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u32) }
    }
    #[inline]
    pub fn set_PageRelativeOffset(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn IndirectCall(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IndirectCall(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IATIndex(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 19u8) as u32) }
    }
    #[inline]
    pub fn set_IATIndex(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 19u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageRelativeOffset: DWORD,
        IndirectCall: DWORD,
        IATIndex: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageRelativeOffset: u32 = unsafe { ::std::mem::transmute(PageRelativeOffset) };
            PageRelativeOffset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let IndirectCall: u32 = unsafe { ::std::mem::transmute(IndirectCall) };
            IndirectCall as u64
        });
        __bindgen_bitfield_unit.set(13usize, 19u8, {
            let IATIndex: u32 = unsafe { ::std::mem::transmute(IATIndex) };
            IATIndex as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub type PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    *mut IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout__IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION)
        )
    );
}
impl _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION {
    #[inline]
    pub fn PageRelativeOffset(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_PageRelativeOffset(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn IndirectCall(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_IndirectCall(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RexWPrefix(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_RexWPrefix(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CfgCheck(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_CfgCheck(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageRelativeOffset: WORD,
        IndirectCall: WORD,
        RexWPrefix: WORD,
        CfgCheck: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageRelativeOffset: u16 = unsafe { ::std::mem::transmute(PageRelativeOffset) };
            PageRelativeOffset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let IndirectCall: u16 = unsafe { ::std::mem::transmute(IndirectCall) };
            IndirectCall as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let RexWPrefix: u16 = unsafe { ::std::mem::transmute(RexWPrefix) };
            RexWPrefix as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let CfgCheck: u16 = unsafe { ::std::mem::transmute(CfgCheck) };
            CfgCheck as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
pub type PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION =
    *mut IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[test]
fn bindgen_test_layout__IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION)
        )
    );
}
impl _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION {
    #[inline]
    pub fn PageRelativeOffset(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u16) }
    }
    #[inline]
    pub fn set_PageRelativeOffset(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn RegisterNumber(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_RegisterNumber(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PageRelativeOffset: WORD,
        RegisterNumber: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let PageRelativeOffset: u16 = unsafe { ::std::mem::transmute(PageRelativeOffset) };
            PageRelativeOffset as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let RegisterNumber: u16 = unsafe { ::std::mem::transmute(RegisterNumber) };
            RegisterNumber as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION = _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
pub type PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION =
    *mut IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    pub Size: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub GlobalFlagsClear: DWORD,
    pub GlobalFlagsSet: DWORD,
    pub CriticalSectionDefaultTimeout: DWORD,
    pub DeCommitFreeBlockThreshold: DWORD,
    pub DeCommitTotalFreeThreshold: DWORD,
    pub LockPrefixTable: DWORD,
    pub MaximumAllocationSize: DWORD,
    pub VirtualMemoryThreshold: DWORD,
    pub ProcessHeapFlags: DWORD,
    pub ProcessAffinityMask: DWORD,
    pub CSDVersion: WORD,
    pub DependentLoadFlags: WORD,
    pub EditList: DWORD,
    pub SecurityCookie: DWORD,
    pub SEHandlerTable: DWORD,
    pub SEHandlerCount: DWORD,
    pub GuardCFCheckFunctionPointer: DWORD,
    pub GuardCFDispatchFunctionPointer: DWORD,
    pub GuardCFFunctionTable: DWORD,
    pub GuardCFFunctionCount: DWORD,
    pub GuardFlags: DWORD,
    pub CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    pub GuardAddressTakenIatEntryTable: DWORD,
    pub GuardAddressTakenIatEntryCount: DWORD,
    pub GuardLongJumpTargetTable: DWORD,
    pub GuardLongJumpTargetCount: DWORD,
    pub DynamicValueRelocTable: DWORD,
    pub CHPEMetadataPointer: DWORD,
    pub GuardRFFailureRoutine: DWORD,
    pub GuardRFFailureRoutineFunctionPointer: DWORD,
    pub DynamicValueRelocTableOffset: DWORD,
    pub DynamicValueRelocTableSection: WORD,
    pub Reserved2: WORD,
    pub GuardRFVerifyStackPointerFunctionPointer: DWORD,
    pub HotPatchTableOffset: DWORD,
    pub Reserved3: DWORD,
    pub EnclaveConfigurationPointer: DWORD,
    pub VolatileMetadataPointer: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_LOAD_CONFIG_DIRECTORY32() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LOAD_CONFIG_DIRECTORY32>(),
        164usize,
        concat!("Size of: ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LOAD_CONFIG_DIRECTORY32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).Size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).TimeDateStamp as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).MajorVersion as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).MinorVersion as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GlobalFlagsClear as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GlobalFlagsClear)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GlobalFlagsSet as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GlobalFlagsSet)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).CriticalSectionDefaultTimeout
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(CriticalSectionDefaultTimeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).DeCommitFreeBlockThreshold
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DeCommitFreeBlockThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).DeCommitTotalFreeThreshold
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DeCommitTotalFreeThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).LockPrefixTable as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(LockPrefixTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).MaximumAllocationSize
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(MaximumAllocationSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).VirtualMemoryThreshold
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(VirtualMemoryThreshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).ProcessHeapFlags as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(ProcessHeapFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).ProcessAffinityMask
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(ProcessAffinityMask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).CSDVersion as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(CSDVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).DependentLoadFlags
                as *const _ as usize
        },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DependentLoadFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).EditList as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(EditList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).SecurityCookie as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(SecurityCookie)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).SEHandlerTable as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(SEHandlerTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).SEHandlerCount as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(SEHandlerCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardCFCheckFunctionPointer
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardCFCheckFunctionPointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>()))
                .GuardCFDispatchFunctionPointer as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardCFDispatchFunctionPointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardCFFunctionTable
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardCFFunctionTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardCFFunctionCount
                as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardCFFunctionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardFlags as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).CodeIntegrity as *const _
                as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(CodeIntegrity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>()))
                .GuardAddressTakenIatEntryTable as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardAddressTakenIatEntryTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>()))
                .GuardAddressTakenIatEntryCount as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardAddressTakenIatEntryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardLongJumpTargetTable
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardLongJumpTargetTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardLongJumpTargetCount
                as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardLongJumpTargetCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).DynamicValueRelocTable
                as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DynamicValueRelocTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).CHPEMetadataPointer
                as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(CHPEMetadataPointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).GuardRFFailureRoutine
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardRFFailureRoutine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>()))
                .GuardRFFailureRoutineFunctionPointer as *const _ as usize
        },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardRFFailureRoutineFunctionPointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).DynamicValueRelocTableOffset
                as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DynamicValueRelocTableOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).DynamicValueRelocTableSection
                as *const _ as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(DynamicValueRelocTableSection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).Reserved2 as *const _
                as usize
        },
        142usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>()))
                .GuardRFVerifyStackPointerFunctionPointer as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(GuardRFVerifyStackPointerFunctionPointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).HotPatchTableOffset
                as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(HotPatchTableOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).Reserved3 as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).EnclaveConfigurationPointer
                as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(EnclaveConfigurationPointer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_LOAD_CONFIG_DIRECTORY32>())).VolatileMetadataPointer
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY32),
            "::",
            stringify!(VolatileMetadataPointer)
        )
    );
}
pub type IMAGE_LOAD_CONFIG_DIRECTORY32 = _IMAGE_LOAD_CONFIG_DIRECTORY32;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY32 = *mut _IMAGE_LOAD_CONFIG_DIRECTORY32;
#[repr(C)]
pub struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    pub _bindgen_opaque_blob: [u32; 66usize],
}
#[test]
fn bindgen_test_layout__IMAGE_LOAD_CONFIG_DIRECTORY64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_LOAD_CONFIG_DIRECTORY64>(),
        264usize,
        concat!("Size of: ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_LOAD_CONFIG_DIRECTORY64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_LOAD_CONFIG_DIRECTORY64))
    );
}
pub type IMAGE_LOAD_CONFIG_DIRECTORY64 = _IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY64 = *mut _IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type IMAGE_LOAD_CONFIG_DIRECTORY = IMAGE_LOAD_CONFIG_DIRECTORY64;
pub type PIMAGE_LOAD_CONFIG_DIRECTORY = PIMAGE_LOAD_CONFIG_DIRECTORY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_HOT_PATCH_INFO {
    pub Version: DWORD,
    pub Size: DWORD,
    pub SequenceNumber: DWORD,
    pub BaseImageList: DWORD,
    pub BaseImageCount: DWORD,
    pub BufferOffset: DWORD,
    pub ExtraPatchSize: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_HOT_PATCH_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_HOT_PATCH_INFO>(),
        28usize,
        concat!("Size of: ", stringify!(_IMAGE_HOT_PATCH_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_HOT_PATCH_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_HOT_PATCH_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).Size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).SequenceNumber as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(SequenceNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).BaseImageList as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(BaseImageList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).BaseImageCount as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(BaseImageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).BufferOffset as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(BufferOffset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_INFO>())).ExtraPatchSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_INFO),
            "::",
            stringify!(ExtraPatchSize)
        )
    );
}
pub type IMAGE_HOT_PATCH_INFO = _IMAGE_HOT_PATCH_INFO;
pub type PIMAGE_HOT_PATCH_INFO = *mut _IMAGE_HOT_PATCH_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_HOT_PATCH_BASE {
    pub SequenceNumber: DWORD,
    pub Flags: DWORD,
    pub OriginalTimeDateStamp: DWORD,
    pub OriginalCheckSum: DWORD,
    pub CodeIntegrityInfo: DWORD,
    pub CodeIntegritySize: DWORD,
    pub PatchTable: DWORD,
    pub BufferOffset: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_HOT_PATCH_BASE() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_HOT_PATCH_BASE>(),
        32usize,
        concat!("Size of: ", stringify!(_IMAGE_HOT_PATCH_BASE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_HOT_PATCH_BASE>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_HOT_PATCH_BASE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).SequenceNumber as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(SequenceNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).Flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).OriginalTimeDateStamp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(OriginalTimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).OriginalCheckSum as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(OriginalCheckSum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).CodeIntegrityInfo as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(CodeIntegrityInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).CodeIntegritySize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(CodeIntegritySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).PatchTable as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(PatchTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_BASE>())).BufferOffset as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_BASE),
            "::",
            stringify!(BufferOffset)
        )
    );
}
pub type IMAGE_HOT_PATCH_BASE = _IMAGE_HOT_PATCH_BASE;
pub type PIMAGE_HOT_PATCH_BASE = *mut _IMAGE_HOT_PATCH_BASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_HOT_PATCH_HASHES {
    pub SHA256: [BYTE; 32usize],
    pub SHA1: [BYTE; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_HOT_PATCH_HASHES() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_HOT_PATCH_HASHES>(),
        52usize,
        concat!("Size of: ", stringify!(_IMAGE_HOT_PATCH_HASHES))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_HOT_PATCH_HASHES>(),
        1usize,
        concat!("Alignment of ", stringify!(_IMAGE_HOT_PATCH_HASHES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_HASHES>())).SHA256 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_HASHES),
            "::",
            stringify!(SHA256)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_HOT_PATCH_HASHES>())).SHA1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_HOT_PATCH_HASHES),
            "::",
            stringify!(SHA1)
        )
    );
}
pub type IMAGE_HOT_PATCH_HASHES = _IMAGE_HOT_PATCH_HASHES;
pub type PIMAGE_HOT_PATCH_HASHES = *mut _IMAGE_HOT_PATCH_HASHES;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    pub FuncStart: DWORD,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
}
#[test]
fn bindgen_test_layout__IMAGE_CE_RUNTIME_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_CE_RUNTIME_FUNCTION_ENTRY>())).FuncStart as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_CE_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(FuncStart)
        )
    );
}
impl _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    #[inline]
    pub fn PrologLen(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_PrologLen(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn FuncLen(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 22u8) as u32) }
    }
    #[inline]
    pub fn set_FuncLen(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 22u8, val as u64)
        }
    }
    #[inline]
    pub fn ThirtyTwoBit(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ThirtyTwoBit(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionFlag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ExceptionFlag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PrologLen: DWORD,
        FuncLen: DWORD,
        ThirtyTwoBit: DWORD,
        ExceptionFlag: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let PrologLen: u32 = unsafe { ::std::mem::transmute(PrologLen) };
            PrologLen as u64
        });
        __bindgen_bitfield_unit.set(8usize, 22u8, {
            let FuncLen: u32 = unsafe { ::std::mem::transmute(FuncLen) };
            FuncLen as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let ThirtyTwoBit: u32 = unsafe { ::std::mem::transmute(ThirtyTwoBit) };
            ThirtyTwoBit as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let ExceptionFlag: u32 = unsafe { ::std::mem::transmute(ExceptionFlag) };
            ExceptionFlag as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_CE_RUNTIME_FUNCTION_ENTRY = _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_CE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_CE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindData: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Flag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Flag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn Ret(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Ret(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn H(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_H(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reg(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_Reg(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn R(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_R(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn L(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_L(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn C(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_C(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StackAdjust(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 10u8) as u32) }
    }
    #[inline]
    pub fn set_StackAdjust(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 10u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flag: DWORD,
        FunctionLength: DWORD,
        Ret: DWORD,
        H: DWORD,
        Reg: DWORD,
        R: DWORD,
        L: DWORD,
        C: DWORD,
        StackAdjust: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Flag: u32 = unsafe { ::std::mem::transmute(Flag) };
            Flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 2u8, {
            let Ret: u32 = unsafe { ::std::mem::transmute(Ret) };
            Ret as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let H: u32 = unsafe { ::std::mem::transmute(H) };
            H as u64
        });
        __bindgen_bitfield_unit.set(16usize, 3u8, {
            let Reg: u32 = unsafe { ::std::mem::transmute(Reg) };
            Reg as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let R: u32 = unsafe { ::std::mem::transmute(R) };
            R as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let L: u32 = unsafe { ::std::mem::transmute(L) };
            L as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let C: u32 = unsafe { ::std::mem::transmute(C) };
            C as u64
        });
        __bindgen_bitfield_unit.set(22usize, 10u8, {
            let StackAdjust: u32 = unsafe { ::std::mem::transmute(StackAdjust) };
            StackAdjust as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>())).UnwindData
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_ARM_RUNTIME_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
}
pub type IMAGE_ARM_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindData: DWORD,
    pub __bindgen_anon_1: _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn Flag(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_Flag(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FunctionLength(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 11u8) as u32) }
    }
    #[inline]
    pub fn set_FunctionLength(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn RegF(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_RegF(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn RegI(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_RegI(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn H(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_H(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn CR(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_CR(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn FrameSize(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 9u8) as u32) }
    }
    #[inline]
    pub fn set_FrameSize(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 9u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Flag: DWORD,
        FunctionLength: DWORD,
        RegF: DWORD,
        RegI: DWORD,
        H: DWORD,
        CR: DWORD,
        FrameSize: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Flag: u32 = unsafe { ::std::mem::transmute(Flag) };
            Flag as u64
        });
        __bindgen_bitfield_unit.set(2usize, 11u8, {
            let FunctionLength: u32 = unsafe { ::std::mem::transmute(FunctionLength) };
            FunctionLength as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let RegF: u32 = unsafe { ::std::mem::transmute(RegF) };
            RegF as u64
        });
        __bindgen_bitfield_unit.set(16usize, 4u8, {
            let RegI: u32 = unsafe { ::std::mem::transmute(RegI) };
            RegI as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let H: u32 = unsafe { ::std::mem::transmute(H) };
            H as u64
        });
        __bindgen_bitfield_unit.set(21usize, 2u8, {
            let CR: u32 = unsafe { ::std::mem::transmute(CR) };
            CR as u64
        });
        __bindgen_bitfield_unit.set(23usize, 9u8, {
            let FrameSize: u32 = unsafe { ::std::mem::transmute(FrameSize) };
            FrameSize as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>())).UnwindData
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
}
pub type IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    pub _bindgen_opaque_blob: [u32; 10usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY)
        )
    );
}
pub type IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub ExceptionHandler: DWORD,
    pub HandlerData: DWORD,
    pub PrologEndAddress: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>(),
        20usize,
        concat!("Size of: ", stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>())).EndAddress as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(EndAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>())).ExceptionHandler
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(ExceptionHandler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>())).HandlerData as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(HandlerData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY>())).PrologEndAddress
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(PrologEndAddress)
        )
    );
}
pub type IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    pub BeginAddress: DWORD,
    pub EndAddress: DWORD,
    pub __bindgen_anon_1: _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1 {
    pub UnwindInfoAddress: DWORD,
    pub UnwindData: DWORD,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout__IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>()))
                .UnwindInfoAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindInfoAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1>())).UnwindData
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnwindData)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_RUNTIME_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY>(),
        12usize,
        concat!("Size of: ", stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_RUNTIME_FUNCTION_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RUNTIME_FUNCTION_ENTRY>())).BeginAddress as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(BeginAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_RUNTIME_FUNCTION_ENTRY>())).EndAddress as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_RUNTIME_FUNCTION_ENTRY),
            "::",
            stringify!(EndAddress)
        )
    );
}
pub type _PIMAGE_RUNTIME_FUNCTION_ENTRY = *mut _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
pub type IMAGE_RUNTIME_FUNCTION_ENTRY = _IMAGE_RUNTIME_FUNCTION_ENTRY;
pub type PIMAGE_RUNTIME_FUNCTION_ENTRY = _PIMAGE_RUNTIME_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ENCLAVE_CONFIG32 {
    pub Size: DWORD,
    pub MinimumRequiredConfigSize: DWORD,
    pub PolicyFlags: DWORD,
    pub NumberOfImports: DWORD,
    pub ImportList: DWORD,
    pub ImportEntrySize: DWORD,
    pub FamilyID: [BYTE; 16usize],
    pub ImageID: [BYTE; 16usize],
    pub ImageVersion: DWORD,
    pub SecurityVersion: DWORD,
    pub EnclaveSize: DWORD,
    pub NumberOfThreads: DWORD,
    pub EnclaveFlags: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_ENCLAVE_CONFIG32() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ENCLAVE_CONFIG32>(),
        76usize,
        concat!("Size of: ", stringify!(_IMAGE_ENCLAVE_CONFIG32))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ENCLAVE_CONFIG32>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ENCLAVE_CONFIG32))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).MinimumRequiredConfigSize
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(MinimumRequiredConfigSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).PolicyFlags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(PolicyFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).NumberOfImports as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(NumberOfImports)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).ImportList as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(ImportList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).ImportEntrySize as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(ImportEntrySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).FamilyID as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(FamilyID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).ImageID as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(ImageID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).ImageVersion as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(ImageVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).SecurityVersion as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(SecurityVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).EnclaveSize as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(EnclaveSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).NumberOfThreads as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(NumberOfThreads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_CONFIG32>())).EnclaveFlags as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_CONFIG32),
            "::",
            stringify!(EnclaveFlags)
        )
    );
}
pub type IMAGE_ENCLAVE_CONFIG32 = _IMAGE_ENCLAVE_CONFIG32;
pub type PIMAGE_ENCLAVE_CONFIG32 = *mut _IMAGE_ENCLAVE_CONFIG32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ENCLAVE_CONFIG64 {
    pub _bindgen_opaque_blob: [u32; 20usize],
}
#[test]
fn bindgen_test_layout__IMAGE_ENCLAVE_CONFIG64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ENCLAVE_CONFIG64>(),
        80usize,
        concat!("Size of: ", stringify!(_IMAGE_ENCLAVE_CONFIG64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ENCLAVE_CONFIG64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ENCLAVE_CONFIG64))
    );
}
pub type IMAGE_ENCLAVE_CONFIG64 = _IMAGE_ENCLAVE_CONFIG64;
pub type PIMAGE_ENCLAVE_CONFIG64 = *mut _IMAGE_ENCLAVE_CONFIG64;
pub type IMAGE_ENCLAVE_CONFIG = IMAGE_ENCLAVE_CONFIG64;
pub type PIMAGE_ENCLAVE_CONFIG = PIMAGE_ENCLAVE_CONFIG64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_ENCLAVE_IMPORT {
    pub MatchType: DWORD,
    pub MinimumSecurityVersion: DWORD,
    pub UniqueOrAuthorID: [BYTE; 32usize],
    pub FamilyID: [BYTE; 16usize],
    pub ImageID: [BYTE; 16usize],
    pub ImportName: DWORD,
    pub Reserved: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_ENCLAVE_IMPORT() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_ENCLAVE_IMPORT>(),
        80usize,
        concat!("Size of: ", stringify!(_IMAGE_ENCLAVE_IMPORT))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_ENCLAVE_IMPORT>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_ENCLAVE_IMPORT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).MatchType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(MatchType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).MinimumSecurityVersion as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(MinimumSecurityVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).UniqueOrAuthorID as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(UniqueOrAuthorID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).FamilyID as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(FamilyID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).ImageID as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(ImageID)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).ImportName as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(ImportName)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_ENCLAVE_IMPORT>())).Reserved as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_ENCLAVE_IMPORT),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_ENCLAVE_IMPORT = _IMAGE_ENCLAVE_IMPORT;
pub type PIMAGE_ENCLAVE_IMPORT = *mut _IMAGE_ENCLAVE_IMPORT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DEBUG_DIRECTORY {
    pub Characteristics: DWORD,
    pub TimeDateStamp: DWORD,
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
    pub Type: DWORD,
    pub SizeOfData: DWORD,
    pub AddressOfRawData: DWORD,
    pub PointerToRawData: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_DEBUG_DIRECTORY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DEBUG_DIRECTORY>(),
        28usize,
        concat!("Size of: ", stringify!(_IMAGE_DEBUG_DIRECTORY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DEBUG_DIRECTORY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DEBUG_DIRECTORY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).Characteristics as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).TimeDateStamp as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).MajorVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).MinorVersion as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(MinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).Type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).SizeOfData as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(SizeOfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).AddressOfRawData as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(AddressOfRawData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_DEBUG_DIRECTORY>())).PointerToRawData as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_DIRECTORY),
            "::",
            stringify!(PointerToRawData)
        )
    );
}
pub type IMAGE_DEBUG_DIRECTORY = _IMAGE_DEBUG_DIRECTORY;
pub type PIMAGE_DEBUG_DIRECTORY = *mut _IMAGE_DEBUG_DIRECTORY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_COFF_SYMBOLS_HEADER {
    pub NumberOfSymbols: DWORD,
    pub LvaToFirstSymbol: DWORD,
    pub NumberOfLinenumbers: DWORD,
    pub LvaToFirstLinenumber: DWORD,
    pub RvaToFirstByteOfCode: DWORD,
    pub RvaToLastByteOfCode: DWORD,
    pub RvaToFirstByteOfData: DWORD,
    pub RvaToLastByteOfData: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_COFF_SYMBOLS_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_COFF_SYMBOLS_HEADER>(),
        32usize,
        concat!("Size of: ", stringify!(_IMAGE_COFF_SYMBOLS_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_COFF_SYMBOLS_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_COFF_SYMBOLS_HEADER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).NumberOfSymbols as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(NumberOfSymbols)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).LvaToFirstSymbol as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(LvaToFirstSymbol)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).NumberOfLinenumbers as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(NumberOfLinenumbers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).LvaToFirstLinenumber as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(LvaToFirstLinenumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).RvaToFirstByteOfCode as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToFirstByteOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).RvaToLastByteOfCode as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToLastByteOfCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).RvaToFirstByteOfData as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToFirstByteOfData)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_COFF_SYMBOLS_HEADER>())).RvaToLastByteOfData as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_COFF_SYMBOLS_HEADER),
            "::",
            stringify!(RvaToLastByteOfData)
        )
    );
}
pub type IMAGE_COFF_SYMBOLS_HEADER = _IMAGE_COFF_SYMBOLS_HEADER;
pub type PIMAGE_COFF_SYMBOLS_HEADER = *mut _IMAGE_COFF_SYMBOLS_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FPO_DATA {
    pub ulOffStart: DWORD,
    pub cbProcSize: DWORD,
    pub cdwLocals: DWORD,
    pub cdwParams: WORD,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
}
#[test]
fn bindgen_test_layout__FPO_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_FPO_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(_FPO_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_FPO_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_FPO_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPO_DATA>())).ulOffStart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(ulOffStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPO_DATA>())).cbProcSize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(cbProcSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPO_DATA>())).cdwLocals as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(cdwLocals)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FPO_DATA>())).cdwParams as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_FPO_DATA),
            "::",
            stringify!(cdwParams)
        )
    );
}
impl _FPO_DATA {
    #[inline]
    pub fn cbProlog(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u16) }
    }
    #[inline]
    pub fn set_cbProlog(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn cbRegs(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_cbRegs(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn fHasSEH(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fHasSEH(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fUseBP(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_fUseBP(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbFrame(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_cbFrame(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        cbProlog: WORD,
        cbRegs: WORD,
        fHasSEH: WORD,
        fUseBP: WORD,
        reserved: WORD,
        cbFrame: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let cbProlog: u16 = unsafe { ::std::mem::transmute(cbProlog) };
            cbProlog as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let cbRegs: u16 = unsafe { ::std::mem::transmute(cbRegs) };
            cbRegs as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let fHasSEH: u16 = unsafe { ::std::mem::transmute(fHasSEH) };
            fHasSEH as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let fUseBP: u16 = unsafe { ::std::mem::transmute(fUseBP) };
            fUseBP as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let reserved: u16 = unsafe { ::std::mem::transmute(reserved) };
            reserved as u64
        });
        __bindgen_bitfield_unit.set(14usize, 2u8, {
            let cbFrame: u16 = unsafe { ::std::mem::transmute(cbFrame) };
            cbFrame as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type FPO_DATA = _FPO_DATA;
pub type PFPO_DATA = *mut _FPO_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_DEBUG_MISC {
    pub DataType: DWORD,
    pub Length: DWORD,
    pub Unicode: BOOLEAN,
    pub Reserved: [BYTE; 3usize],
    pub Data: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__IMAGE_DEBUG_MISC() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_DEBUG_MISC>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_DEBUG_MISC))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_DEBUG_MISC>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_DEBUG_MISC))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DEBUG_MISC>())).DataType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(DataType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DEBUG_MISC>())).Length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DEBUG_MISC>())).Unicode as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Unicode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DEBUG_MISC>())).Reserved as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_DEBUG_MISC>())).Data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_DEBUG_MISC),
            "::",
            stringify!(Data)
        )
    );
}
pub type IMAGE_DEBUG_MISC = _IMAGE_DEBUG_MISC;
pub type PIMAGE_DEBUG_MISC = *mut _IMAGE_DEBUG_MISC;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FUNCTION_ENTRY {
    pub StartingAddress: DWORD,
    pub EndingAddress: DWORD,
    pub EndOfPrologue: DWORD,
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FUNCTION_ENTRY>(),
        12usize,
        concat!("Size of: ", stringify!(_IMAGE_FUNCTION_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FUNCTION_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FUNCTION_ENTRY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FUNCTION_ENTRY>())).StartingAddress as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY),
            "::",
            stringify!(StartingAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FUNCTION_ENTRY>())).EndingAddress as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY),
            "::",
            stringify!(EndingAddress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_FUNCTION_ENTRY>())).EndOfPrologue as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_FUNCTION_ENTRY),
            "::",
            stringify!(EndOfPrologue)
        )
    );
}
pub type IMAGE_FUNCTION_ENTRY = _IMAGE_FUNCTION_ENTRY;
pub type PIMAGE_FUNCTION_ENTRY = *mut _IMAGE_FUNCTION_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_FUNCTION_ENTRY64 {
    pub _bindgen_opaque_blob: [u32; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_FUNCTION_ENTRY64__bindgen_ty_1 {
    pub _bindgen_opaque_blob: [u32; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY64__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_FUNCTION_ENTRY64__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_FUNCTION_ENTRY64() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_FUNCTION_ENTRY64>(),
        24usize,
        concat!("Size of: ", stringify!(_IMAGE_FUNCTION_ENTRY64))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_FUNCTION_ENTRY64>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_FUNCTION_ENTRY64))
    );
}
pub type IMAGE_FUNCTION_ENTRY64 = _IMAGE_FUNCTION_ENTRY64;
pub type PIMAGE_FUNCTION_ENTRY64 = *mut _IMAGE_FUNCTION_ENTRY64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IMAGE_SEPARATE_DEBUG_HEADER {
    pub Signature: WORD,
    pub Flags: WORD,
    pub Machine: WORD,
    pub Characteristics: WORD,
    pub TimeDateStamp: DWORD,
    pub CheckSum: DWORD,
    pub ImageBase: DWORD,
    pub SizeOfImage: DWORD,
    pub NumberOfSections: DWORD,
    pub ExportedNamesSize: DWORD,
    pub DebugDirectorySize: DWORD,
    pub SectionAlignment: DWORD,
    pub Reserved: [DWORD; 2usize],
}
#[test]
fn bindgen_test_layout__IMAGE_SEPARATE_DEBUG_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_SEPARATE_DEBUG_HEADER>(),
        48usize,
        concat!("Size of: ", stringify!(_IMAGE_SEPARATE_DEBUG_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_SEPARATE_DEBUG_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_IMAGE_SEPARATE_DEBUG_HEADER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).Signature as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Signature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).Flags as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).Machine as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).Characteristics as *const _
                as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Characteristics)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).TimeDateStamp as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).CheckSum as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(CheckSum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).ImageBase as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(ImageBase)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).SizeOfImage as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(SizeOfImage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).NumberOfSections as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(NumberOfSections)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).ExportedNamesSize as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(ExportedNamesSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).DebugDirectorySize as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(DebugDirectorySize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).SectionAlignment as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(SectionAlignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_SEPARATE_DEBUG_HEADER>())).Reserved as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_SEPARATE_DEBUG_HEADER),
            "::",
            stringify!(Reserved)
        )
    );
}
pub type IMAGE_SEPARATE_DEBUG_HEADER = _IMAGE_SEPARATE_DEBUG_HEADER;
pub type PIMAGE_SEPARATE_DEBUG_HEADER = *mut _IMAGE_SEPARATE_DEBUG_HEADER;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NON_PAGED_DEBUG_INFO {
    pub _bindgen_opaque_blob: [u32; 8usize],
}
#[test]
fn bindgen_test_layout__NON_PAGED_DEBUG_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_NON_PAGED_DEBUG_INFO>(),
        32usize,
        concat!("Size of: ", stringify!(_NON_PAGED_DEBUG_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_NON_PAGED_DEBUG_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_NON_PAGED_DEBUG_INFO))
    );
}
pub type NON_PAGED_DEBUG_INFO = _NON_PAGED_DEBUG_INFO;
pub type PNON_PAGED_DEBUG_INFO = *mut _NON_PAGED_DEBUG_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ImageArchitectureHeader {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u8>,
    pub FirstEntryRVA: DWORD,
}
#[test]
fn bindgen_test_layout__ImageArchitectureHeader() {
    assert_eq!(
        ::std::mem::size_of::<_ImageArchitectureHeader>(),
        8usize,
        concat!("Size of: ", stringify!(_ImageArchitectureHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<_ImageArchitectureHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(_ImageArchitectureHeader))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ImageArchitectureHeader>())).FirstEntryRVA as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ImageArchitectureHeader),
            "::",
            stringify!(FirstEntryRVA)
        )
    );
}
impl _ImageArchitectureHeader {
    #[inline]
    pub fn AmaskValue(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_AmaskValue(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AmaskShift(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_AmaskShift(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AmaskValue: ::std::os::raw::c_uint,
        AmaskShift: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let AmaskValue: u32 = unsafe { ::std::mem::transmute(AmaskValue) };
            AmaskValue as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let AmaskShift: u32 = unsafe { ::std::mem::transmute(AmaskShift) };
            AmaskShift as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type IMAGE_ARCHITECTURE_HEADER = _ImageArchitectureHeader;
pub type PIMAGE_ARCHITECTURE_HEADER = *mut _ImageArchitectureHeader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ImageArchitectureEntry {
    pub FixupInstRVA: DWORD,
    pub NewInst: DWORD,
}
#[test]
fn bindgen_test_layout__ImageArchitectureEntry() {
    assert_eq!(
        ::std::mem::size_of::<_ImageArchitectureEntry>(),
        8usize,
        concat!("Size of: ", stringify!(_ImageArchitectureEntry))
    );
    assert_eq!(
        ::std::mem::align_of::<_ImageArchitectureEntry>(),
        4usize,
        concat!("Alignment of ", stringify!(_ImageArchitectureEntry))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ImageArchitectureEntry>())).FixupInstRVA as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ImageArchitectureEntry),
            "::",
            stringify!(FixupInstRVA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ImageArchitectureEntry>())).NewInst as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ImageArchitectureEntry),
            "::",
            stringify!(NewInst)
        )
    );
}
pub type IMAGE_ARCHITECTURE_ENTRY = _ImageArchitectureEntry;
pub type PIMAGE_ARCHITECTURE_ENTRY = *mut _ImageArchitectureEntry;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMPORT_OBJECT_HEADER {
    pub Sig1: WORD,
    pub Sig2: WORD,
    pub Version: WORD,
    pub Machine: WORD,
    pub TimeDateStamp: DWORD,
    pub SizeOfData: DWORD,
    pub __bindgen_anon_1: IMPORT_OBJECT_HEADER__bindgen_ty_1,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u16>,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMPORT_OBJECT_HEADER__bindgen_ty_1 {
    pub Ordinal: WORD,
    pub Hint: WORD,
    _bindgen_union_align: u16,
}
#[test]
fn bindgen_test_layout_IMPORT_OBJECT_HEADER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IMPORT_OBJECT_HEADER__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPORT_OBJECT_HEADER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER__bindgen_ty_1>())).Ordinal as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1),
            "::",
            stringify!(Ordinal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER__bindgen_ty_1>())).Hint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER__bindgen_ty_1),
            "::",
            stringify!(Hint)
        )
    );
}
#[test]
fn bindgen_test_layout_IMPORT_OBJECT_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<IMPORT_OBJECT_HEADER>(),
        20usize,
        concat!("Size of: ", stringify!(IMPORT_OBJECT_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<IMPORT_OBJECT_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(IMPORT_OBJECT_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER>())).Sig1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Sig1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER>())).Sig2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Sig2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER>())).Version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER>())).Machine as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(Machine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER>())).TimeDateStamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(TimeDateStamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMPORT_OBJECT_HEADER>())).SizeOfData as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(IMPORT_OBJECT_HEADER),
            "::",
            stringify!(SizeOfData)
        )
    );
}
impl IMPORT_OBJECT_HEADER {
    #[inline]
    pub fn Type(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn NameType(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_NameType(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> WORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 11u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: WORD) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 11u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: WORD,
        NameType: WORD,
        Reserved: WORD,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Type: u16 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let NameType: u16 = unsafe { ::std::mem::transmute(NameType) };
            NameType as u64
        });
        __bindgen_bitfield_unit.set(5usize, 11u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const IMPORT_OBJECT_TYPE_IMPORT_OBJECT_CODE: IMPORT_OBJECT_TYPE = 0;
pub const IMPORT_OBJECT_TYPE_IMPORT_OBJECT_DATA: IMPORT_OBJECT_TYPE = 1;
pub const IMPORT_OBJECT_TYPE_IMPORT_OBJECT_CONST: IMPORT_OBJECT_TYPE = 2;
pub type IMPORT_OBJECT_TYPE = i32;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_ORDINAL: IMPORT_OBJECT_NAME_TYPE = 0;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME: IMPORT_OBJECT_NAME_TYPE = 1;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME_NO_PREFIX: IMPORT_OBJECT_NAME_TYPE = 2;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME_UNDECORATE: IMPORT_OBJECT_NAME_TYPE = 3;
pub const IMPORT_OBJECT_NAME_TYPE_IMPORT_OBJECT_NAME_EXPORTAS: IMPORT_OBJECT_NAME_TYPE = 4;
pub type IMPORT_OBJECT_NAME_TYPE = i32;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_ILONLY: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_32BITREQUIRED: ReplacesCorHdrNumericDefines =
    2;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_IL_LIBRARY: ReplacesCorHdrNumericDefines = 4;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_STRONGNAMESIGNED:
    ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_NATIVE_ENTRYPOINT:
    ReplacesCorHdrNumericDefines = 16;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_TRACKDEBUGDATA: ReplacesCorHdrNumericDefines =
    65536;
pub const ReplacesCorHdrNumericDefines_COMIMAGE_FLAGS_32BITPREFERRED: ReplacesCorHdrNumericDefines =
    131072;
pub const ReplacesCorHdrNumericDefines_COR_VERSION_MAJOR_V2: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_COR_VERSION_MAJOR: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_COR_VERSION_MINOR: ReplacesCorHdrNumericDefines = 5;
pub const ReplacesCorHdrNumericDefines_COR_DELETED_NAME_LENGTH: ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COR_VTABLEGAP_NAME_LENGTH: ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_NATIVE_TYPE_MAX_CB: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE:
    ReplacesCorHdrNumericDefines = 255;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_MIH_METHODRVA: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_MIH_EHRVA: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_MIH_BASICBLOCK: ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_32BIT: ReplacesCorHdrNumericDefines = 1;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_64BIT: ReplacesCorHdrNumericDefines = 2;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_FROM_UNMANAGED: ReplacesCorHdrNumericDefines = 4;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN:
    ReplacesCorHdrNumericDefines = 8;
pub const ReplacesCorHdrNumericDefines_COR_VTABLE_CALL_MOST_DERIVED: ReplacesCorHdrNumericDefines =
    16;
pub const ReplacesCorHdrNumericDefines_IMAGE_COR_EATJ_THUNK_SIZE: ReplacesCorHdrNumericDefines = 32;
pub const ReplacesCorHdrNumericDefines_MAX_CLASS_NAME: ReplacesCorHdrNumericDefines = 1024;
pub const ReplacesCorHdrNumericDefines_MAX_PACKAGE_NAME: ReplacesCorHdrNumericDefines = 1024;
pub type ReplacesCorHdrNumericDefines = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct IMAGE_COR20_HEADER {
    pub cb: DWORD,
    pub MajorRuntimeVersion: WORD,
    pub MinorRuntimeVersion: WORD,
    pub MetaData: IMAGE_DATA_DIRECTORY,
    pub Flags: DWORD,
    pub __bindgen_anon_1: IMAGE_COR20_HEADER__bindgen_ty_1,
    pub Resources: IMAGE_DATA_DIRECTORY,
    pub StrongNameSignature: IMAGE_DATA_DIRECTORY,
    pub CodeManagerTable: IMAGE_DATA_DIRECTORY,
    pub VTableFixups: IMAGE_DATA_DIRECTORY,
    pub ExportAddressTableJumps: IMAGE_DATA_DIRECTORY,
    pub ManagedNativeHeader: IMAGE_DATA_DIRECTORY,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union IMAGE_COR20_HEADER__bindgen_ty_1 {
    pub EntryPointToken: DWORD,
    pub EntryPointRVA: DWORD,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_IMAGE_COR20_HEADER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_COR20_HEADER__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(IMAGE_COR20_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_COR20_HEADER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(IMAGE_COR20_HEADER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER__bindgen_ty_1>())).EntryPointToken as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER__bindgen_ty_1),
            "::",
            stringify!(EntryPointToken)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER__bindgen_ty_1>())).EntryPointRVA as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER__bindgen_ty_1),
            "::",
            stringify!(EntryPointRVA)
        )
    );
}
#[test]
fn bindgen_test_layout_IMAGE_COR20_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<IMAGE_COR20_HEADER>(),
        72usize,
        concat!("Size of: ", stringify!(IMAGE_COR20_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<IMAGE_COR20_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(IMAGE_COR20_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).cb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(cb)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).MajorRuntimeVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(MajorRuntimeVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).MinorRuntimeVersion as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(MinorRuntimeVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).MetaData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(MetaData)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).Flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).Resources as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(Resources)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).StrongNameSignature as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(StrongNameSignature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).CodeManagerTable as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(CodeManagerTable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).VTableFixups as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(VTableFixups)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).ExportAddressTableJumps as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(ExportAddressTableJumps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<IMAGE_COR20_HEADER>())).ManagedNativeHeader as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(IMAGE_COR20_HEADER),
            "::",
            stringify!(ManagedNativeHeader)
        )
    );
}
pub type PIMAGE_COR20_HEADER = *mut IMAGE_COR20_HEADER;
extern "C" {
    pub fn RtlCaptureStackBackTrace(
        FramesToSkip: DWORD,
        FramesToCapture: DWORD,
        BackTrace: *mut PVOID,
        BackTraceHash: PDWORD,
    ) -> WORD;
}
extern "C" {
    pub fn RtlCaptureContext(ContextRecord: PCONTEXT);
}
extern "C" {
    pub fn RtlUnwind(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
    );
}
extern "C" {
    pub fn RtlAddFunctionTable(
        FunctionTable: PRUNTIME_FUNCTION,
        EntryCount: DWORD,
        BaseAddress: DWORD64,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlDeleteFunctionTable(FunctionTable: PRUNTIME_FUNCTION) -> BOOLEAN;
}
extern "C" {
    pub fn RtlInstallFunctionTableCallback(
        TableIdentifier: DWORD64,
        BaseAddress: DWORD64,
        Length: DWORD,
        Callback: PGET_RUNTIME_FUNCTION_CALLBACK,
        Context: PVOID,
        OutOfProcessCallbackDll: PCWSTR,
    ) -> BOOLEAN;
}
extern "C" {
    pub fn RtlAddGrowableFunctionTable(
        DynamicTable: *mut PVOID,
        FunctionTable: PRUNTIME_FUNCTION,
        EntryCount: DWORD,
        MaximumEntryCount: DWORD,
        RangeBase: ULONG_PTR,
        RangeEnd: ULONG_PTR,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlGrowFunctionTable(DynamicTable: PVOID, NewEntryCount: DWORD);
}
extern "C" {
    pub fn RtlDeleteGrowableFunctionTable(DynamicTable: PVOID);
}
extern "C" {
    pub fn RtlLookupFunctionEntry(
        ControlPc: DWORD64,
        ImageBase: PDWORD64,
        HistoryTable: PUNWIND_HISTORY_TABLE,
    ) -> PRUNTIME_FUNCTION;
}
extern "C" {
    pub fn RtlRestoreContext(ContextRecord: PCONTEXT, ExceptionRecord: *mut _EXCEPTION_RECORD);
}
extern "C" {
    pub fn RtlUnwindEx(
        TargetFrame: PVOID,
        TargetIp: PVOID,
        ExceptionRecord: PEXCEPTION_RECORD,
        ReturnValue: PVOID,
        ContextRecord: PCONTEXT,
        HistoryTable: PUNWIND_HISTORY_TABLE,
    );
}
extern "C" {
    pub fn RtlVirtualUnwind(
        HandlerType: DWORD,
        ImageBase: DWORD64,
        ControlPc: DWORD64,
        FunctionEntry: PRUNTIME_FUNCTION,
        ContextRecord: PCONTEXT,
        HandlerData: *mut PVOID,
        EstablisherFrame: PDWORD64,
        ContextPointers: PKNONVOLATILE_CONTEXT_POINTERS,
    ) -> PEXCEPTION_ROUTINE;
}
extern "C" {
    pub fn RtlPcToFileHeader(PcValue: PVOID, BaseOfImage: *mut PVOID) -> PVOID;
}
extern "C" {
    pub fn RtlCompareMemory(
        Source1: *const ::std::os::raw::c_void,
        Source2: *const ::std::os::raw::c_void,
        Length: SIZE_T,
    ) -> SIZE_T;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_ENTRY {
    pub Next: *mut _SLIST_ENTRY,
    pub __bindgen_padding_0: u64,
}
#[test]
fn bindgen_test_layout__SLIST_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_SLIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SLIST_ENTRY>())).Next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_ENTRY),
            "::",
            stringify!(Next)
        )
    );
}
pub type SLIST_ENTRY = _SLIST_ENTRY;
pub type PSLIST_ENTRY = *mut _SLIST_ENTRY;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _SLIST_HEADER {
    pub __bindgen_anon_1: _SLIST_HEADER__bindgen_ty_1,
    pub HeaderX64: _SLIST_HEADER__bindgen_ty_2,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_1 {
    pub Alignment: ULONGLONG,
    pub Region: ULONGLONG,
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Alignment as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_SLIST_HEADER__bindgen_ty_1>())).Region as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER__bindgen_ty_1),
            "::",
            stringify!(Region)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SLIST_HEADER__bindgen_ty_2 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 16usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout__SLIST_HEADER__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<_SLIST_HEADER__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(_SLIST_HEADER__bindgen_ty_2))
    );
}
impl _SLIST_HEADER__bindgen_ty_2 {
    #[inline]
    pub fn Depth(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 16u8) as u64) }
    }
    #[inline]
    pub fn set_Depth(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn Sequence(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Sequence(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(64usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(64usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NextEntry(&self) -> ULONGLONG {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(68usize, 60u8) as u64) }
    }
    #[inline]
    pub fn set_NextEntry(&mut self, val: ULONGLONG) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(68usize, 60u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Depth: ULONGLONG,
        Sequence: ULONGLONG,
        Reserved: ULONGLONG,
        NextEntry: ULONGLONG,
    ) -> __BindgenBitfieldUnit<[u8; 16usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 16usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 16u8, {
            let Depth: u64 = unsafe { ::std::mem::transmute(Depth) };
            Depth as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Sequence: u64 = unsafe { ::std::mem::transmute(Sequence) };
            Sequence as u64
        });
        __bindgen_bitfield_unit.set(64usize, 4u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(68usize, 60u8, {
            let NextEntry: u64 = unsafe { ::std::mem::transmute(NextEntry) };
            NextEntry as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__SLIST_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_SLIST_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_SLIST_HEADER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SLIST_HEADER>())).HeaderX64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SLIST_HEADER),
            "::",
            stringify!(HeaderX64)
        )
    );
}
pub type SLIST_HEADER = _SLIST_HEADER;
pub type PSLIST_HEADER = *mut _SLIST_HEADER;
extern "C" {
    pub fn RtlInitializeSListHead(ListHead: PSLIST_HEADER);
}
extern "C" {
    pub fn RtlFirstEntrySList(ListHead: *const SLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPopEntrySList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPushEntrySList(
        ListHead: PSLIST_HEADER,
        ListEntry: PSLIST_ENTRY,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedPushListSListEx(
        ListHead: PSLIST_HEADER,
        List: PSLIST_ENTRY,
        ListEnd: PSLIST_ENTRY,
        Count: DWORD,
    ) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlInterlockedFlushSList(ListHead: PSLIST_HEADER) -> PSLIST_ENTRY;
}
extern "C" {
    pub fn RtlQueryDepthSList(ListHead: PSLIST_HEADER) -> WORD;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _RTL_RUN_ONCE {
    pub Ptr: PVOID,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__RTL_RUN_ONCE() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_RUN_ONCE>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_RUN_ONCE))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_RUN_ONCE>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_RUN_ONCE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_RUN_ONCE>())).Ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_RUN_ONCE),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type RTL_RUN_ONCE = _RTL_RUN_ONCE;
pub type PRTL_RUN_ONCE = *mut _RTL_RUN_ONCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_BARRIER {
    pub Reserved1: DWORD,
    pub Reserved2: DWORD,
    pub Reserved3: [ULONG_PTR; 2usize],
    pub Reserved4: DWORD,
    pub Reserved5: DWORD,
}
#[test]
fn bindgen_test_layout__RTL_BARRIER() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_BARRIER>(),
        32usize,
        concat!("Size of: ", stringify!(_RTL_BARRIER))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_BARRIER>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_BARRIER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved3 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved4 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_BARRIER>())).Reserved5 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_BARRIER),
            "::",
            stringify!(Reserved5)
        )
    );
}
pub type RTL_BARRIER = _RTL_BARRIER;
pub type PRTL_BARRIER = *mut _RTL_BARRIER;
extern "C" {
    pub fn __fastfail(Code: ::std::os::raw::c_uint);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_ENTRY {
    pub Length: WORD,
    pub Flags: WORD,
    pub Text: [BYTE; 1usize],
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_MESSAGE_RESOURCE_ENTRY>(),
        6usize,
        concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_MESSAGE_RESOURCE_ENTRY>(),
        2usize,
        concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MESSAGE_RESOURCE_ENTRY>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_ENTRY),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MESSAGE_RESOURCE_ENTRY>())).Flags as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_ENTRY),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MESSAGE_RESOURCE_ENTRY>())).Text as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_ENTRY),
            "::",
            stringify!(Text)
        )
    );
}
pub type MESSAGE_RESOURCE_ENTRY = _MESSAGE_RESOURCE_ENTRY;
pub type PMESSAGE_RESOURCE_ENTRY = *mut _MESSAGE_RESOURCE_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_BLOCK {
    pub LowId: DWORD,
    pub HighId: DWORD,
    pub OffsetToEntries: DWORD,
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_BLOCK() {
    assert_eq!(
        ::std::mem::size_of::<_MESSAGE_RESOURCE_BLOCK>(),
        12usize,
        concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_BLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_MESSAGE_RESOURCE_BLOCK>(),
        4usize,
        concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_BLOCK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MESSAGE_RESOURCE_BLOCK>())).LowId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_BLOCK),
            "::",
            stringify!(LowId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MESSAGE_RESOURCE_BLOCK>())).HighId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_BLOCK),
            "::",
            stringify!(HighId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MESSAGE_RESOURCE_BLOCK>())).OffsetToEntries as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_BLOCK),
            "::",
            stringify!(OffsetToEntries)
        )
    );
}
pub type MESSAGE_RESOURCE_BLOCK = _MESSAGE_RESOURCE_BLOCK;
pub type PMESSAGE_RESOURCE_BLOCK = *mut _MESSAGE_RESOURCE_BLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MESSAGE_RESOURCE_DATA {
    pub NumberOfBlocks: DWORD,
    pub Blocks: [MESSAGE_RESOURCE_BLOCK; 1usize],
}
#[test]
fn bindgen_test_layout__MESSAGE_RESOURCE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_MESSAGE_RESOURCE_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(_MESSAGE_RESOURCE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_MESSAGE_RESOURCE_DATA>(),
        4usize,
        concat!("Alignment of ", stringify!(_MESSAGE_RESOURCE_DATA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_MESSAGE_RESOURCE_DATA>())).NumberOfBlocks as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_DATA),
            "::",
            stringify!(NumberOfBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_MESSAGE_RESOURCE_DATA>())).Blocks as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_MESSAGE_RESOURCE_DATA),
            "::",
            stringify!(Blocks)
        )
    );
}
pub type MESSAGE_RESOURCE_DATA = _MESSAGE_RESOURCE_DATA;
pub type PMESSAGE_RESOURCE_DATA = *mut _MESSAGE_RESOURCE_DATA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOA {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [CHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOA() {
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOA>(),
        148usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOA))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOA>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOA>())).dwOSVersionInfoSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOA>())).dwMajorVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOA>())).dwMinorVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOA>())).dwBuildNumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOA>())).dwPlatformId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOA>())).szCSDVersion as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOA),
            "::",
            stringify!(szCSDVersion)
        )
    );
}
pub type OSVERSIONINFOA = _OSVERSIONINFOA;
pub type POSVERSIONINFOA = *mut _OSVERSIONINFOA;
pub type LPOSVERSIONINFOA = *mut _OSVERSIONINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOW {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [WCHAR; 128usize],
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOW() {
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOW>(),
        276usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOW))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOW>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOW))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOW>())).dwOSVersionInfoSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOW>())).dwMajorVersion as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOW>())).dwMinorVersion as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOW>())).dwBuildNumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOW>())).dwPlatformId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOW>())).szCSDVersion as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOW),
            "::",
            stringify!(szCSDVersion)
        )
    );
}
pub type OSVERSIONINFOW = _OSVERSIONINFOW;
pub type POSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type LPOSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type RTL_OSVERSIONINFOW = _OSVERSIONINFOW;
pub type PRTL_OSVERSIONINFOW = *mut _OSVERSIONINFOW;
pub type OSVERSIONINFO = OSVERSIONINFOA;
pub type POSVERSIONINFO = POSVERSIONINFOA;
pub type LPOSVERSIONINFO = LPOSVERSIONINFOA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOEXA {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [CHAR; 128usize],
    pub wServicePackMajor: WORD,
    pub wServicePackMinor: WORD,
    pub wSuiteMask: WORD,
    pub wProductType: BYTE,
    pub wReserved: BYTE,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXA() {
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOEXA>(),
        156usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOEXA))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOEXA>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOEXA))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).dwOSVersionInfoSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).dwMajorVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).dwMinorVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).dwBuildNumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).dwPlatformId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).szCSDVersion as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(szCSDVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).wServicePackMajor as *const _ as usize
        },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wServicePackMajor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).wServicePackMinor as *const _ as usize
        },
        150usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wServicePackMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).wSuiteMask as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wSuiteMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).wProductType as *const _ as usize },
        154usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wProductType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXA>())).wReserved as *const _ as usize },
        155usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXA),
            "::",
            stringify!(wReserved)
        )
    );
}
pub type OSVERSIONINFOEXA = _OSVERSIONINFOEXA;
pub type POSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEXA = *mut _OSVERSIONINFOEXA;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _OSVERSIONINFOEXW {
    pub dwOSVersionInfoSize: DWORD,
    pub dwMajorVersion: DWORD,
    pub dwMinorVersion: DWORD,
    pub dwBuildNumber: DWORD,
    pub dwPlatformId: DWORD,
    pub szCSDVersion: [WCHAR; 128usize],
    pub wServicePackMajor: WORD,
    pub wServicePackMinor: WORD,
    pub wSuiteMask: WORD,
    pub wProductType: BYTE,
    pub wReserved: BYTE,
}
#[test]
fn bindgen_test_layout__OSVERSIONINFOEXW() {
    assert_eq!(
        ::std::mem::size_of::<_OSVERSIONINFOEXW>(),
        284usize,
        concat!("Size of: ", stringify!(_OSVERSIONINFOEXW))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSVERSIONINFOEXW>(),
        4usize,
        concat!("Alignment of ", stringify!(_OSVERSIONINFOEXW))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).dwOSVersionInfoSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwOSVersionInfoSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).dwMajorVersion as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwMajorVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).dwMinorVersion as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwMinorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).dwBuildNumber as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwBuildNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).dwPlatformId as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(dwPlatformId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).szCSDVersion as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(szCSDVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).wServicePackMajor as *const _ as usize
        },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wServicePackMajor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).wServicePackMinor as *const _ as usize
        },
        278usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wServicePackMinor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).wSuiteMask as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wSuiteMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).wProductType as *const _ as usize },
        282usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wProductType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_OSVERSIONINFOEXW>())).wReserved as *const _ as usize },
        283usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSVERSIONINFOEXW),
            "::",
            stringify!(wReserved)
        )
    );
}
pub type OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type POSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type LPOSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type RTL_OSVERSIONINFOEXW = _OSVERSIONINFOEXW;
pub type PRTL_OSVERSIONINFOEXW = *mut _OSVERSIONINFOEXW;
pub type OSVERSIONINFOEX = OSVERSIONINFOEXA;
pub type POSVERSIONINFOEX = POSVERSIONINFOEXA;
pub type LPOSVERSIONINFOEX = LPOSVERSIONINFOEXA;
extern "C" {
    pub fn VerSetConditionMask(
        ConditionMask: ULONGLONG,
        TypeMask: DWORD,
        Condition: BYTE,
    ) -> ULONGLONG;
}
extern "C" {
    pub fn RtlGetProductInfo(
        OSMajorVersion: DWORD,
        OSMinorVersion: DWORD,
        SpMajorVersion: DWORD,
        SpMinorVersion: DWORD,
        ReturnedProductType: PDWORD,
    ) -> BOOLEAN;
}
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadInvalidInfoClass: _RTL_UMS_THREAD_INFO_CLASS = 0;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadUserContext: _RTL_UMS_THREAD_INFO_CLASS = 1;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadPriority: _RTL_UMS_THREAD_INFO_CLASS = 2;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadAffinity: _RTL_UMS_THREAD_INFO_CLASS = 3;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadTeb: _RTL_UMS_THREAD_INFO_CLASS = 4;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadIsSuspended: _RTL_UMS_THREAD_INFO_CLASS = 5;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadIsTerminated: _RTL_UMS_THREAD_INFO_CLASS = 6;
pub const _RTL_UMS_THREAD_INFO_CLASS_UmsThreadMaxInfoClass: _RTL_UMS_THREAD_INFO_CLASS = 7;
pub type _RTL_UMS_THREAD_INFO_CLASS = i32;
pub use self::_RTL_UMS_THREAD_INFO_CLASS as RTL_UMS_THREAD_INFO_CLASS;
pub type PRTL_UMS_THREAD_INFO_CLASS = *mut _RTL_UMS_THREAD_INFO_CLASS;
pub const _RTL_UMS_SCHEDULER_REASON_UmsSchedulerStartup: _RTL_UMS_SCHEDULER_REASON = 0;
pub const _RTL_UMS_SCHEDULER_REASON_UmsSchedulerThreadBlocked: _RTL_UMS_SCHEDULER_REASON = 1;
pub const _RTL_UMS_SCHEDULER_REASON_UmsSchedulerThreadYield: _RTL_UMS_SCHEDULER_REASON = 2;
pub type _RTL_UMS_SCHEDULER_REASON = i32;
pub use self::_RTL_UMS_SCHEDULER_REASON as RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_REASON = *mut _RTL_UMS_SCHEDULER_REASON;
pub type PRTL_UMS_SCHEDULER_ENTRY_POINT = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn RtlCrc32(Buffer: *const ::std::os::raw::c_void, Size: usize, InitialCrc: DWORD)
        -> DWORD;
}
extern "C" {
    pub fn RtlCrc64(
        Buffer: *const ::std::os::raw::c_void,
        Size: usize,
        InitialCrc: ULONGLONG,
    ) -> ULONGLONG;
}
pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_STANDARD: _OS_DEPLOYEMENT_STATE_VALUES = 1;
pub const _OS_DEPLOYEMENT_STATE_VALUES_OS_DEPLOYMENT_COMPACT: _OS_DEPLOYEMENT_STATE_VALUES = 2;
pub type _OS_DEPLOYEMENT_STATE_VALUES = i32;
pub use self::_OS_DEPLOYEMENT_STATE_VALUES as OS_DEPLOYEMENT_STATE_VALUES;
extern "C" {
    pub fn RtlOsDeploymentState(Flags: DWORD) -> OS_DEPLOYEMENT_STATE_VALUES;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _NV_MEMORY_RANGE {
    pub BaseAddress: *mut ::std::os::raw::c_void,
    pub Length: SIZE_T,
}
#[test]
fn bindgen_test_layout__NV_MEMORY_RANGE() {
    assert_eq!(
        ::std::mem::size_of::<_NV_MEMORY_RANGE>(),
        16usize,
        concat!("Size of: ", stringify!(_NV_MEMORY_RANGE))
    );
    assert_eq!(
        ::std::mem::align_of::<_NV_MEMORY_RANGE>(),
        8usize,
        concat!("Alignment of ", stringify!(_NV_MEMORY_RANGE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_MEMORY_RANGE>())).BaseAddress as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MEMORY_RANGE),
            "::",
            stringify!(BaseAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_NV_MEMORY_RANGE>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_NV_MEMORY_RANGE),
            "::",
            stringify!(Length)
        )
    );
}
pub type NV_MEMORY_RANGE = _NV_MEMORY_RANGE;
pub type PNV_MEMORY_RANGE = *mut _NV_MEMORY_RANGE;
extern "C" {
    pub fn RtlGetNonVolatileToken(NvBuffer: PVOID, Size: SIZE_T, NvToken: *mut PVOID) -> DWORD;
}
extern "C" {
    pub fn RtlFreeNonVolatileToken(NvToken: PVOID) -> DWORD;
}
extern "C" {
    pub fn RtlFlushNonVolatileMemory(
        NvToken: PVOID,
        NvBuffer: PVOID,
        Size: SIZE_T,
        Flags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlDrainNonVolatileFlush(NvToken: PVOID) -> DWORD;
}
extern "C" {
    pub fn RtlWriteNonVolatileMemory(
        NvToken: PVOID,
        NvDestination: *mut ::std::os::raw::c_void,
        Source: *const ::std::os::raw::c_void,
        Size: SIZE_T,
        Flags: DWORD,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlFlushNonVolatileMemoryRanges(
        NvToken: PVOID,
        NvRanges: PNV_MEMORY_RANGE,
        NumRanges: SIZE_T,
        Flags: DWORD,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CORRELATION_VECTOR {
    pub Version: CHAR,
    pub Vector: [CHAR; 129usize],
}
#[test]
fn bindgen_test_layout_CORRELATION_VECTOR() {
    assert_eq!(
        ::std::mem::size_of::<CORRELATION_VECTOR>(),
        130usize,
        concat!("Size of: ", stringify!(CORRELATION_VECTOR))
    );
    assert_eq!(
        ::std::mem::align_of::<CORRELATION_VECTOR>(),
        1usize,
        concat!("Alignment of ", stringify!(CORRELATION_VECTOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CORRELATION_VECTOR>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CORRELATION_VECTOR),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CORRELATION_VECTOR>())).Vector as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CORRELATION_VECTOR),
            "::",
            stringify!(Vector)
        )
    );
}
pub type PCORRELATION_VECTOR = *mut CORRELATION_VECTOR;
extern "C" {
    pub fn RtlInitializeCorrelationVector(
        CorrelationVector: PCORRELATION_VECTOR,
        Version: ::std::os::raw::c_int,
        Guid: *const GUID,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlIncrementCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> DWORD;
}
extern "C" {
    pub fn RtlExtendCorrelationVector(CorrelationVector: PCORRELATION_VECTOR) -> DWORD;
}
extern "C" {
    pub fn RtlValidateCorrelationVector(Vector: PCORRELATION_VECTOR) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG {
    pub Size: DWORD,
    pub TriggerId: PCWSTR,
}
#[test]
fn bindgen_test_layout__CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG() {
    assert_eq!(
        ::std::mem::size_of::<_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG>(),
        16usize,
        concat!("Size of: ", stringify!(_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG))
    );
    assert_eq!(
        ::std::mem::align_of::<_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG>())).Size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG>())).TriggerId as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG),
            "::",
            stringify!(TriggerId)
        )
    );
}
pub type CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
pub type PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG = *mut _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;
extern "C" {
    pub fn RtlRaiseCustomSystemEventTrigger(
        TriggerConfig: PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG,
    ) -> DWORD;
}
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeNone: _IMAGE_POLICY_ENTRY_TYPE = 0;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeBool: _IMAGE_POLICY_ENTRY_TYPE = 1;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt8: _IMAGE_POLICY_ENTRY_TYPE = 2;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt8: _IMAGE_POLICY_ENTRY_TYPE = 3;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt16: _IMAGE_POLICY_ENTRY_TYPE = 4;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt16: _IMAGE_POLICY_ENTRY_TYPE = 5;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt32: _IMAGE_POLICY_ENTRY_TYPE = 6;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt32: _IMAGE_POLICY_ENTRY_TYPE = 7;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeInt64: _IMAGE_POLICY_ENTRY_TYPE = 8;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUInt64: _IMAGE_POLICY_ENTRY_TYPE = 9;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeAnsiString: _IMAGE_POLICY_ENTRY_TYPE = 10;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeUnicodeString: _IMAGE_POLICY_ENTRY_TYPE = 11;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeOverride: _IMAGE_POLICY_ENTRY_TYPE = 12;
pub const _IMAGE_POLICY_ENTRY_TYPE_ImagePolicyEntryTypeMaximum: _IMAGE_POLICY_ENTRY_TYPE = 13;
pub type _IMAGE_POLICY_ENTRY_TYPE = i32;
pub use self::_IMAGE_POLICY_ENTRY_TYPE as IMAGE_POLICY_ENTRY_TYPE;
pub const _IMAGE_POLICY_ID_ImagePolicyIdNone: _IMAGE_POLICY_ID = 0;
pub const _IMAGE_POLICY_ID_ImagePolicyIdEtw: _IMAGE_POLICY_ID = 1;
pub const _IMAGE_POLICY_ID_ImagePolicyIdDebug: _IMAGE_POLICY_ID = 2;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDump: _IMAGE_POLICY_ID = 3;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKey: _IMAGE_POLICY_ID = 4;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCrashDumpKeyGuid: _IMAGE_POLICY_ID = 5;
pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSd: _IMAGE_POLICY_ID = 6;
pub const _IMAGE_POLICY_ID_ImagePolicyIdParentSdRev: _IMAGE_POLICY_ID = 7;
pub const _IMAGE_POLICY_ID_ImagePolicyIdSvn: _IMAGE_POLICY_ID = 8;
pub const _IMAGE_POLICY_ID_ImagePolicyIdDeviceId: _IMAGE_POLICY_ID = 9;
pub const _IMAGE_POLICY_ID_ImagePolicyIdCapability: _IMAGE_POLICY_ID = 10;
pub const _IMAGE_POLICY_ID_ImagePolicyIdScenarioId: _IMAGE_POLICY_ID = 11;
pub const _IMAGE_POLICY_ID_ImagePolicyIdMaximum: _IMAGE_POLICY_ID = 12;
pub type _IMAGE_POLICY_ID = i32;
pub use self::_IMAGE_POLICY_ID as IMAGE_POLICY_ID;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IMAGE_POLICY_ENTRY {
    pub Type: IMAGE_POLICY_ENTRY_TYPE,
    pub PolicyId: IMAGE_POLICY_ID,
    pub u: _IMAGE_POLICY_ENTRY__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _IMAGE_POLICY_ENTRY__bindgen_ty_1 {
    pub None: *const ::std::os::raw::c_void,
    pub BoolValue: BOOLEAN,
    pub Int8Value: INT8,
    pub UInt8Value: UINT8,
    pub Int16Value: INT16,
    pub UInt16Value: UINT16,
    pub Int32Value: INT32,
    pub UInt32Value: UINT32,
    pub Int64Value: INT64,
    pub UInt64Value: UINT64,
    pub AnsiStringValue: PCSTR,
    pub UnicodeStringValue: PCWSTR,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout__IMAGE_POLICY_ENTRY__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).None as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(None)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).BoolValue as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(BoolValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).Int8Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Int8Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).UInt8Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UInt8Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).Int16Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Int16Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).UInt16Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UInt16Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).Int32Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Int32Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).UInt32Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UInt32Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).Int64Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(Int64Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).UInt64Value as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UInt64Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).AnsiStringValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(AnsiStringValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY__bindgen_ty_1>())).UnicodeStringValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY__bindgen_ty_1),
            "::",
            stringify!(UnicodeStringValue)
        )
    );
}
#[test]
fn bindgen_test_layout__IMAGE_POLICY_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_POLICY_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_POLICY_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_POLICY_ENTRY>(),
        8usize,
        concat!("Alignment of ", stringify!(_IMAGE_POLICY_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY>())).PolicyId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY),
            "::",
            stringify!(PolicyId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IMAGE_POLICY_ENTRY>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IMAGE_POLICY_ENTRY),
            "::",
            stringify!(u)
        )
    );
}
pub type IMAGE_POLICY_ENTRY = _IMAGE_POLICY_ENTRY;
pub type PCIMAGE_POLICY_ENTRY = *const IMAGE_POLICY_ENTRY;
#[repr(C)]
pub struct _IMAGE_POLICY_METADATA {
    pub Version: BYTE,
    pub Reserved0: [BYTE; 7usize],
    pub ApplicationId: ULONGLONG,
    pub Policies: __IncompleteArrayField<IMAGE_POLICY_ENTRY>,
}
#[test]
fn bindgen_test_layout__IMAGE_POLICY_METADATA() {
    assert_eq!(
        ::std::mem::size_of::<_IMAGE_POLICY_METADATA>(),
        16usize,
        concat!("Size of: ", stringify!(_IMAGE_POLICY_METADATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_IMAGE_POLICY_METADATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_IMAGE_POLICY_METADATA))
    );
}
pub type IMAGE_POLICY_METADATA = _IMAGE_POLICY_METADATA;
pub type PCIMAGE_POLICY_METADATA = *const IMAGE_POLICY_METADATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION_DEBUG {
    pub Type: WORD,
    pub CreatorBackTraceIndex: WORD,
    pub CriticalSection: *mut _RTL_CRITICAL_SECTION,
    pub ProcessLocksList: LIST_ENTRY,
    pub EntryCount: DWORD,
    pub ContentionCount: DWORD,
    pub Flags: DWORD,
    pub CreatorBackTraceIndexHigh: WORD,
    pub SpareWORD: WORD,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION_DEBUG() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        48usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION_DEBUG>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION_DEBUG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).Type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).CreatorBackTraceIndex
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).CriticalSection as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CriticalSection)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).ProcessLocksList as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ProcessLocksList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).EntryCount as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(EntryCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).ContentionCount as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(ContentionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).Flags as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).CreatorBackTraceIndexHigh
                as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(CreatorBackTraceIndexHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION_DEBUG>())).SpareWORD as *const _ as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION_DEBUG),
            "::",
            stringify!(SpareWORD)
        )
    );
}
pub type RTL_CRITICAL_SECTION_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_CRITICAL_SECTION_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
pub type RTL_RESOURCE_DEBUG = _RTL_CRITICAL_SECTION_DEBUG;
pub type PRTL_RESOURCE_DEBUG = *mut _RTL_CRITICAL_SECTION_DEBUG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CRITICAL_SECTION {
    pub DebugInfo: PRTL_CRITICAL_SECTION_DEBUG,
    pub LockCount: LONG,
    pub RecursionCount: LONG,
    pub OwningThread: HANDLE,
    pub LockSemaphore: HANDLE,
    pub SpinCount: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RTL_CRITICAL_SECTION() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_CRITICAL_SECTION>(),
        40usize,
        concat!("Size of: ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CRITICAL_SECTION>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CRITICAL_SECTION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION>())).DebugInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(DebugInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION>())).LockCount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION>())).RecursionCount as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(RecursionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION>())).OwningThread as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(OwningThread)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION>())).LockSemaphore as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(LockSemaphore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_CRITICAL_SECTION>())).SpinCount as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CRITICAL_SECTION),
            "::",
            stringify!(SpinCount)
        )
    );
}
pub type RTL_CRITICAL_SECTION = _RTL_CRITICAL_SECTION;
pub type PRTL_CRITICAL_SECTION = *mut _RTL_CRITICAL_SECTION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_SRWLOCK {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_SRWLOCK() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_SRWLOCK>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_SRWLOCK))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_SRWLOCK>())).Ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_SRWLOCK),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type RTL_SRWLOCK = _RTL_SRWLOCK;
pub type PRTL_SRWLOCK = *mut _RTL_SRWLOCK;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RTL_CONDITION_VARIABLE {
    pub Ptr: PVOID,
}
#[test]
fn bindgen_test_layout__RTL_CONDITION_VARIABLE() {
    assert_eq!(
        ::std::mem::size_of::<_RTL_CONDITION_VARIABLE>(),
        8usize,
        concat!("Size of: ", stringify!(_RTL_CONDITION_VARIABLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_RTL_CONDITION_VARIABLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_RTL_CONDITION_VARIABLE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_RTL_CONDITION_VARIABLE>())).Ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RTL_CONDITION_VARIABLE),
            "::",
            stringify!(Ptr)
        )
    );
}
pub type RTL_CONDITION_VARIABLE = _RTL_CONDITION_VARIABLE;
pub type PRTL_CONDITION_VARIABLE = *mut _RTL_CONDITION_VARIABLE;
pub type PAPCFUNC = ::std::option::Option<unsafe extern "C" fn(Parameter: ULONG_PTR)>;
pub type PVECTORED_EXCEPTION_HANDLER =
    ::std::option::Option<unsafe extern "C" fn(ExceptionInfo: *mut _EXCEPTION_POINTERS) -> LONG>;
pub const _HEAP_INFORMATION_CLASS_HeapCompatibilityInformation: _HEAP_INFORMATION_CLASS = 0;
pub const _HEAP_INFORMATION_CLASS_HeapEnableTerminationOnCorruption: _HEAP_INFORMATION_CLASS = 1;
pub const _HEAP_INFORMATION_CLASS_HeapOptimizeResources: _HEAP_INFORMATION_CLASS = 3;
pub type _HEAP_INFORMATION_CLASS = i32;
pub use self::_HEAP_INFORMATION_CLASS as HEAP_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION {
    pub Version: DWORD,
    pub Flags: DWORD,
}
#[test]
fn bindgen_test_layout__HEAP_OPTIMIZE_RESOURCES_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>())).Version as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_HEAP_OPTIMIZE_RESOURCES_INFORMATION>())).Flags as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HEAP_OPTIMIZE_RESOURCES_INFORMATION),
            "::",
            stringify!(Flags)
        )
    );
}
pub type HEAP_OPTIMIZE_RESOURCES_INFORMATION = _HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub type PHEAP_OPTIMIZE_RESOURCES_INFORMATION = *mut _HEAP_OPTIMIZE_RESOURCES_INFORMATION;
pub type WAITORTIMERCALLBACKFUNC =
    ::std::option::Option<unsafe extern "C" fn(arg1: PVOID, arg2: BOOLEAN)>;
pub type WORKERCALLBACKFUNC = ::std::option::Option<unsafe extern "C" fn(arg1: PVOID)>;
pub type APC_CALLBACK_FUNCTION =
    ::std::option::Option<unsafe extern "C" fn(arg1: DWORD, arg2: PVOID, arg3: PVOID)>;
pub type WAITORTIMERCALLBACK = WAITORTIMERCALLBACKFUNC;
pub type PFLS_CALLBACK_FUNCTION = ::std::option::Option<unsafe extern "C" fn(lpFlsData: PVOID)>;
pub type PSECURE_MEMORY_CACHE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Addr: PVOID, Range: SIZE_T) -> BOOLEAN>;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_ActivationContextBasicInformation:
    _ACTIVATION_CONTEXT_INFO_CLASS = 1;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_ActivationContextDetailedInformation:
    _ACTIVATION_CONTEXT_INFO_CLASS = 2;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_AssemblyDetailedInformationInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 3;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_FileInformationInAssemblyOfAssemblyInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 4;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_RunlevelInformationInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 5;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_CompatibilityInformationInActivationContext:
    _ACTIVATION_CONTEXT_INFO_CLASS = 6;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_ActivationContextManifestResourceName:
    _ACTIVATION_CONTEXT_INFO_CLASS = 7;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_MaxActivationContextInfoClass:
    _ACTIVATION_CONTEXT_INFO_CLASS = 8;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_AssemblyDetailedInformationInActivationContxt:
    _ACTIVATION_CONTEXT_INFO_CLASS = 3;
pub const _ACTIVATION_CONTEXT_INFO_CLASS_FileInformationInAssemblyOfAssemblyInActivationContxt:
    _ACTIVATION_CONTEXT_INFO_CLASS = 4;
pub type _ACTIVATION_CONTEXT_INFO_CLASS = i32;
pub use self::_ACTIVATION_CONTEXT_INFO_CLASS as ACTIVATION_CONTEXT_INFO_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    pub ulAssemblyIndex: DWORD,
    pub ulFileIndexInAssembly: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_QUERY_INDEX() {
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_QUERY_INDEX>(),
        8usize,
        concat!("Size of: ", stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX))
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_QUERY_INDEX>(),
        4usize,
        concat!("Alignment of ", stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_QUERY_INDEX>())).ulAssemblyIndex as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX),
            "::",
            stringify!(ulAssemblyIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_QUERY_INDEX>())).ulFileIndexInAssembly
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_QUERY_INDEX),
            "::",
            stringify!(ulFileIndexInAssembly)
        )
    );
}
pub type ACTIVATION_CONTEXT_QUERY_INDEX = _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PACTIVATION_CONTEXT_QUERY_INDEX = *mut _ACTIVATION_CONTEXT_QUERY_INDEX;
pub type PCACTIVATION_CONTEXT_QUERY_INDEX = *const _ACTIVATION_CONTEXT_QUERY_INDEX;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    pub ulFlags: DWORD,
    pub ulFilenameLength: DWORD,
    pub ulPathLength: DWORD,
    pub lpFileName: PCWSTR,
    pub lpFilePath: PCWSTR,
}
#[test]
fn bindgen_test_layout__ASSEMBLY_FILE_DETAILED_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ASSEMBLY_FILE_DETAILED_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ASSEMBLY_FILE_DETAILED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).ulFlags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(ulFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).ulFilenameLength
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(ulFilenameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).ulPathLength as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(ulPathLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).lpFileName as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(lpFileName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ASSEMBLY_FILE_DETAILED_INFORMATION>())).lpFilePath as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ASSEMBLY_FILE_DETAILED_INFORMATION),
            "::",
            stringify!(lpFilePath)
        )
    );
}
pub type ASSEMBLY_FILE_DETAILED_INFORMATION = _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PASSEMBLY_FILE_DETAILED_INFORMATION = *mut _ASSEMBLY_FILE_DETAILED_INFORMATION;
pub type PCASSEMBLY_FILE_DETAILED_INFORMATION = *const ASSEMBLY_FILE_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    pub ulFlags: DWORD,
    pub ulEncodedAssemblyIdentityLength: DWORD,
    pub ulManifestPathType: DWORD,
    pub ulManifestPathLength: DWORD,
    pub liManifestLastWriteTime: LARGE_INTEGER,
    pub ulPolicyPathType: DWORD,
    pub ulPolicyPathLength: DWORD,
    pub liPolicyLastWriteTime: LARGE_INTEGER,
    pub ulMetadataSatelliteRosterIndex: DWORD,
    pub ulManifestVersionMajor: DWORD,
    pub ulManifestVersionMinor: DWORD,
    pub ulPolicyVersionMajor: DWORD,
    pub ulPolicyVersionMinor: DWORD,
    pub ulAssemblyDirectoryNameLength: DWORD,
    pub lpAssemblyEncodedAssemblyIdentity: PCWSTR,
    pub lpAssemblyManifestPath: PCWSTR,
    pub lpAssemblyPolicyPath: PCWSTR,
    pub lpAssemblyDirectoryName: PCWSTR,
    pub ulFileCount: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(),
        104usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>())).ulFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulEncodedAssemblyIdentityLength as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulEncodedAssemblyIdentityLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulManifestPathType as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestPathType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulManifestPathLength as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestPathLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .liManifestLastWriteTime as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(liManifestLastWriteTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulPolicyPathType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyPathType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulPolicyPathLength as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyPathLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .liPolicyLastWriteTime as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(liPolicyLastWriteTime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulMetadataSatelliteRosterIndex as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulMetadataSatelliteRosterIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulManifestVersionMajor as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestVersionMajor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulManifestVersionMinor as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulManifestVersionMinor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulPolicyVersionMajor as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyVersionMajor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulPolicyVersionMinor as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulPolicyVersionMinor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulAssemblyDirectoryNameLength as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulAssemblyDirectoryNameLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .lpAssemblyEncodedAssemblyIdentity as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyEncodedAssemblyIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .lpAssemblyManifestPath as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyManifestPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .lpAssemblyPolicyPath as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyPolicyPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .lpAssemblyDirectoryName as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(lpAssemblyDirectoryName)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION>()))
                .ulFileCount as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION),
            "::",
            stringify!(ulFileCount)
        )
    );
}
pub type ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    *mut _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION =
    *const _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_UNSPECIFIED: ACTCTX_REQUESTED_RUN_LEVEL = 0;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_AS_INVOKER: ACTCTX_REQUESTED_RUN_LEVEL = 1;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE:
    ACTCTX_REQUESTED_RUN_LEVEL = 2;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_REQUIRE_ADMIN: ACTCTX_REQUESTED_RUN_LEVEL = 3;
pub const ACTCTX_REQUESTED_RUN_LEVEL_ACTCTX_RUN_LEVEL_NUMBERS: ACTCTX_REQUESTED_RUN_LEVEL = 4;
pub type ACTCTX_REQUESTED_RUN_LEVEL = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    pub ulFlags: DWORD,
    pub RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    pub UiAccess: DWORD,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>())).ulFlags
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
            "::",
            stringify!(ulFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>())).RunLevel
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
            "::",
            stringify!(RunLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION>())).UiAccess
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION),
            "::",
            stringify!(UiAccess)
        )
    );
}
pub type ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = *mut _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub type PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION =
    *const _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN:
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE = 0;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS:
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE = 1;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION:
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE = 2;
pub type ACTCTX_COMPATIBILITY_ELEMENT_TYPE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _COMPATIBILITY_CONTEXT_ELEMENT {
    pub Id: GUID,
    pub Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
}
#[test]
fn bindgen_test_layout__COMPATIBILITY_CONTEXT_ELEMENT() {
    assert_eq!(
        ::std::mem::size_of::<_COMPATIBILITY_CONTEXT_ELEMENT>(),
        20usize,
        concat!("Size of: ", stringify!(_COMPATIBILITY_CONTEXT_ELEMENT))
    );
    assert_eq!(
        ::std::mem::align_of::<_COMPATIBILITY_CONTEXT_ELEMENT>(),
        4usize,
        concat!("Alignment of ", stringify!(_COMPATIBILITY_CONTEXT_ELEMENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_COMPATIBILITY_CONTEXT_ELEMENT>())).Id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_COMPATIBILITY_CONTEXT_ELEMENT),
            "::",
            stringify!(Id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_COMPATIBILITY_CONTEXT_ELEMENT>())).Type as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_COMPATIBILITY_CONTEXT_ELEMENT),
            "::",
            stringify!(Type)
        )
    );
}
pub type COMPATIBILITY_CONTEXT_ELEMENT = _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCOMPATIBILITY_CONTEXT_ELEMENT = *mut _COMPATIBILITY_CONTEXT_ELEMENT;
pub type PCCOMPATIBILITY_CONTEXT_ELEMENT = *const _COMPATIBILITY_CONTEXT_ELEMENT;
#[repr(C)]
#[derive(Debug)]
pub struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    pub ElementCount: DWORD,
    pub Elements: __IncompleteArrayField<COMPATIBILITY_CONTEXT_ELEMENT>,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION)
        )
    );
}
pub type ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    *mut _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
pub type PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION =
    *const _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _SUPPORTED_OS_INFO {
    pub MajorVersion: WORD,
    pub MinorVersion: WORD,
}
#[test]
fn bindgen_test_layout__SUPPORTED_OS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<_SUPPORTED_OS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(_SUPPORTED_OS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_SUPPORTED_OS_INFO>(),
        2usize,
        concat!("Alignment of ", stringify!(_SUPPORTED_OS_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SUPPORTED_OS_INFO>())).MajorVersion as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SUPPORTED_OS_INFO),
            "::",
            stringify!(MajorVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_SUPPORTED_OS_INFO>())).MinorVersion as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_SUPPORTED_OS_INFO),
            "::",
            stringify!(MinorVersion)
        )
    );
}
pub type SUPPORTED_OS_INFO = _SUPPORTED_OS_INFO;
pub type PSUPPORTED_OS_INFO = *mut _SUPPORTED_OS_INFO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    pub dwFlags: DWORD,
    pub ulFormatVersion: DWORD,
    pub ulAssemblyCount: DWORD,
    pub ulRootManifestPathType: DWORD,
    pub ulRootManifestPathChars: DWORD,
    pub ulRootConfigurationPathType: DWORD,
    pub ulRootConfigurationPathChars: DWORD,
    pub ulAppDirPathType: DWORD,
    pub ulAppDirPathChars: DWORD,
    pub lpRootManifestPath: PCWSTR,
    pub lpRootConfigurationPath: PCWSTR,
    pub lpAppDirPath: PCWSTR,
}
#[test]
fn bindgen_test_layout__ACTIVATION_CONTEXT_DETAILED_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).dwFlags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(dwFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulFormatVersion
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulFormatVersion)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulAssemblyCount
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulAssemblyCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
                .ulRootManifestPathType as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootManifestPathType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
                .ulRootManifestPathChars as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootManifestPathChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
                .ulRootConfigurationPathType as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootConfigurationPathType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
                .ulRootConfigurationPathChars as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulRootConfigurationPathChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulAppDirPathType
                as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulAppDirPathType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).ulAppDirPathChars
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(ulAppDirPathChars)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).lpRootManifestPath
                as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(lpRootManifestPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>()))
                .lpRootConfigurationPath as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(lpRootConfigurationPath)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ACTIVATION_CONTEXT_DETAILED_INFORMATION>())).lpAppDirPath
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_ACTIVATION_CONTEXT_DETAILED_INFORMATION),
            "::",
            stringify!(lpAppDirPath)
        )
    );
}
pub type ACTIVATION_CONTEXT_DETAILED_INFORMATION = _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PACTIVATION_CONTEXT_DETAILED_INFORMATION = *mut _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
pub type PCACTIVATION_CONTEXT_DETAILED_INFORMATION =
    *const _ACTIVATION_CONTEXT_DETAILED_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _HARDWARE_COUNTER_DATA {
    pub Type: HARDWARE_COUNTER_TYPE,
    pub Reserved: DWORD,
    pub Value: DWORD64,
}
#[test]
fn bindgen_test_layout__HARDWARE_COUNTER_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_HARDWARE_COUNTER_DATA>(),
        16usize,
        concat!("Size of: ", stringify!(_HARDWARE_COUNTER_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_HARDWARE_COUNTER_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_HARDWARE_COUNTER_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HARDWARE_COUNTER_DATA>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_HARDWARE_COUNTER_DATA),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HARDWARE_COUNTER_DATA>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_HARDWARE_COUNTER_DATA),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_HARDWARE_COUNTER_DATA>())).Value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_HARDWARE_COUNTER_DATA),
            "::",
            stringify!(Value)
        )
    );
}
pub type HARDWARE_COUNTER_DATA = _HARDWARE_COUNTER_DATA;
pub type PHARDWARE_COUNTER_DATA = *mut _HARDWARE_COUNTER_DATA;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _PERFORMANCE_DATA {
    pub Size: WORD,
    pub Version: BYTE,
    pub HwCountersCount: BYTE,
    pub ContextSwitchCount: DWORD,
    pub WaitReasonBitMap: DWORD64,
    pub CycleTime: DWORD64,
    pub RetryCount: DWORD,
    pub Reserved: DWORD,
    pub HwCounters: [HARDWARE_COUNTER_DATA; 16usize],
}
#[test]
fn bindgen_test_layout__PERFORMANCE_DATA() {
    assert_eq!(
        ::std::mem::size_of::<_PERFORMANCE_DATA>(),
        288usize,
        concat!("Size of: ", stringify!(_PERFORMANCE_DATA))
    );
    assert_eq!(
        ::std::mem::align_of::<_PERFORMANCE_DATA>(),
        8usize,
        concat!("Alignment of ", stringify!(_PERFORMANCE_DATA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).Size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(Size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).Version as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).HwCountersCount as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(HwCountersCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).ContextSwitchCount as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(ContextSwitchCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).WaitReasonBitMap as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(WaitReasonBitMap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).CycleTime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(CycleTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).RetryCount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(RetryCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).Reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_PERFORMANCE_DATA>())).HwCounters as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_PERFORMANCE_DATA),
            "::",
            stringify!(HwCounters)
        )
    );
}
pub type PERFORMANCE_DATA = _PERFORMANCE_DATA;
pub type PPERFORMANCE_DATA = *mut _PERFORMANCE_DATA;
extern "C" {
    pub fn RtlGetDeviceFamilyInfoEnum(
        pullUAPInfo: *mut ULONGLONG,
        pulDeviceFamily: *mut DWORD,
        pulDeviceForm: *mut DWORD,
    );
}
extern "C" {
    pub fn RtlConvertDeviceFamilyInfoToString(
        pulDeviceFamilyBufferSize: PDWORD,
        pulDeviceFormBufferSize: PDWORD,
        DeviceFamily: PWSTR,
        DeviceForm: PWSTR,
    ) -> DWORD;
}
extern "C" {
    pub fn RtlSwitchedVVI(
        VersionInfo: PRTL_OSVERSIONINFOEXW,
        TypeMask: DWORD,
        ConditionMask: ULONGLONG,
    ) -> DWORD;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _EVENTLOGRECORD {
    pub Length: DWORD,
    pub Reserved: DWORD,
    pub RecordNumber: DWORD,
    pub TimeGenerated: DWORD,
    pub TimeWritten: DWORD,
    pub EventID: DWORD,
    pub EventType: WORD,
    pub NumStrings: WORD,
    pub EventCategory: WORD,
    pub ReservedFlags: WORD,
    pub ClosingRecordNumber: DWORD,
    pub StringOffset: DWORD,
    pub UserSidLength: DWORD,
    pub UserSidOffset: DWORD,
    pub DataLength: DWORD,
    pub DataOffset: DWORD,
}
#[test]
fn bindgen_test_layout__EVENTLOGRECORD() {
    assert_eq!(
        ::std::mem::size_of::<_EVENTLOGRECORD>(),
        56usize,
        concat!("Size of: ", stringify!(_EVENTLOGRECORD))
    );
    assert_eq!(
        ::std::mem::align_of::<_EVENTLOGRECORD>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENTLOGRECORD))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).Length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(Length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).RecordNumber as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(RecordNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).TimeGenerated as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(TimeGenerated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).TimeWritten as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(TimeWritten)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).EventID as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(EventID)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).EventType as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(EventType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).NumStrings as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(NumStrings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).EventCategory as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(EventCategory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).ReservedFlags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(ReservedFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_EVENTLOGRECORD>())).ClosingRecordNumber as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(ClosingRecordNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).StringOffset as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(StringOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).UserSidLength as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(UserSidLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).UserSidOffset as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(UserSidOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).DataLength as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(DataLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_EVENTLOGRECORD>())).DataOffset as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_EVENTLOGRECORD),
            "::",
            stringify!(DataOffset)
        )
    );
}
pub type EVENTLOGRECORD = _EVENTLOGRECORD;
pub type PEVENTLOGRECORD = *mut _EVENTLOGRECORD;
pub type EVENTSFORLOGFILE = _EVENTSFORLOGFILE;
pub type PEVENTSFORLOGFILE = *mut _EVENTSFORLOGFILE;
pub type PACKEDEVENTINFO = _PACKEDEVENTINFO;
pub type PPACKEDEVENTINFO = *mut _PACKEDEVENTINFO;
#[repr(C)]
pub struct _EVENTSFORLOGFILE {
    pub ulSize: DWORD,
    pub szLogicalLogFile: [WCHAR; 256usize],
    pub ulNumRecords: DWORD,
    pub pEventLogRecords: __IncompleteArrayField<EVENTLOGRECORD>,
}
#[test]
fn bindgen_test_layout__EVENTSFORLOGFILE() {
    assert_eq!(
        ::std::mem::size_of::<_EVENTSFORLOGFILE>(),
        520usize,
        concat!("Size of: ", stringify!(_EVENTSFORLOGFILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_EVENTSFORLOGFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(_EVENTSFORLOGFILE))
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct _PACKEDEVENTINFO {
    pub ulSize: DWORD,
    pub ulNumEventsForLogFile: DWORD,
    pub ulOffsets: __IncompleteArrayField<DWORD>,
}
#[test]
fn bindgen_test_layout__PACKEDEVENTINFO() {
    assert_eq!(
        ::std::mem::size_of::<_PACKEDEVENTINFO>(),
        8usize,
        concat!("Size of: ", stringify!(_PACKEDEVENTINFO))
    );
    assert_eq!(
        ::std::mem::align_of::<_PACKEDEVENTINFO>(),
        4usize,
        concat!("Alignment of ", stringify!(_PACKEDEVENTINFO))
    );
}
pub const _CM_SERVICE_NODE_TYPE_DriverType: _CM_SERVICE_NODE_TYPE = 1;
pub const _CM_SERVICE_NODE_TYPE_FileSystemType: _CM_SERVICE_NODE_TYPE = 2;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceOwnProcess: _CM_SERVICE_NODE_TYPE = 16;
pub const _CM_SERVICE_NODE_TYPE_Win32ServiceShareProcess: _CM_SERVICE_NODE_TYPE = 32;
pub const _CM_SERVICE_NODE_TYPE_AdapterType: _CM_SERVICE_NODE_TYPE = 4;
pub const _CM_SERVICE_NODE_TYPE_RecognizerType: _CM_SERVICE_NODE_TYPE = 8;
pub type _CM_SERVICE_NODE_TYPE = i32;
pub use self::_CM_SERVICE_NODE_TYPE as SERVICE_NODE_TYPE;
pub const _CM_SERVICE_LOAD_TYPE_BootLoad: _CM_SERVICE_LOAD_TYPE = 0;
pub const _CM_SERVICE_LOAD_TYPE_SystemLoad: _CM_SERVICE_LOAD_TYPE = 1;
pub const _CM_SERVICE_LOAD_TYPE_AutoLoad: _CM_SERVICE_LOAD_TYPE = 2;
pub const _CM_SERVICE_LOAD_TYPE_DemandLoad: _CM_SERVICE_LOAD_TYPE = 3;
pub const _CM_SERVICE_LOAD_TYPE_DisableLoad: _CM_SERVICE_LOAD_TYPE = 4;
pub type _CM_SERVICE_LOAD_TYPE = i32;
pub use self::_CM_SERVICE_LOAD_TYPE as SERVICE_LOAD_TYPE;
pub const _CM_ERROR_CONTROL_TYPE_IgnoreError: _CM_ERROR_CONTROL_TYPE = 0;
pub const _CM_ERROR_CONTROL_TYPE_NormalError: _CM_ERROR_CONTROL_TYPE = 1;
pub const _CM_ERROR_CONTROL_TYPE_SevereError: _CM_ERROR_CONTROL_TYPE = 2;
pub const _CM_ERROR_CONTROL_TYPE_CriticalError: _CM_ERROR_CONTROL_TYPE = 3;
pub type _CM_ERROR_CONTROL_TYPE = i32;
pub use self::_CM_ERROR_CONTROL_TYPE as SERVICE_ERROR_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_ERASE {
    pub Type: DWORD,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_ERASE() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_ERASE>(),
        8usize,
        concat!("Size of: ", stringify!(_TAPE_ERASE))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_ERASE>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_ERASE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_ERASE>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_ERASE),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_ERASE>())).Immediate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_ERASE),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_ERASE = _TAPE_ERASE;
pub type PTAPE_ERASE = *mut _TAPE_ERASE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_PREPARE {
    pub Operation: DWORD,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_PREPARE() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_PREPARE>(),
        8usize,
        concat!("Size of: ", stringify!(_TAPE_PREPARE))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_PREPARE>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_PREPARE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_PREPARE>())).Operation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_PREPARE),
            "::",
            stringify!(Operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_PREPARE>())).Immediate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_PREPARE),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_PREPARE = _TAPE_PREPARE;
pub type PTAPE_PREPARE = *mut _TAPE_PREPARE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_WRITE_MARKS {
    pub Type: DWORD,
    pub Count: DWORD,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_WRITE_MARKS() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_WRITE_MARKS>(),
        12usize,
        concat!("Size of: ", stringify!(_TAPE_WRITE_MARKS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_WRITE_MARKS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_WRITE_MARKS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_WRITE_MARKS>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WRITE_MARKS),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_WRITE_MARKS>())).Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WRITE_MARKS),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_WRITE_MARKS>())).Immediate as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WRITE_MARKS),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_WRITE_MARKS = _TAPE_WRITE_MARKS;
pub type PTAPE_WRITE_MARKS = *mut _TAPE_WRITE_MARKS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_POSITION {
    pub Type: DWORD,
    pub Partition: DWORD,
    pub Offset: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TAPE_GET_POSITION() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_GET_POSITION>(),
        16usize,
        concat!("Size of: ", stringify!(_TAPE_GET_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_GET_POSITION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_GET_POSITION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_GET_POSITION>())).Type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_POSITION),
            "::",
            stringify!(Type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_GET_POSITION>())).Partition as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_POSITION),
            "::",
            stringify!(Partition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_GET_POSITION>())).Offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_POSITION),
            "::",
            stringify!(Offset)
        )
    );
}
pub type TAPE_GET_POSITION = _TAPE_GET_POSITION;
pub type PTAPE_GET_POSITION = *mut _TAPE_GET_POSITION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_SET_POSITION {
    pub Method: DWORD,
    pub Partition: DWORD,
    pub Offset: LARGE_INTEGER,
    pub Immediate: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_SET_POSITION() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_SET_POSITION>(),
        24usize,
        concat!("Size of: ", stringify!(_TAPE_SET_POSITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_SET_POSITION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_SET_POSITION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_SET_POSITION>())).Method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_SET_POSITION>())).Partition as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Partition)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_SET_POSITION>())).Offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_SET_POSITION>())).Immediate as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_POSITION),
            "::",
            stringify!(Immediate)
        )
    );
}
pub type TAPE_SET_POSITION = _TAPE_SET_POSITION;
pub type PTAPE_SET_POSITION = *mut _TAPE_SET_POSITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_GET_DRIVE_PARAMETERS {
    pub ECC: BOOLEAN,
    pub Compression: BOOLEAN,
    pub DataPadding: BOOLEAN,
    pub ReportSetmarks: BOOLEAN,
    pub DefaultBlockSize: DWORD,
    pub MaximumBlockSize: DWORD,
    pub MinimumBlockSize: DWORD,
    pub MaximumPartitionCount: DWORD,
    pub FeaturesLow: DWORD,
    pub FeaturesHigh: DWORD,
    pub EOTWarningZoneSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_GET_DRIVE_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_GET_DRIVE_PARAMETERS>(),
        32usize,
        concat!("Size of: ", stringify!(_TAPE_GET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_GET_DRIVE_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_GET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).ECC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(ECC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).Compression as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(Compression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).DataPadding as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(DataPadding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).ReportSetmarks as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(ReportSetmarks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).DefaultBlockSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(DefaultBlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).MaximumBlockSize as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(MaximumBlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).MinimumBlockSize as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(MinimumBlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).MaximumPartitionCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(MaximumPartitionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).FeaturesLow as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(FeaturesLow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).FeaturesHigh as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(FeaturesHigh)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_DRIVE_PARAMETERS>())).EOTWarningZoneSize as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_DRIVE_PARAMETERS),
            "::",
            stringify!(EOTWarningZoneSize)
        )
    );
}
pub type TAPE_GET_DRIVE_PARAMETERS = _TAPE_GET_DRIVE_PARAMETERS;
pub type PTAPE_GET_DRIVE_PARAMETERS = *mut _TAPE_GET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_SET_DRIVE_PARAMETERS {
    pub ECC: BOOLEAN,
    pub Compression: BOOLEAN,
    pub DataPadding: BOOLEAN,
    pub ReportSetmarks: BOOLEAN,
    pub EOTWarningZoneSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_SET_DRIVE_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_SET_DRIVE_PARAMETERS>(),
        8usize,
        concat!("Size of: ", stringify!(_TAPE_SET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_SET_DRIVE_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_SET_DRIVE_PARAMETERS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).ECC as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(ECC)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).Compression as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(Compression)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).DataPadding as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(DataPadding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).ReportSetmarks as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(ReportSetmarks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_SET_DRIVE_PARAMETERS>())).EOTWarningZoneSize as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_DRIVE_PARAMETERS),
            "::",
            stringify!(EOTWarningZoneSize)
        )
    );
}
pub type TAPE_SET_DRIVE_PARAMETERS = _TAPE_SET_DRIVE_PARAMETERS;
pub type PTAPE_SET_DRIVE_PARAMETERS = *mut _TAPE_SET_DRIVE_PARAMETERS;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TAPE_GET_MEDIA_PARAMETERS {
    pub Capacity: LARGE_INTEGER,
    pub Remaining: LARGE_INTEGER,
    pub BlockSize: DWORD,
    pub PartitionCount: DWORD,
    pub WriteProtected: BOOLEAN,
}
#[test]
fn bindgen_test_layout__TAPE_GET_MEDIA_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_GET_MEDIA_PARAMETERS>(),
        32usize,
        concat!("Size of: ", stringify!(_TAPE_GET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_GET_MEDIA_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_GET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).Capacity as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(Capacity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).Remaining as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(Remaining)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).BlockSize as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(BlockSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).PartitionCount as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(PartitionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_GET_MEDIA_PARAMETERS>())).WriteProtected as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_GET_MEDIA_PARAMETERS),
            "::",
            stringify!(WriteProtected)
        )
    );
}
pub type TAPE_GET_MEDIA_PARAMETERS = _TAPE_GET_MEDIA_PARAMETERS;
pub type PTAPE_GET_MEDIA_PARAMETERS = *mut _TAPE_GET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_SET_MEDIA_PARAMETERS {
    pub BlockSize: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_SET_MEDIA_PARAMETERS() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_SET_MEDIA_PARAMETERS>(),
        4usize,
        concat!("Size of: ", stringify!(_TAPE_SET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_SET_MEDIA_PARAMETERS>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_SET_MEDIA_PARAMETERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_SET_MEDIA_PARAMETERS>())).BlockSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_SET_MEDIA_PARAMETERS),
            "::",
            stringify!(BlockSize)
        )
    );
}
pub type TAPE_SET_MEDIA_PARAMETERS = _TAPE_SET_MEDIA_PARAMETERS;
pub type PTAPE_SET_MEDIA_PARAMETERS = *mut _TAPE_SET_MEDIA_PARAMETERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_CREATE_PARTITION {
    pub Method: DWORD,
    pub Count: DWORD,
    pub Size: DWORD,
}
#[test]
fn bindgen_test_layout__TAPE_CREATE_PARTITION() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_CREATE_PARTITION>(),
        12usize,
        concat!("Size of: ", stringify!(_TAPE_CREATE_PARTITION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_CREATE_PARTITION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TAPE_CREATE_PARTITION))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_CREATE_PARTITION>())).Method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_CREATE_PARTITION),
            "::",
            stringify!(Method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_CREATE_PARTITION>())).Count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_CREATE_PARTITION),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_CREATE_PARTITION>())).Size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_CREATE_PARTITION),
            "::",
            stringify!(Size)
        )
    );
}
pub type TAPE_CREATE_PARTITION = _TAPE_CREATE_PARTITION;
pub type PTAPE_CREATE_PARTITION = *mut _TAPE_CREATE_PARTITION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TAPE_WMI_OPERATIONS {
    pub Method: DWORD,
    pub DataBufferSize: DWORD,
    pub DataBuffer: PVOID,
}
#[test]
fn bindgen_test_layout__TAPE_WMI_OPERATIONS() {
    assert_eq!(
        ::std::mem::size_of::<_TAPE_WMI_OPERATIONS>(),
        16usize,
        concat!("Size of: ", stringify!(_TAPE_WMI_OPERATIONS))
    );
    assert_eq!(
        ::std::mem::align_of::<_TAPE_WMI_OPERATIONS>(),
        8usize,
        concat!("Alignment of ", stringify!(_TAPE_WMI_OPERATIONS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_WMI_OPERATIONS>())).Method as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WMI_OPERATIONS),
            "::",
            stringify!(Method)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TAPE_WMI_OPERATIONS>())).DataBufferSize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WMI_OPERATIONS),
            "::",
            stringify!(DataBufferSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TAPE_WMI_OPERATIONS>())).DataBuffer as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TAPE_WMI_OPERATIONS),
            "::",
            stringify!(DataBuffer)
        )
    );
}
pub type TAPE_WMI_OPERATIONS = _TAPE_WMI_OPERATIONS;
pub type PTAPE_WMI_OPERATIONS = *mut _TAPE_WMI_OPERATIONS;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveProblemNone: _TAPE_DRIVE_PROBLEM_TYPE = 0;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadWriteWarning: _TAPE_DRIVE_PROBLEM_TYPE = 1;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadWriteError: _TAPE_DRIVE_PROBLEM_TYPE = 2;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadWarning: _TAPE_DRIVE_PROBLEM_TYPE = 3;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveWriteWarning: _TAPE_DRIVE_PROBLEM_TYPE = 4;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveReadError: _TAPE_DRIVE_PROBLEM_TYPE = 5;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveWriteError: _TAPE_DRIVE_PROBLEM_TYPE = 6;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveHardwareError: _TAPE_DRIVE_PROBLEM_TYPE = 7;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveUnsupportedMedia: _TAPE_DRIVE_PROBLEM_TYPE = 8;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveScsiConnectionError: _TAPE_DRIVE_PROBLEM_TYPE = 9;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveTimetoClean: _TAPE_DRIVE_PROBLEM_TYPE = 10;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveCleanDriveNow: _TAPE_DRIVE_PROBLEM_TYPE = 11;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveMediaLifeExpired: _TAPE_DRIVE_PROBLEM_TYPE = 12;
pub const _TAPE_DRIVE_PROBLEM_TYPE_TapeDriveSnappedTape: _TAPE_DRIVE_PROBLEM_TYPE = 13;
pub type _TAPE_DRIVE_PROBLEM_TYPE = i32;
pub use self::_TAPE_DRIVE_PROBLEM_TYPE as TAPE_DRIVE_PROBLEM_TYPE;
pub type UOW = GUID;
pub type PUOW = *mut GUID;
pub type CRM_PROTOCOL_ID = GUID;
pub type PCRM_PROTOCOL_ID = *mut GUID;
pub type NOTIFICATION_MASK = ULONG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION {
    pub TransactionKey: PVOID,
    pub TransactionNotification: ULONG,
    pub TmVirtualClock: LARGE_INTEGER,
    pub ArgumentLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION>(),
        32usize,
        concat!("Size of: ", stringify!(_TRANSACTION_NOTIFICATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_NOTIFICATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION>())).TransactionKey as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(TransactionKey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION>())).TransactionNotification
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(TransactionNotification)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION>())).TmVirtualClock as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(TmVirtualClock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION>())).ArgumentLength as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION),
            "::",
            stringify!(ArgumentLength)
        )
    );
}
pub type TRANSACTION_NOTIFICATION = _TRANSACTION_NOTIFICATION;
pub type PTRANSACTION_NOTIFICATION = *mut _TRANSACTION_NOTIFICATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    pub EnlistmentId: GUID,
    pub UOW: UOW,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>())).EnlistmentId
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT),
            "::",
            stringify!(EnlistmentId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT>())).UOW as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT),
            "::",
            stringify!(UOW)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT = _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    pub TmIdentity: GUID,
    pub Flags: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>())).TmIdentity
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT>())).Flags
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT),
            "::",
            stringify!(Flags)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT = _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;
pub type SAVEPOINT_ID = ULONG;
pub type PSAVEPOINT_ID = *mut ULONG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    pub SavepointId: SAVEPOINT_ID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT>())).SavepointId
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT),
            "::",
            stringify!(SavepointId)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT = _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    pub PropagationCookie: ULONG,
    pub UOW: GUID,
    pub TmIdentity: GUID,
    pub BufferLength: ULONG,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>()))
                .PropagationCookie as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(PropagationCookie)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).UOW as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(UOW)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).TmIdentity
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT>())).BufferLength
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT),
            "::",
            stringify!(BufferLength)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT = _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    pub MarshalCookie: ULONG,
    pub UOW: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>(),
        20usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>())).MarshalCookie
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT),
            "::",
            stringify!(MarshalCookie)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT>())).UOW as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT),
            "::",
            stringify!(UOW)
        )
    );
}
pub type TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT = _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT =
    *mut _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;
pub type TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT = TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
pub type PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT =
    *mut TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_MARSHAL_HEADER {
    pub VersionMajor: ULONG,
    pub VersionMinor: ULONG,
    pub NumProtocols: ULONG,
    pub Unused: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_MARSHAL_HEADER() {
    assert_eq!(
        ::std::mem::size_of::<_KCRM_MARSHAL_HEADER>(),
        16usize,
        concat!("Size of: ", stringify!(_KCRM_MARSHAL_HEADER))
    );
    assert_eq!(
        ::std::mem::align_of::<_KCRM_MARSHAL_HEADER>(),
        4usize,
        concat!("Alignment of ", stringify!(_KCRM_MARSHAL_HEADER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_MARSHAL_HEADER>())).VersionMajor as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(VersionMajor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_MARSHAL_HEADER>())).VersionMinor as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(VersionMinor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_MARSHAL_HEADER>())).NumProtocols as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(NumProtocols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KCRM_MARSHAL_HEADER>())).Unused as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_MARSHAL_HEADER),
            "::",
            stringify!(Unused)
        )
    );
}
pub type KCRM_MARSHAL_HEADER = _KCRM_MARSHAL_HEADER;
pub type PKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
pub type PRKCRM_MARSHAL_HEADER = *mut _KCRM_MARSHAL_HEADER;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _KCRM_TRANSACTION_BLOB {
    pub UOW: UOW,
    pub TmIdentity: GUID,
    pub IsolationLevel: ULONG,
    pub IsolationFlags: ULONG,
    pub Timeout: ULONG,
    pub Description: [WCHAR; 64usize],
}
#[test]
fn bindgen_test_layout__KCRM_TRANSACTION_BLOB() {
    assert_eq!(
        ::std::mem::size_of::<_KCRM_TRANSACTION_BLOB>(),
        172usize,
        concat!("Size of: ", stringify!(_KCRM_TRANSACTION_BLOB))
    );
    assert_eq!(
        ::std::mem::align_of::<_KCRM_TRANSACTION_BLOB>(),
        4usize,
        concat!("Alignment of ", stringify!(_KCRM_TRANSACTION_BLOB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KCRM_TRANSACTION_BLOB>())).UOW as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(UOW)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_TRANSACTION_BLOB>())).TmIdentity as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_TRANSACTION_BLOB>())).IsolationLevel as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(IsolationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_TRANSACTION_BLOB>())).IsolationFlags as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(IsolationFlags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KCRM_TRANSACTION_BLOB>())).Timeout as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_TRANSACTION_BLOB>())).Description as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_TRANSACTION_BLOB),
            "::",
            stringify!(Description)
        )
    );
}
pub type KCRM_TRANSACTION_BLOB = _KCRM_TRANSACTION_BLOB;
pub type PKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
pub type PRKCRM_TRANSACTION_BLOB = *mut _KCRM_TRANSACTION_BLOB;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KCRM_PROTOCOL_BLOB {
    pub ProtocolId: CRM_PROTOCOL_ID,
    pub StaticInfoLength: ULONG,
    pub TransactionIdInfoLength: ULONG,
    pub Unused1: ULONG,
    pub Unused2: ULONG,
}
#[test]
fn bindgen_test_layout__KCRM_PROTOCOL_BLOB() {
    assert_eq!(
        ::std::mem::size_of::<_KCRM_PROTOCOL_BLOB>(),
        32usize,
        concat!("Size of: ", stringify!(_KCRM_PROTOCOL_BLOB))
    );
    assert_eq!(
        ::std::mem::align_of::<_KCRM_PROTOCOL_BLOB>(),
        4usize,
        concat!("Alignment of ", stringify!(_KCRM_PROTOCOL_BLOB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KCRM_PROTOCOL_BLOB>())).ProtocolId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(ProtocolId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_PROTOCOL_BLOB>())).StaticInfoLength as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(StaticInfoLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_KCRM_PROTOCOL_BLOB>())).TransactionIdInfoLength as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(TransactionIdInfoLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KCRM_PROTOCOL_BLOB>())).Unused1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(Unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KCRM_PROTOCOL_BLOB>())).Unused2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_KCRM_PROTOCOL_BLOB),
            "::",
            stringify!(Unused2)
        )
    );
}
pub type KCRM_PROTOCOL_BLOB = _KCRM_PROTOCOL_BLOB;
pub type PKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub type PRKCRM_PROTOCOL_BLOB = *mut _KCRM_PROTOCOL_BLOB;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeUndetermined: _TRANSACTION_OUTCOME = 1;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeCommitted: _TRANSACTION_OUTCOME = 2;
pub const _TRANSACTION_OUTCOME_TransactionOutcomeAborted: _TRANSACTION_OUTCOME = 3;
pub type _TRANSACTION_OUTCOME = i32;
pub use self::_TRANSACTION_OUTCOME as TRANSACTION_OUTCOME;
pub const _TRANSACTION_STATE_TransactionStateNormal: _TRANSACTION_STATE = 1;
pub const _TRANSACTION_STATE_TransactionStateIndoubt: _TRANSACTION_STATE = 2;
pub const _TRANSACTION_STATE_TransactionStateCommittedNotify: _TRANSACTION_STATE = 3;
pub type _TRANSACTION_STATE = i32;
pub use self::_TRANSACTION_STATE as TRANSACTION_STATE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BASIC_INFORMATION {
    pub TransactionId: GUID,
    pub State: DWORD,
    pub Outcome: DWORD,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_BASIC_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_TRANSACTION_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_BASIC_INFORMATION>())).TransactionId as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BASIC_INFORMATION),
            "::",
            stringify!(TransactionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_BASIC_INFORMATION>())).State as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BASIC_INFORMATION),
            "::",
            stringify!(State)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_BASIC_INFORMATION>())).Outcome as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BASIC_INFORMATION),
            "::",
            stringify!(Outcome)
        )
    );
}
pub type TRANSACTION_BASIC_INFORMATION = _TRANSACTION_BASIC_INFORMATION;
pub type PTRANSACTION_BASIC_INFORMATION = *mut _TRANSACTION_BASIC_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    pub TmIdentity: GUID,
    pub VirtualClock: LARGE_INTEGER,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_BASIC_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_BASIC_INFORMATION>())).TmIdentity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(TmIdentity)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_BASIC_INFORMATION>())).VirtualClock
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(VirtualClock)
        )
    );
}
pub type TRANSACTIONMANAGER_BASIC_INFORMATION = _TRANSACTIONMANAGER_BASIC_INFORMATION;
pub type PTRANSACTIONMANAGER_BASIC_INFORMATION = *mut _TRANSACTIONMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    pub LogIdentity: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOG_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_LOG_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_LOG_INFORMATION>())).LogIdentity as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_LOG_INFORMATION),
            "::",
            stringify!(LogIdentity)
        )
    );
}
pub type TRANSACTIONMANAGER_LOG_INFORMATION = _TRANSACTIONMANAGER_LOG_INFORMATION;
pub type PTRANSACTIONMANAGER_LOG_INFORMATION = *mut _TRANSACTIONMANAGER_LOG_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    pub LogPathLength: DWORD,
    pub LogPath: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_LOGPATH_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>())).LogPathLength
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION),
            "::",
            stringify!(LogPathLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_LOGPATH_INFORMATION>())).LogPath as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_LOGPATH_INFORMATION),
            "::",
            stringify!(LogPath)
        )
    );
}
pub type TRANSACTIONMANAGER_LOGPATH_INFORMATION = _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
pub type PTRANSACTIONMANAGER_LOGPATH_INFORMATION = *mut _TRANSACTIONMANAGER_LOGPATH_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    pub LastRecoveredLsn: ULONGLONG,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_RECOVERY_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_RECOVERY_INFORMATION>())).LastRecoveredLsn
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_RECOVERY_INFORMATION),
            "::",
            stringify!(LastRecoveredLsn)
        )
    );
}
pub type TRANSACTIONMANAGER_RECOVERY_INFORMATION = _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
pub type PTRANSACTIONMANAGER_RECOVERY_INFORMATION = *mut _TRANSACTIONMANAGER_RECOVERY_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    pub OldestTransactionGuid: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTIONMANAGER_OLDEST_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTIONMANAGER_OLDEST_INFORMATION>())).OldestTransactionGuid
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTIONMANAGER_OLDEST_INFORMATION),
            "::",
            stringify!(OldestTransactionGuid)
        )
    );
}
pub type TRANSACTIONMANAGER_OLDEST_INFORMATION = _TRANSACTIONMANAGER_OLDEST_INFORMATION;
pub type PTRANSACTIONMANAGER_OLDEST_INFORMATION = *mut _TRANSACTIONMANAGER_OLDEST_INFORMATION;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TRANSACTION_PROPERTIES_INFORMATION {
    pub IsolationLevel: DWORD,
    pub IsolationFlags: DWORD,
    pub Timeout: LARGE_INTEGER,
    pub Outcome: DWORD,
    pub DescriptionLength: DWORD,
    pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_PROPERTIES_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_PROPERTIES_INFORMATION>(),
        32usize,
        concat!("Size of: ", stringify!(_TRANSACTION_PROPERTIES_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_PROPERTIES_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).IsolationLevel
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(IsolationLevel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).IsolationFlags
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(IsolationFlags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).Timeout as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(Timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).Outcome as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(Outcome)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).DescriptionLength
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(DescriptionLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_PROPERTIES_INFORMATION>())).Description as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_PROPERTIES_INFORMATION),
            "::",
            stringify!(Description)
        )
    );
}
pub type TRANSACTION_PROPERTIES_INFORMATION = _TRANSACTION_PROPERTIES_INFORMATION;
pub type PTRANSACTION_PROPERTIES_INFORMATION = *mut _TRANSACTION_PROPERTIES_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_BIND_INFORMATION {
    pub TmHandle: HANDLE,
}
#[test]
fn bindgen_test_layout__TRANSACTION_BIND_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_BIND_INFORMATION>(),
        8usize,
        concat!("Size of: ", stringify!(_TRANSACTION_BIND_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_BIND_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_BIND_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_BIND_INFORMATION>())).TmHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_BIND_INFORMATION),
            "::",
            stringify!(TmHandle)
        )
    );
}
pub type TRANSACTION_BIND_INFORMATION = _TRANSACTION_BIND_INFORMATION;
pub type PTRANSACTION_BIND_INFORMATION = *mut _TRANSACTION_BIND_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENT_PAIR {
    pub EnlistmentId: GUID,
    pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENT_PAIR() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_ENLISTMENT_PAIR>(),
        32usize,
        concat!("Size of: ", stringify!(_TRANSACTION_ENLISTMENT_PAIR))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_ENLISTMENT_PAIR>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_ENLISTMENT_PAIR))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_ENLISTMENT_PAIR>())).EnlistmentId as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENT_PAIR),
            "::",
            stringify!(EnlistmentId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_ENLISTMENT_PAIR>())).ResourceManagerId as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENT_PAIR),
            "::",
            stringify!(ResourceManagerId)
        )
    );
}
pub type TRANSACTION_ENLISTMENT_PAIR = _TRANSACTION_ENLISTMENT_PAIR;
pub type PTRANSACTION_ENLISTMENT_PAIR = *mut _TRANSACTION_ENLISTMENT_PAIR;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    pub NumberOfEnlistments: DWORD,
    pub EnlistmentPair: [TRANSACTION_ENLISTMENT_PAIR; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_ENLISTMENTS_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>(),
        36usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_ENLISTMENTS_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_ENLISTMENTS_INFORMATION>())).NumberOfEnlistments
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION),
            "::",
            stringify!(NumberOfEnlistments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_ENLISTMENTS_INFORMATION>())).EnlistmentPair
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_ENLISTMENTS_INFORMATION),
            "::",
            stringify!(EnlistmentPair)
        )
    );
}
pub type TRANSACTION_ENLISTMENTS_INFORMATION = _TRANSACTION_ENLISTMENTS_INFORMATION;
pub type PTRANSACTION_ENLISTMENTS_INFORMATION = *mut _TRANSACTION_ENLISTMENTS_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    pub SuperiorEnlistmentPair: TRANSACTION_ENLISTMENT_PAIR,
}
#[test]
fn bindgen_test_layout__TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION>()))
                .SuperiorEnlistmentPair as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION),
            "::",
            stringify!(SuperiorEnlistmentPair)
        )
    );
}
pub type TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION = _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
pub type PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION =
    *mut _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_BASIC_INFORMATION {
    pub ResourceManagerId: GUID,
    pub DescriptionLength: DWORD,
    pub Description: [WCHAR; 1usize],
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_RESOURCEMANAGER_BASIC_INFORMATION>(),
        24usize,
        concat!("Size of: ", stringify!(_RESOURCEMANAGER_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_RESOURCEMANAGER_BASIC_INFORMATION>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESOURCEMANAGER_BASIC_INFORMATION>())).ResourceManagerId
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(ResourceManagerId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESOURCEMANAGER_BASIC_INFORMATION>())).DescriptionLength
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(DescriptionLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESOURCEMANAGER_BASIC_INFORMATION>())).Description as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_BASIC_INFORMATION),
            "::",
            stringify!(Description)
        )
    );
}
pub type RESOURCEMANAGER_BASIC_INFORMATION = _RESOURCEMANAGER_BASIC_INFORMATION;
pub type PRESOURCEMANAGER_BASIC_INFORMATION = *mut _RESOURCEMANAGER_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    pub IoCompletionPortHandle: HANDLE,
    pub CompletionKey: ULONG_PTR,
}
#[test]
fn bindgen_test_layout__RESOURCEMANAGER_COMPLETION_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_RESOURCEMANAGER_COMPLETION_INFORMATION>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESOURCEMANAGER_COMPLETION_INFORMATION>()))
                .IoCompletionPortHandle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION),
            "::",
            stringify!(IoCompletionPortHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_RESOURCEMANAGER_COMPLETION_INFORMATION>())).CompletionKey
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_RESOURCEMANAGER_COMPLETION_INFORMATION),
            "::",
            stringify!(CompletionKey)
        )
    );
}
pub type RESOURCEMANAGER_COMPLETION_INFORMATION = _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub type PRESOURCEMANAGER_COMPLETION_INFORMATION = *mut _RESOURCEMANAGER_COMPLETION_INFORMATION;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionBasicInformation:
    _TRANSACTION_INFORMATION_CLASS = 0;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionPropertiesInformation:
    _TRANSACTION_INFORMATION_CLASS = 1;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionEnlistmentInformation:
    _TRANSACTION_INFORMATION_CLASS = 2;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionSuperiorEnlistmentInformation:
    _TRANSACTION_INFORMATION_CLASS = 3;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionBindInformation:
    _TRANSACTION_INFORMATION_CLASS = 4;
pub const _TRANSACTION_INFORMATION_CLASS_TransactionDTCPrivateInformation:
    _TRANSACTION_INFORMATION_CLASS = 5;
pub type _TRANSACTION_INFORMATION_CLASS = i32;
pub use self::_TRANSACTION_INFORMATION_CLASS as TRANSACTION_INFORMATION_CLASS;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerBasicInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 0;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 1;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerLogPathInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 2;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerRecoveryInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 4;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerOnlineProbeInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 3;
pub const _TRANSACTIONMANAGER_INFORMATION_CLASS_TransactionManagerOldestTransactionInformation:
    _TRANSACTIONMANAGER_INFORMATION_CLASS = 5;
pub type _TRANSACTIONMANAGER_INFORMATION_CLASS = i32;
pub use self::_TRANSACTIONMANAGER_INFORMATION_CLASS as TRANSACTIONMANAGER_INFORMATION_CLASS;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerBasicInformation:
    _RESOURCEMANAGER_INFORMATION_CLASS = 0;
pub const _RESOURCEMANAGER_INFORMATION_CLASS_ResourceManagerCompletionInformation:
    _RESOURCEMANAGER_INFORMATION_CLASS = 1;
pub type _RESOURCEMANAGER_INFORMATION_CLASS = i32;
pub use self::_RESOURCEMANAGER_INFORMATION_CLASS as RESOURCEMANAGER_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_BASIC_INFORMATION {
    pub EnlistmentId: GUID,
    pub TransactionId: GUID,
    pub ResourceManagerId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_BASIC_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ENLISTMENT_BASIC_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_ENLISTMENT_BASIC_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENLISTMENT_BASIC_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENLISTMENT_BASIC_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENLISTMENT_BASIC_INFORMATION>())).EnlistmentId as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_BASIC_INFORMATION),
            "::",
            stringify!(EnlistmentId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENLISTMENT_BASIC_INFORMATION>())).TransactionId as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_BASIC_INFORMATION),
            "::",
            stringify!(TransactionId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENLISTMENT_BASIC_INFORMATION>())).ResourceManagerId as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_BASIC_INFORMATION),
            "::",
            stringify!(ResourceManagerId)
        )
    );
}
pub type ENLISTMENT_BASIC_INFORMATION = _ENLISTMENT_BASIC_INFORMATION;
pub type PENLISTMENT_BASIC_INFORMATION = *mut _ENLISTMENT_BASIC_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ENLISTMENT_CRM_INFORMATION {
    pub CrmTransactionManagerId: GUID,
    pub CrmResourceManagerId: GUID,
    pub CrmEnlistmentId: GUID,
}
#[test]
fn bindgen_test_layout__ENLISTMENT_CRM_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_ENLISTMENT_CRM_INFORMATION>(),
        48usize,
        concat!("Size of: ", stringify!(_ENLISTMENT_CRM_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_ENLISTMENT_CRM_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_ENLISTMENT_CRM_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENLISTMENT_CRM_INFORMATION>())).CrmTransactionManagerId
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_CRM_INFORMATION),
            "::",
            stringify!(CrmTransactionManagerId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENLISTMENT_CRM_INFORMATION>())).CrmResourceManagerId as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_CRM_INFORMATION),
            "::",
            stringify!(CrmResourceManagerId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_ENLISTMENT_CRM_INFORMATION>())).CrmEnlistmentId as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_ENLISTMENT_CRM_INFORMATION),
            "::",
            stringify!(CrmEnlistmentId)
        )
    );
}
pub type ENLISTMENT_CRM_INFORMATION = _ENLISTMENT_CRM_INFORMATION;
pub type PENLISTMENT_CRM_INFORMATION = *mut _ENLISTMENT_CRM_INFORMATION;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentBasicInformation: _ENLISTMENT_INFORMATION_CLASS =
    0;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentRecoveryInformation:
    _ENLISTMENT_INFORMATION_CLASS = 1;
pub const _ENLISTMENT_INFORMATION_CLASS_EnlistmentCrmInformation: _ENLISTMENT_INFORMATION_CLASS = 2;
pub type _ENLISTMENT_INFORMATION_CLASS = i32;
pub use self::_ENLISTMENT_INFORMATION_CLASS as ENLISTMENT_INFORMATION_CLASS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_ENTRY {
    pub UOW: UOW,
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_ENTRY() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_LIST_ENTRY>(),
        16usize,
        concat!("Size of: ", stringify!(_TRANSACTION_LIST_ENTRY))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_LIST_ENTRY>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_LIST_ENTRY))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TRANSACTION_LIST_ENTRY>())).UOW as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_LIST_ENTRY),
            "::",
            stringify!(UOW)
        )
    );
}
pub type TRANSACTION_LIST_ENTRY = _TRANSACTION_LIST_ENTRY;
pub type PTRANSACTION_LIST_ENTRY = *mut _TRANSACTION_LIST_ENTRY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TRANSACTION_LIST_INFORMATION {
    pub NumberOfTransactions: DWORD,
    pub TransactionInformation: [TRANSACTION_LIST_ENTRY; 1usize],
}
#[test]
fn bindgen_test_layout__TRANSACTION_LIST_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TRANSACTION_LIST_INFORMATION>(),
        20usize,
        concat!("Size of: ", stringify!(_TRANSACTION_LIST_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TRANSACTION_LIST_INFORMATION>(),
        4usize,
        concat!("Alignment of ", stringify!(_TRANSACTION_LIST_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_LIST_INFORMATION>())).NumberOfTransactions
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_LIST_INFORMATION),
            "::",
            stringify!(NumberOfTransactions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TRANSACTION_LIST_INFORMATION>())).TransactionInformation
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_TRANSACTION_LIST_INFORMATION),
            "::",
            stringify!(TransactionInformation)
        )
    );
}
pub type TRANSACTION_LIST_INFORMATION = _TRANSACTION_LIST_INFORMATION;
pub type PTRANSACTION_LIST_INFORMATION = *mut _TRANSACTION_LIST_INFORMATION;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION: _KTMOBJECT_TYPE = 0;
pub const _KTMOBJECT_TYPE_KTMOBJECT_TRANSACTION_MANAGER: _KTMOBJECT_TYPE = 1;
pub const _KTMOBJECT_TYPE_KTMOBJECT_RESOURCE_MANAGER: _KTMOBJECT_TYPE = 2;
pub const _KTMOBJECT_TYPE_KTMOBJECT_ENLISTMENT: _KTMOBJECT_TYPE = 3;
pub const _KTMOBJECT_TYPE_KTMOBJECT_INVALID: _KTMOBJECT_TYPE = 4;
pub type _KTMOBJECT_TYPE = i32;
pub use self::_KTMOBJECT_TYPE as KTMOBJECT_TYPE;
pub type PKTMOBJECT_TYPE = *mut _KTMOBJECT_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _KTMOBJECT_CURSOR {
    pub LastQuery: GUID,
    pub ObjectIdCount: DWORD,
    pub ObjectIds: [GUID; 1usize],
}
#[test]
fn bindgen_test_layout__KTMOBJECT_CURSOR() {
    assert_eq!(
        ::std::mem::size_of::<_KTMOBJECT_CURSOR>(),
        36usize,
        concat!("Size of: ", stringify!(_KTMOBJECT_CURSOR))
    );
    assert_eq!(
        ::std::mem::align_of::<_KTMOBJECT_CURSOR>(),
        4usize,
        concat!("Alignment of ", stringify!(_KTMOBJECT_CURSOR))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KTMOBJECT_CURSOR>())).LastQuery as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTMOBJECT_CURSOR),
            "::",
            stringify!(LastQuery)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KTMOBJECT_CURSOR>())).ObjectIdCount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTMOBJECT_CURSOR),
            "::",
            stringify!(ObjectIdCount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_KTMOBJECT_CURSOR>())).ObjectIds as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_KTMOBJECT_CURSOR),
            "::",
            stringify!(ObjectIds)
        )
    );
}
pub type KTMOBJECT_CURSOR = _KTMOBJECT_CURSOR;
pub type PKTMOBJECT_CURSOR = *mut _KTMOBJECT_CURSOR;
pub type TP_VERSION = DWORD;
pub type PTP_VERSION = *mut DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_INSTANCE {
    _unused: [u8; 0],
}
pub type TP_CALLBACK_INSTANCE = _TP_CALLBACK_INSTANCE;
pub type PTP_CALLBACK_INSTANCE = *mut _TP_CALLBACK_INSTANCE;
pub type PTP_SIMPLE_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL {
    _unused: [u8; 0],
}
pub type TP_POOL = _TP_POOL;
pub type PTP_POOL = *mut _TP_POOL;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_HIGH: _TP_CALLBACK_PRIORITY = 0;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_NORMAL: _TP_CALLBACK_PRIORITY = 1;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_LOW: _TP_CALLBACK_PRIORITY = 2;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_INVALID: _TP_CALLBACK_PRIORITY = 3;
pub const _TP_CALLBACK_PRIORITY_TP_CALLBACK_PRIORITY_COUNT: _TP_CALLBACK_PRIORITY = 3;
pub type _TP_CALLBACK_PRIORITY = i32;
pub use self::_TP_CALLBACK_PRIORITY as TP_CALLBACK_PRIORITY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_POOL_STACK_INFORMATION {
    pub StackReserve: SIZE_T,
    pub StackCommit: SIZE_T,
}
#[test]
fn bindgen_test_layout__TP_POOL_STACK_INFORMATION() {
    assert_eq!(
        ::std::mem::size_of::<_TP_POOL_STACK_INFORMATION>(),
        16usize,
        concat!("Size of: ", stringify!(_TP_POOL_STACK_INFORMATION))
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_POOL_STACK_INFORMATION>(),
        8usize,
        concat!("Alignment of ", stringify!(_TP_POOL_STACK_INFORMATION))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_POOL_STACK_INFORMATION>())).StackReserve as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_POOL_STACK_INFORMATION),
            "::",
            stringify!(StackReserve)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_POOL_STACK_INFORMATION>())).StackCommit as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_POOL_STACK_INFORMATION),
            "::",
            stringify!(StackCommit)
        )
    );
}
pub type TP_POOL_STACK_INFORMATION = _TP_POOL_STACK_INFORMATION;
pub type PTP_POOL_STACK_INFORMATION = *mut _TP_POOL_STACK_INFORMATION;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CLEANUP_GROUP {
    _unused: [u8; 0],
}
pub type TP_CLEANUP_GROUP = _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP = *mut _TP_CLEANUP_GROUP;
pub type PTP_CLEANUP_GROUP_CANCEL_CALLBACK =
    ::std::option::Option<unsafe extern "C" fn(ObjectContext: PVOID, CleanupContext: PVOID)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3 {
    pub Version: TP_VERSION,
    pub Pool: PTP_POOL,
    pub CleanupGroup: PTP_CLEANUP_GROUP,
    pub CleanupGroupCancelCallback: PTP_CLEANUP_GROUP_CANCEL_CALLBACK,
    pub RaceDll: PVOID,
    pub ActivationContext: *mut _ACTIVATION_CONTEXT,
    pub FinalizationCallback: PTP_SIMPLE_CALLBACK,
    pub u: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1,
    pub CallbackPriority: TP_CALLBACK_PRIORITY,
    pub Size: DWORD,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1 {
    pub Flags: DWORD,
    pub s: _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl _TP_CALLBACK_ENVIRON_V3__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn LongFunction(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_LongFunction(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Persistent(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_Persistent(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Private(&self) -> DWORD {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Private(&mut self, val: DWORD) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        LongFunction: DWORD,
        Persistent: DWORD,
        Private: DWORD,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let LongFunction: u32 = unsafe { ::std::mem::transmute(LongFunction) };
            LongFunction as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let Persistent: u32 = unsafe { ::std::mem::transmute(Persistent) };
            Persistent as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Private: u32 = unsafe { ::std::mem::transmute(Private) };
            Private as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>())).Flags as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1),
            "::",
            stringify!(Flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1>())).s as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3__bindgen_ty_1),
            "::",
            stringify!(s)
        )
    );
}
#[test]
fn bindgen_test_layout__TP_CALLBACK_ENVIRON_V3() {
    assert_eq!(
        ::std::mem::size_of::<_TP_CALLBACK_ENVIRON_V3>(),
        72usize,
        concat!("Size of: ", stringify!(_TP_CALLBACK_ENVIRON_V3))
    );
    assert_eq!(
        ::std::mem::align_of::<_TP_CALLBACK_ENVIRON_V3>(),
        8usize,
        concat!("Alignment of ", stringify!(_TP_CALLBACK_ENVIRON_V3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).Version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(Version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).Pool as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(Pool)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).CleanupGroup as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(CleanupGroup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).CleanupGroupCancelCallback
                as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(CleanupGroupCancelCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).RaceDll as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(RaceDll)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).ActivationContext as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(ActivationContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).FinalizationCallback as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(FinalizationCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).u as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).CallbackPriority as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(CallbackPriority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_TP_CALLBACK_ENVIRON_V3>())).Size as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_TP_CALLBACK_ENVIRON_V3),
            "::",
            stringify!(Size)
        )
    );
}
pub type TP_CALLBACK_ENVIRON_V3 = _TP_CALLBACK_ENVIRON_V3;
pub type TP_CALLBACK_ENVIRON = TP_CALLBACK_ENVIRON_V3;
pub type PTP_CALLBACK_ENVIRON = *mut TP_CALLBACK_ENVIRON_V3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WORK {
    _unused: [u8; 0],
}
pub type TP_WORK = _TP_WORK;
pub type PTP_WORK = *mut _TP_WORK;
pub type PTP_WORK_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Work: PTP_WORK),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_TIMER {
    _unused: [u8; 0],
}
pub type TP_TIMER = _TP_TIMER;
pub type PTP_TIMER = *mut _TP_TIMER;
pub type PTP_TIMER_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(Instance: PTP_CALLBACK_INSTANCE, Context: PVOID, Timer: PTP_TIMER),
>;
pub type TP_WAIT_RESULT = DWORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_WAIT {
    _unused: [u8; 0],
}
pub type TP_WAIT = _TP_WAIT;
pub type PTP_WAIT = *mut _TP_WAIT;
pub type PTP_WAIT_CALLBACK = ::std::option::Option<
    unsafe extern "C" fn(
        Instance: PTP_CALLBACK_INSTANCE,
        Context: PVOID,
        Wait: PTP_WAIT,
        WaitResult: TP_WAIT_RESULT,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TP_IO {
    _unused: [u8; 0],
}
pub type TP_IO = _TP_IO;
pub type PTP_IO = *mut _TP_IO;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _TEB {
    _unused: [u8; 0],
}
pub type WPARAM = UINT_PTR;
pub type LPARAM = LONG_PTR;
pub type LRESULT = LONG_PTR;
pub type SPHANDLE = *mut HANDLE;
pub type LPHANDLE = *mut HANDLE;
pub type HGLOBAL = HANDLE;
pub type HLOCAL = HANDLE;
pub type GLOBALHANDLE = HANDLE;
pub type LOCALHANDLE = HANDLE;
pub type FARPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type NEARPROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type PROC = ::std::option::Option<unsafe extern "C" fn() -> INT_PTR>;
pub type ATOM = WORD;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKEY__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HKEY__() {
    assert_eq!(
        ::std::mem::size_of::<HKEY__>(),
        4usize,
        concat!("Size of: ", stringify!(HKEY__))
    );
    assert_eq!(
        ::std::mem::align_of::<HKEY__>(),
        4usize,
        concat!("Alignment of ", stringify!(HKEY__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HKEY__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HKEY__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HKEY = *mut HKEY__;
pub type PHKEY = *mut HKEY;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HMETAFILE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HMETAFILE__() {
    assert_eq!(
        ::std::mem::size_of::<HMETAFILE__>(),
        4usize,
        concat!("Size of: ", stringify!(HMETAFILE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HMETAFILE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HMETAFILE__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HMETAFILE__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HMETAFILE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HMETAFILE = *mut HMETAFILE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HINSTANCE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HINSTANCE__() {
    assert_eq!(
        ::std::mem::size_of::<HINSTANCE__>(),
        4usize,
        concat!("Size of: ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HINSTANCE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HINSTANCE__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HINSTANCE__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HINSTANCE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HINSTANCE = *mut HINSTANCE__;
pub type HMODULE = HINSTANCE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRGN__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HRGN__() {
    assert_eq!(
        ::std::mem::size_of::<HRGN__>(),
        4usize,
        concat!("Size of: ", stringify!(HRGN__))
    );
    assert_eq!(
        ::std::mem::align_of::<HRGN__>(),
        4usize,
        concat!("Alignment of ", stringify!(HRGN__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HRGN__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HRGN__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HRGN = *mut HRGN__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HRSRC__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HRSRC__() {
    assert_eq!(
        ::std::mem::size_of::<HRSRC__>(),
        4usize,
        concat!("Size of: ", stringify!(HRSRC__))
    );
    assert_eq!(
        ::std::mem::align_of::<HRSRC__>(),
        4usize,
        concat!("Alignment of ", stringify!(HRSRC__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HRSRC__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HRSRC__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HRSRC = *mut HRSRC__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSPRITE__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HSPRITE__() {
    assert_eq!(
        ::std::mem::size_of::<HSPRITE__>(),
        4usize,
        concat!("Size of: ", stringify!(HSPRITE__))
    );
    assert_eq!(
        ::std::mem::align_of::<HSPRITE__>(),
        4usize,
        concat!("Alignment of ", stringify!(HSPRITE__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HSPRITE__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HSPRITE__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HSPRITE = *mut HSPRITE__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HLSURF__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HLSURF__() {
    assert_eq!(
        ::std::mem::size_of::<HLSURF__>(),
        4usize,
        concat!("Size of: ", stringify!(HLSURF__))
    );
    assert_eq!(
        ::std::mem::align_of::<HLSURF__>(),
        4usize,
        concat!("Alignment of ", stringify!(HLSURF__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HLSURF__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HLSURF__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HLSURF = *mut HLSURF__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HSTR__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HSTR__() {
    assert_eq!(
        ::std::mem::size_of::<HSTR__>(),
        4usize,
        concat!("Size of: ", stringify!(HSTR__))
    );
    assert_eq!(
        ::std::mem::align_of::<HSTR__>(),
        4usize,
        concat!("Alignment of ", stringify!(HSTR__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HSTR__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HSTR__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HSTR = *mut HSTR__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HTASK__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HTASK__() {
    assert_eq!(
        ::std::mem::size_of::<HTASK__>(),
        4usize,
        concat!("Size of: ", stringify!(HTASK__))
    );
    assert_eq!(
        ::std::mem::align_of::<HTASK__>(),
        4usize,
        concat!("Alignment of ", stringify!(HTASK__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HTASK__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HTASK__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HTASK = *mut HTASK__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HWINSTA__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HWINSTA__() {
    assert_eq!(
        ::std::mem::size_of::<HWINSTA__>(),
        4usize,
        concat!("Size of: ", stringify!(HWINSTA__))
    );
    assert_eq!(
        ::std::mem::align_of::<HWINSTA__>(),
        4usize,
        concat!("Alignment of ", stringify!(HWINSTA__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HWINSTA__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HWINSTA__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HWINSTA = *mut HWINSTA__;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HKL__ {
    pub unused: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_HKL__() {
    assert_eq!(
        ::std::mem::size_of::<HKL__>(),
        4usize,
        concat!("Size of: ", stringify!(HKL__))
    );
    assert_eq!(
        ::std::mem::align_of::<HKL__>(),
        4usize,
        concat!("Alignment of ", stringify!(HKL__))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HKL__>())).unused as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HKL__),
            "::",
            stringify!(unused)
        )
    );
}
pub type HKL = *mut HKL__;
pub type HFILE = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _FILETIME {
    pub dwLowDateTime: DWORD,
    pub dwHighDateTime: DWORD,
}
#[test]
fn bindgen_test_layout__FILETIME() {
    assert_eq!(
        ::std::mem::size_of::<_FILETIME>(),
        8usize,
        concat!("Size of: ", stringify!(_FILETIME))
    );
    assert_eq!(
        ::std::mem::align_of::<_FILETIME>(),
        4usize,
        concat!("Alignment of ", stringify!(_FILETIME))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FILETIME>())).dwLowDateTime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwLowDateTime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_FILETIME>())).dwHighDateTime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_FILETIME),
            "::",
            stringify!(dwHighDateTime)
        )
    );
}
pub type FILETIME = _FILETIME;
pub type PFILETIME = *mut _FILETIME;
pub type LPFILETIME = *mut _FILETIME;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeHypervisorPresent: WHV_CAPABILITY_CODE = 0;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeFeatures: WHV_CAPABILITY_CODE = 1;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeExtendedVmExits: WHV_CAPABILITY_CODE = 2;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeExceptionExitBitmap: WHV_CAPABILITY_CODE = 3;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorVendor: WHV_CAPABILITY_CODE = 4096;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorFeatures: WHV_CAPABILITY_CODE = 4097;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorClFlushSize: WHV_CAPABILITY_CODE = 4098;
pub const WHV_CAPABILITY_CODE_WHvCapabilityCodeProcessorXsaveFeatures: WHV_CAPABILITY_CODE = 4099;
pub type WHV_CAPABILITY_CODE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_CAPABILITY_FEATURES {
    pub __bindgen_anon_1: WHV_CAPABILITY_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_CAPABILITY_FEATURES__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_CAPABILITY_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_CAPABILITY_FEATURES__bindgen_ty_1)
        )
    );
}
impl WHV_CAPABILITY_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn PartialUnmap(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PartialUnmap(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LocalApicEmulation(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LocalApicEmulation(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Xsave(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Xsave(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DirtyPageTracking(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DirtyPageTracking(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SpeculationControl(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SpeculationControl(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 59u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 59u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        PartialUnmap: UINT64,
        LocalApicEmulation: UINT64,
        Xsave: UINT64,
        DirtyPageTracking: UINT64,
        SpeculationControl: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let PartialUnmap: u64 = unsafe { ::std::mem::transmute(PartialUnmap) };
            PartialUnmap as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LocalApicEmulation: u64 = unsafe { ::std::mem::transmute(LocalApicEmulation) };
            LocalApicEmulation as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Xsave: u64 = unsafe { ::std::mem::transmute(Xsave) };
            Xsave as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let DirtyPageTracking: u64 = unsafe { ::std::mem::transmute(DirtyPageTracking) };
            DirtyPageTracking as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let SpeculationControl: u64 = unsafe { ::std::mem::transmute(SpeculationControl) };
            SpeculationControl as u64
        });
        __bindgen_bitfield_unit.set(5usize, 59u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_CAPABILITY_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_CAPABILITY_FEATURES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY_FEATURES>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_EXTENDED_VM_EXITS {
    pub __bindgen_anon_1: WHV_EXTENDED_VM_EXITS__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_EXTENDED_VM_EXITS__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_EXTENDED_VM_EXITS__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EXTENDED_VM_EXITS__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_EXTENDED_VM_EXITS__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EXTENDED_VM_EXITS__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_EXTENDED_VM_EXITS__bindgen_ty_1)
        )
    );
}
impl WHV_EXTENDED_VM_EXITS__bindgen_ty_1 {
    #[inline]
    pub fn X64CpuidExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64CpuidExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X64MsrExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X64MsrExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExceptionExit(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExceptionExit(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 61u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 61u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        X64CpuidExit: UINT64,
        X64MsrExit: UINT64,
        ExceptionExit: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let X64CpuidExit: u64 = unsafe { ::std::mem::transmute(X64CpuidExit) };
            X64CpuidExit as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let X64MsrExit: u64 = unsafe { ::std::mem::transmute(X64MsrExit) };
            X64MsrExit as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let ExceptionExit: u64 = unsafe { ::std::mem::transmute(ExceptionExit) };
            ExceptionExit as u64
        });
        __bindgen_bitfield_unit.set(3usize, 61u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_EXTENDED_VM_EXITS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_EXTENDED_VM_EXITS>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_EXTENDED_VM_EXITS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_EXTENDED_VM_EXITS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_EXTENDED_VM_EXITS))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_EXTENDED_VM_EXITS>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_EXTENDED_VM_EXITS),
            "::",
            stringify!(AsUINT64)
        )
    );
}
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorAmd: WHV_PROCESSOR_VENDOR = 0;
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorIntel: WHV_PROCESSOR_VENDOR = 1;
pub const WHV_PROCESSOR_VENDOR_WHvProcessorVendorHygon: WHV_PROCESSOR_VENDOR = 2;
pub type WHV_PROCESSOR_VENDOR = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PROCESSOR_FEATURES {
    pub __bindgen_anon_1: WHV_PROCESSOR_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_FEATURES__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u8>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_PROCESSOR_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_FEATURES__bindgen_ty_1)
        )
    );
}
impl WHV_PROCESSOR_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn Sse3Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse3Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LahfSahfSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LahfSahfSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Ssse3Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Ssse3Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4_1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4_1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4_2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4_2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Sse4aSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sse4aSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XopSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XopSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PopCntSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PopCntSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Cmpxchg16bSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Cmpxchg16bSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Altmovcr8Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Altmovcr8Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn LzcntSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_LzcntSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MisAlignSseSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MisAlignSseSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MmxExtSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MmxExtSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Amd3DNowSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Amd3DNowSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ExtendedAmd3DNowSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ExtendedAmd3DNowSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Page1GbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Page1GbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AesSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AesSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PclmulqdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PclmulqdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn PcidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_PcidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Fma4Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Fma4Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn F16CSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_F16CSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdRandSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdRandSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdWrFsGsSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdWrFsGsSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmepSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SmepSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EnhancedFastStringSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(24usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EnhancedFastStringSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(24usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bmi1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(25usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bmi1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(25usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Bmi2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(26usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Bmi2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(26usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(27usize, 2u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(27usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn MovbeSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(29usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MovbeSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(29usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Npiep1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(30usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Npiep1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(30usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DepX87FPUSaveSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(31usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_DepX87FPUSaveSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(31usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdSeedSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(32usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdSeedSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(32usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AdxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(33usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AdxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(33usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IntelPrefetchSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(34usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IntelPrefetchSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(34usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SmapSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(35usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SmapSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(35usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn HleSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(36usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_HleSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(36usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RtmSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(37usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RtmSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(37usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdtscpSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(38usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdtscpSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(38usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClflushoptSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(39usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClflushoptSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(39usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ClwbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(40usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ClwbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(40usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn ShaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(41usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_ShaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(41usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn X87PointersSavedSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(42usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_X87PointersSavedSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(42usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InvpcidSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(43usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InvpcidSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(43usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbrsSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(44usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbrsSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(44usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn StibpSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(45usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_StibpSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(45usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbpbSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(46usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbpbSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(46usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved2(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(47usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved2(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(47usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SsbdSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(48usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SsbdSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(48usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FastShortRepMovSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(49usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FastShortRepMovSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(49usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved3(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(50usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved3(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(50usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RdclNo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(51usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RdclNo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(51usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn IbrsAllSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(52usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_IbrsAllSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(52usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved4(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(53usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved4(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(53usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SsbNo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(54usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_SsbNo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(54usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RsbANo(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(55usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_RsbANo(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(55usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved5(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(56usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved5(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(56usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Sse3Support: UINT64,
        LahfSahfSupport: UINT64,
        Ssse3Support: UINT64,
        Sse4_1Support: UINT64,
        Sse4_2Support: UINT64,
        Sse4aSupport: UINT64,
        XopSupport: UINT64,
        PopCntSupport: UINT64,
        Cmpxchg16bSupport: UINT64,
        Altmovcr8Support: UINT64,
        LzcntSupport: UINT64,
        MisAlignSseSupport: UINT64,
        MmxExtSupport: UINT64,
        Amd3DNowSupport: UINT64,
        ExtendedAmd3DNowSupport: UINT64,
        Page1GbSupport: UINT64,
        AesSupport: UINT64,
        PclmulqdqSupport: UINT64,
        PcidSupport: UINT64,
        Fma4Support: UINT64,
        F16CSupport: UINT64,
        RdRandSupport: UINT64,
        RdWrFsGsSupport: UINT64,
        SmepSupport: UINT64,
        EnhancedFastStringSupport: UINT64,
        Bmi1Support: UINT64,
        Bmi2Support: UINT64,
        Reserved1: UINT64,
        MovbeSupport: UINT64,
        Npiep1Support: UINT64,
        DepX87FPUSaveSupport: UINT64,
        RdSeedSupport: UINT64,
        AdxSupport: UINT64,
        IntelPrefetchSupport: UINT64,
        SmapSupport: UINT64,
        HleSupport: UINT64,
        RtmSupport: UINT64,
        RdtscpSupport: UINT64,
        ClflushoptSupport: UINT64,
        ClwbSupport: UINT64,
        ShaSupport: UINT64,
        X87PointersSavedSupport: UINT64,
        InvpcidSupport: UINT64,
        IbrsSupport: UINT64,
        StibpSupport: UINT64,
        IbpbSupport: UINT64,
        Reserved2: UINT64,
        SsbdSupport: UINT64,
        FastShortRepMovSupport: UINT64,
        Reserved3: UINT64,
        RdclNo: UINT64,
        IbrsAllSupport: UINT64,
        Reserved4: UINT64,
        SsbNo: UINT64,
        RsbANo: UINT64,
        Reserved5: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let Sse3Support: u64 = unsafe { ::std::mem::transmute(Sse3Support) };
            Sse3Support as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let LahfSahfSupport: u64 = unsafe { ::std::mem::transmute(LahfSahfSupport) };
            LahfSahfSupport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Ssse3Support: u64 = unsafe { ::std::mem::transmute(Ssse3Support) };
            Ssse3Support as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Sse4_1Support: u64 = unsafe { ::std::mem::transmute(Sse4_1Support) };
            Sse4_1Support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let Sse4_2Support: u64 = unsafe { ::std::mem::transmute(Sse4_2Support) };
            Sse4_2Support as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let Sse4aSupport: u64 = unsafe { ::std::mem::transmute(Sse4aSupport) };
            Sse4aSupport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let XopSupport: u64 = unsafe { ::std::mem::transmute(XopSupport) };
            XopSupport as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let PopCntSupport: u64 = unsafe { ::std::mem::transmute(PopCntSupport) };
            PopCntSupport as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Cmpxchg16bSupport: u64 = unsafe { ::std::mem::transmute(Cmpxchg16bSupport) };
            Cmpxchg16bSupport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Altmovcr8Support: u64 = unsafe { ::std::mem::transmute(Altmovcr8Support) };
            Altmovcr8Support as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let LzcntSupport: u64 = unsafe { ::std::mem::transmute(LzcntSupport) };
            LzcntSupport as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let MisAlignSseSupport: u64 = unsafe { ::std::mem::transmute(MisAlignSseSupport) };
            MisAlignSseSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let MmxExtSupport: u64 = unsafe { ::std::mem::transmute(MmxExtSupport) };
            MmxExtSupport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Amd3DNowSupport: u64 = unsafe { ::std::mem::transmute(Amd3DNowSupport) };
            Amd3DNowSupport as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let ExtendedAmd3DNowSupport: u64 =
                unsafe { ::std::mem::transmute(ExtendedAmd3DNowSupport) };
            ExtendedAmd3DNowSupport as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Page1GbSupport: u64 = unsafe { ::std::mem::transmute(Page1GbSupport) };
            Page1GbSupport as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let AesSupport: u64 = unsafe { ::std::mem::transmute(AesSupport) };
            AesSupport as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let PclmulqdqSupport: u64 = unsafe { ::std::mem::transmute(PclmulqdqSupport) };
            PclmulqdqSupport as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let PcidSupport: u64 = unsafe { ::std::mem::transmute(PcidSupport) };
            PcidSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let Fma4Support: u64 = unsafe { ::std::mem::transmute(Fma4Support) };
            Fma4Support as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let F16CSupport: u64 = unsafe { ::std::mem::transmute(F16CSupport) };
            F16CSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let RdRandSupport: u64 = unsafe { ::std::mem::transmute(RdRandSupport) };
            RdRandSupport as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let RdWrFsGsSupport: u64 = unsafe { ::std::mem::transmute(RdWrFsGsSupport) };
            RdWrFsGsSupport as u64
        });
        __bindgen_bitfield_unit.set(23usize, 1u8, {
            let SmepSupport: u64 = unsafe { ::std::mem::transmute(SmepSupport) };
            SmepSupport as u64
        });
        __bindgen_bitfield_unit.set(24usize, 1u8, {
            let EnhancedFastStringSupport: u64 =
                unsafe { ::std::mem::transmute(EnhancedFastStringSupport) };
            EnhancedFastStringSupport as u64
        });
        __bindgen_bitfield_unit.set(25usize, 1u8, {
            let Bmi1Support: u64 = unsafe { ::std::mem::transmute(Bmi1Support) };
            Bmi1Support as u64
        });
        __bindgen_bitfield_unit.set(26usize, 1u8, {
            let Bmi2Support: u64 = unsafe { ::std::mem::transmute(Bmi2Support) };
            Bmi2Support as u64
        });
        __bindgen_bitfield_unit.set(27usize, 2u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(29usize, 1u8, {
            let MovbeSupport: u64 = unsafe { ::std::mem::transmute(MovbeSupport) };
            MovbeSupport as u64
        });
        __bindgen_bitfield_unit.set(30usize, 1u8, {
            let Npiep1Support: u64 = unsafe { ::std::mem::transmute(Npiep1Support) };
            Npiep1Support as u64
        });
        __bindgen_bitfield_unit.set(31usize, 1u8, {
            let DepX87FPUSaveSupport: u64 = unsafe { ::std::mem::transmute(DepX87FPUSaveSupport) };
            DepX87FPUSaveSupport as u64
        });
        __bindgen_bitfield_unit.set(32usize, 1u8, {
            let RdSeedSupport: u64 = unsafe { ::std::mem::transmute(RdSeedSupport) };
            RdSeedSupport as u64
        });
        __bindgen_bitfield_unit.set(33usize, 1u8, {
            let AdxSupport: u64 = unsafe { ::std::mem::transmute(AdxSupport) };
            AdxSupport as u64
        });
        __bindgen_bitfield_unit.set(34usize, 1u8, {
            let IntelPrefetchSupport: u64 = unsafe { ::std::mem::transmute(IntelPrefetchSupport) };
            IntelPrefetchSupport as u64
        });
        __bindgen_bitfield_unit.set(35usize, 1u8, {
            let SmapSupport: u64 = unsafe { ::std::mem::transmute(SmapSupport) };
            SmapSupport as u64
        });
        __bindgen_bitfield_unit.set(36usize, 1u8, {
            let HleSupport: u64 = unsafe { ::std::mem::transmute(HleSupport) };
            HleSupport as u64
        });
        __bindgen_bitfield_unit.set(37usize, 1u8, {
            let RtmSupport: u64 = unsafe { ::std::mem::transmute(RtmSupport) };
            RtmSupport as u64
        });
        __bindgen_bitfield_unit.set(38usize, 1u8, {
            let RdtscpSupport: u64 = unsafe { ::std::mem::transmute(RdtscpSupport) };
            RdtscpSupport as u64
        });
        __bindgen_bitfield_unit.set(39usize, 1u8, {
            let ClflushoptSupport: u64 = unsafe { ::std::mem::transmute(ClflushoptSupport) };
            ClflushoptSupport as u64
        });
        __bindgen_bitfield_unit.set(40usize, 1u8, {
            let ClwbSupport: u64 = unsafe { ::std::mem::transmute(ClwbSupport) };
            ClwbSupport as u64
        });
        __bindgen_bitfield_unit.set(41usize, 1u8, {
            let ShaSupport: u64 = unsafe { ::std::mem::transmute(ShaSupport) };
            ShaSupport as u64
        });
        __bindgen_bitfield_unit.set(42usize, 1u8, {
            let X87PointersSavedSupport: u64 =
                unsafe { ::std::mem::transmute(X87PointersSavedSupport) };
            X87PointersSavedSupport as u64
        });
        __bindgen_bitfield_unit.set(43usize, 1u8, {
            let InvpcidSupport: u64 = unsafe { ::std::mem::transmute(InvpcidSupport) };
            InvpcidSupport as u64
        });
        __bindgen_bitfield_unit.set(44usize, 1u8, {
            let IbrsSupport: u64 = unsafe { ::std::mem::transmute(IbrsSupport) };
            IbrsSupport as u64
        });
        __bindgen_bitfield_unit.set(45usize, 1u8, {
            let StibpSupport: u64 = unsafe { ::std::mem::transmute(StibpSupport) };
            StibpSupport as u64
        });
        __bindgen_bitfield_unit.set(46usize, 1u8, {
            let IbpbSupport: u64 = unsafe { ::std::mem::transmute(IbpbSupport) };
            IbpbSupport as u64
        });
        __bindgen_bitfield_unit.set(47usize, 1u8, {
            let Reserved2: u64 = unsafe { ::std::mem::transmute(Reserved2) };
            Reserved2 as u64
        });
        __bindgen_bitfield_unit.set(48usize, 1u8, {
            let SsbdSupport: u64 = unsafe { ::std::mem::transmute(SsbdSupport) };
            SsbdSupport as u64
        });
        __bindgen_bitfield_unit.set(49usize, 1u8, {
            let FastShortRepMovSupport: u64 =
                unsafe { ::std::mem::transmute(FastShortRepMovSupport) };
            FastShortRepMovSupport as u64
        });
        __bindgen_bitfield_unit.set(50usize, 1u8, {
            let Reserved3: u64 = unsafe { ::std::mem::transmute(Reserved3) };
            Reserved3 as u64
        });
        __bindgen_bitfield_unit.set(51usize, 1u8, {
            let RdclNo: u64 = unsafe { ::std::mem::transmute(RdclNo) };
            RdclNo as u64
        });
        __bindgen_bitfield_unit.set(52usize, 1u8, {
            let IbrsAllSupport: u64 = unsafe { ::std::mem::transmute(IbrsAllSupport) };
            IbrsAllSupport as u64
        });
        __bindgen_bitfield_unit.set(53usize, 1u8, {
            let Reserved4: u64 = unsafe { ::std::mem::transmute(Reserved4) };
            Reserved4 as u64
        });
        __bindgen_bitfield_unit.set(54usize, 1u8, {
            let SsbNo: u64 = unsafe { ::std::mem::transmute(SsbNo) };
            SsbNo as u64
        });
        __bindgen_bitfield_unit.set(55usize, 1u8, {
            let RsbANo: u64 = unsafe { ::std::mem::transmute(RsbANo) };
            RsbANo as u64
        });
        __bindgen_bitfield_unit.set(56usize, 8u8, {
            let Reserved5: u64 = unsafe { ::std::mem::transmute(Reserved5) };
            Reserved5 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_FEATURES))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_PROCESSOR_FEATURES>())).AsUINT64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _WHV_PROCESSOR_XSAVE_FEATURES {
    pub __bindgen_anon_1: _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout__WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1)
        )
    );
}
impl _WHV_PROCESSOR_XSAVE_FEATURES__bindgen_ty_1 {
    #[inline]
    pub fn XsaveSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveoptSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveoptSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AvxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_AvxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn FmaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_FmaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn MpxSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_MpxSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512DQSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512DQSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512CDSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512CDSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512BWSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512BWSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VLSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VLSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveCompSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveCompSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn XsaveSupervisorSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_XsaveSupervisorSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Xcr1Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Xcr1Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512BitalgSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512BitalgSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512IfmaSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512IfmaSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VBmiSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VBmiSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VBmi2Support(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VBmi2Support(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VnniSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VnniSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GfniSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_GfniSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VaesSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(20usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_VaesSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(20usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Avx512VPopcntdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(21usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Avx512VPopcntdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(21usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn VpclmulqdqSupport(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(22usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_VpclmulqdqSupport(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(22usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(23usize, 41u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(23usize, 41u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        XsaveSupport: UINT64,
        XsaveoptSupport: UINT64,
        AvxSupport: UINT64,
        Avx2Support: UINT64,
        FmaSupport: UINT64,
        MpxSupport: UINT64,
        Avx512Support: UINT64,
        Avx512DQSupport: UINT64,
        Avx512CDSupport: UINT64,
        Avx512BWSupport: UINT64,
        Avx512VLSupport: UINT64,
        XsaveCompSupport: UINT64,
        XsaveSupervisorSupport: UINT64,
        Xcr1Support: UINT64,
        Avx512BitalgSupport: UINT64,
        Avx512IfmaSupport: UINT64,
        Avx512VBmiSupport: UINT64,
        Avx512VBmi2Support: UINT64,
        Avx512VnniSupport: UINT64,
        GfniSupport: UINT64,
        VaesSupport: UINT64,
        Avx512VPopcntdqSupport: UINT64,
        VpclmulqdqSupport: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let XsaveSupport: u64 = unsafe { ::std::mem::transmute(XsaveSupport) };
            XsaveSupport as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let XsaveoptSupport: u64 = unsafe { ::std::mem::transmute(XsaveoptSupport) };
            XsaveoptSupport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let AvxSupport: u64 = unsafe { ::std::mem::transmute(AvxSupport) };
            AvxSupport as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Avx2Support: u64 = unsafe { ::std::mem::transmute(Avx2Support) };
            Avx2Support as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let FmaSupport: u64 = unsafe { ::std::mem::transmute(FmaSupport) };
            FmaSupport as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let MpxSupport: u64 = unsafe { ::std::mem::transmute(MpxSupport) };
            MpxSupport as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let Avx512Support: u64 = unsafe { ::std::mem::transmute(Avx512Support) };
            Avx512Support as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Avx512DQSupport: u64 = unsafe { ::std::mem::transmute(Avx512DQSupport) };
            Avx512DQSupport as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let Avx512CDSupport: u64 = unsafe { ::std::mem::transmute(Avx512CDSupport) };
            Avx512CDSupport as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let Avx512BWSupport: u64 = unsafe { ::std::mem::transmute(Avx512BWSupport) };
            Avx512BWSupport as u64
        });
        __bindgen_bitfield_unit.set(10usize, 1u8, {
            let Avx512VLSupport: u64 = unsafe { ::std::mem::transmute(Avx512VLSupport) };
            Avx512VLSupport as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let XsaveCompSupport: u64 = unsafe { ::std::mem::transmute(XsaveCompSupport) };
            XsaveCompSupport as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let XsaveSupervisorSupport: u64 =
                unsafe { ::std::mem::transmute(XsaveSupervisorSupport) };
            XsaveSupervisorSupport as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Xcr1Support: u64 = unsafe { ::std::mem::transmute(Xcr1Support) };
            Xcr1Support as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Avx512BitalgSupport: u64 = unsafe { ::std::mem::transmute(Avx512BitalgSupport) };
            Avx512BitalgSupport as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Avx512IfmaSupport: u64 = unsafe { ::std::mem::transmute(Avx512IfmaSupport) };
            Avx512IfmaSupport as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let Avx512VBmiSupport: u64 = unsafe { ::std::mem::transmute(Avx512VBmiSupport) };
            Avx512VBmiSupport as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let Avx512VBmi2Support: u64 = unsafe { ::std::mem::transmute(Avx512VBmi2Support) };
            Avx512VBmi2Support as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let Avx512VnniSupport: u64 = unsafe { ::std::mem::transmute(Avx512VnniSupport) };
            Avx512VnniSupport as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let GfniSupport: u64 = unsafe { ::std::mem::transmute(GfniSupport) };
            GfniSupport as u64
        });
        __bindgen_bitfield_unit.set(20usize, 1u8, {
            let VaesSupport: u64 = unsafe { ::std::mem::transmute(VaesSupport) };
            VaesSupport as u64
        });
        __bindgen_bitfield_unit.set(21usize, 1u8, {
            let Avx512VPopcntdqSupport: u64 =
                unsafe { ::std::mem::transmute(Avx512VPopcntdqSupport) };
            Avx512VPopcntdqSupport as u64
        });
        __bindgen_bitfield_unit.set(22usize, 1u8, {
            let VpclmulqdqSupport: u64 = unsafe { ::std::mem::transmute(VpclmulqdqSupport) };
            VpclmulqdqSupport as u64
        });
        __bindgen_bitfield_unit.set(23usize, 41u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout__WHV_PROCESSOR_XSAVE_FEATURES() {
    assert_eq!(
        ::std::mem::size_of::<_WHV_PROCESSOR_XSAVE_FEATURES>(),
        8usize,
        concat!("Size of: ", stringify!(_WHV_PROCESSOR_XSAVE_FEATURES))
    );
    assert_eq!(
        ::std::mem::align_of::<_WHV_PROCESSOR_XSAVE_FEATURES>(),
        8usize,
        concat!("Alignment of ", stringify!(_WHV_PROCESSOR_XSAVE_FEATURES))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_WHV_PROCESSOR_XSAVE_FEATURES>())).AsUINT64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_WHV_PROCESSOR_XSAVE_FEATURES),
            "::",
            stringify!(AsUINT64)
        )
    );
}
pub type WHV_PROCESSOR_XSAVE_FEATURES = _WHV_PROCESSOR_XSAVE_FEATURES;
pub type PWHV_PROCESSOR_XSAVE_FEATURES = *mut _WHV_PROCESSOR_XSAVE_FEATURES;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_CAPABILITY {
    pub HypervisorPresent: BOOL,
    pub Features: WHV_CAPABILITY_FEATURES,
    pub ExtendedVmExits: WHV_EXTENDED_VM_EXITS,
    pub ProcessorVendor: WHV_PROCESSOR_VENDOR,
    pub ProcessorFeatures: WHV_PROCESSOR_FEATURES,
    pub ProcessorXsaveFeatures: WHV_PROCESSOR_XSAVE_FEATURES,
    pub ProcessorClFlushSize: UINT8,
    pub ExceptionExitBitmap: UINT64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_WHV_CAPABILITY() {
    assert_eq!(
        ::std::mem::size_of::<WHV_CAPABILITY>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_CAPABILITY))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_CAPABILITY>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_CAPABILITY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).HypervisorPresent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(HypervisorPresent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).Features as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(Features)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).ExtendedVmExits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ExtendedVmExits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorVendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorVendor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorXsaveFeatures as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorXsaveFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ProcessorClFlushSize as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ProcessorClFlushSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_CAPABILITY>())).ExceptionExitBitmap as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_CAPABILITY),
            "::",
            stringify!(ExceptionExitBitmap)
        )
    );
}
pub type WHV_PARTITION_HANDLE = *mut ::std::os::raw::c_void;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeExtendedVmExits:
    WHV_PARTITION_PROPERTY_CODE = 1;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeExceptionExitBitmap:
    WHV_PARTITION_PROPERTY_CODE = 2;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeSeparateSecurityDomain:
    WHV_PARTITION_PROPERTY_CODE = 3;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorFeatures:
    WHV_PARTITION_PROPERTY_CODE = 4097;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorClFlushSize:
    WHV_PARTITION_PROPERTY_CODE = 4098;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeCpuidExitList:
    WHV_PARTITION_PROPERTY_CODE = 4099;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeCpuidResultList:
    WHV_PARTITION_PROPERTY_CODE = 4100;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeLocalApicEmulationMode:
    WHV_PARTITION_PROPERTY_CODE = 4101;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorXsaveFeatures:
    WHV_PARTITION_PROPERTY_CODE = 4102;
pub const WHV_PARTITION_PROPERTY_CODE_WHvPartitionPropertyCodeProcessorCount:
    WHV_PARTITION_PROPERTY_CODE = 8191;
pub type WHV_PARTITION_PROPERTY_CODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_CPUID_RESULT {
    pub Function: UINT32,
    pub Reserved: [UINT32; 3usize],
    pub Eax: UINT32,
    pub Ebx: UINT32,
    pub Ecx: UINT32,
    pub Edx: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_CPUID_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_CPUID_RESULT>(),
        32usize,
        concat!("Size of: ", stringify!(WHV_X64_CPUID_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_CPUID_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_CPUID_RESULT))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Function as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Eax as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Eax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Ebx as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Ebx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Ecx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Ecx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_CPUID_RESULT>())).Edx as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_RESULT),
            "::",
            stringify!(Edx)
        )
    );
}
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDivideErrorFault: WHV_EXCEPTION_TYPE = 0;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDebugTrapOrFault: WHV_EXCEPTION_TYPE = 1;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeBreakpointTrap: WHV_EXCEPTION_TYPE = 3;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeOverflowTrap: WHV_EXCEPTION_TYPE = 4;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeBoundRangeFault: WHV_EXCEPTION_TYPE = 5;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeInvalidOpcodeFault: WHV_EXCEPTION_TYPE = 6;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDeviceNotAvailableFault: WHV_EXCEPTION_TYPE = 7;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeDoubleFaultAbort: WHV_EXCEPTION_TYPE = 8;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeInvalidTaskStateSegmentFault: WHV_EXCEPTION_TYPE =
    10;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeSegmentNotPresentFault: WHV_EXCEPTION_TYPE = 11;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeStackFault: WHV_EXCEPTION_TYPE = 12;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeGeneralProtectionFault: WHV_EXCEPTION_TYPE = 13;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypePageFault: WHV_EXCEPTION_TYPE = 14;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeFloatingPointErrorFault: WHV_EXCEPTION_TYPE = 16;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeAlignmentCheckFault: WHV_EXCEPTION_TYPE = 17;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeMachineCheckAbort: WHV_EXCEPTION_TYPE = 18;
pub const WHV_EXCEPTION_TYPE_WHvX64ExceptionTypeSimdFloatingPointFault: WHV_EXCEPTION_TYPE = 19;
pub type WHV_EXCEPTION_TYPE = i32;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeNone:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 0;
pub const WHV_X64_LOCAL_APIC_EMULATION_MODE_WHvX64LocalApicEmulationModeXApic:
    WHV_X64_LOCAL_APIC_EMULATION_MODE = 1;
pub type WHV_X64_LOCAL_APIC_EMULATION_MODE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_PARTITION_PROPERTY {
    pub ExtendedVmExits: WHV_EXTENDED_VM_EXITS,
    pub ProcessorFeatures: WHV_PROCESSOR_FEATURES,
    pub ProcessorXsaveFeatures: WHV_PROCESSOR_XSAVE_FEATURES,
    pub ProcessorClFlushSize: UINT8,
    pub ProcessorCount: UINT32,
    pub CpuidExitList: [UINT32; 1usize],
    pub CpuidResultList: [WHV_X64_CPUID_RESULT; 1usize],
    pub ExceptionExitBitmap: UINT64,
    pub LocalApicEmulationMode: WHV_X64_LOCAL_APIC_EMULATION_MODE,
    pub SeparateSecurityDomain: BOOL,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_WHV_PARTITION_PROPERTY() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PARTITION_PROPERTY>(),
        32usize,
        concat!("Size of: ", stringify!(WHV_PARTITION_PROPERTY))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PARTITION_PROPERTY>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PARTITION_PROPERTY))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ExtendedVmExits as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ExtendedVmExits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorFeatures as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorXsaveFeatures as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorXsaveFeatures)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorClFlushSize as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorClFlushSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ProcessorCount as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ProcessorCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).CpuidExitList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(CpuidExitList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).CpuidResultList as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(CpuidResultList)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).ExceptionExitBitmap as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(ExceptionExitBitmap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).LocalApicEmulationMode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(LocalApicEmulationMode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_PROPERTY>())).SeparateSecurityDomain as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_PROPERTY),
            "::",
            stringify!(SeparateSecurityDomain)
        )
    );
}
pub type WHV_GUEST_PHYSICAL_ADDRESS = UINT64;
pub type WHV_GUEST_VIRTUAL_ADDRESS = UINT64;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagNone: WHV_MAP_GPA_RANGE_FLAGS = 0;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagRead: WHV_MAP_GPA_RANGE_FLAGS = 1;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagWrite: WHV_MAP_GPA_RANGE_FLAGS = 2;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagExecute: WHV_MAP_GPA_RANGE_FLAGS = 4;
pub const WHV_MAP_GPA_RANGE_FLAGS_WHvMapGpaRangeFlagTrackDirtyPages: WHV_MAP_GPA_RANGE_FLAGS = 8;
pub type WHV_MAP_GPA_RANGE_FLAGS = i32;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagNone: WHV_TRANSLATE_GVA_FLAGS = 0;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateRead: WHV_TRANSLATE_GVA_FLAGS = 1;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateWrite: WHV_TRANSLATE_GVA_FLAGS = 2;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagValidateExecute: WHV_TRANSLATE_GVA_FLAGS = 4;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagPrivilegeExempt: WHV_TRANSLATE_GVA_FLAGS = 8;
pub const WHV_TRANSLATE_GVA_FLAGS_WHvTranslateGvaFlagSetPageTableBits: WHV_TRANSLATE_GVA_FLAGS = 16;
pub type WHV_TRANSLATE_GVA_FLAGS = i32;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultSuccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 0;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultPageNotPresent:
    WHV_TRANSLATE_GVA_RESULT_CODE = 1;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultPrivilegeViolation:
    WHV_TRANSLATE_GVA_RESULT_CODE = 2;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultInvalidPageTableFlags:
    WHV_TRANSLATE_GVA_RESULT_CODE = 3;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaUnmapped:
    WHV_TRANSLATE_GVA_RESULT_CODE = 4;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaNoReadAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 5;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaNoWriteAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 6;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultGpaIllegalOverlayAccess:
    WHV_TRANSLATE_GVA_RESULT_CODE = 7;
pub const WHV_TRANSLATE_GVA_RESULT_CODE_WHvTranslateGvaResultIntercept:
    WHV_TRANSLATE_GVA_RESULT_CODE = 8;
pub type WHV_TRANSLATE_GVA_RESULT_CODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_TRANSLATE_GVA_RESULT {
    pub ResultCode: WHV_TRANSLATE_GVA_RESULT_CODE,
    pub Reserved: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_TRANSLATE_GVA_RESULT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_TRANSLATE_GVA_RESULT>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_TRANSLATE_GVA_RESULT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_TRANSLATE_GVA_RESULT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_TRANSLATE_GVA_RESULT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_TRANSLATE_GVA_RESULT>())).ResultCode as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_TRANSLATE_GVA_RESULT),
            "::",
            stringify!(ResultCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_TRANSLATE_GVA_RESULT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_TRANSLATE_GVA_RESULT),
            "::",
            stringify!(Reserved)
        )
    );
}
pub const WHV_REGISTER_NAME_WHvX64RegisterRax: WHV_REGISTER_NAME = 0;
pub const WHV_REGISTER_NAME_WHvX64RegisterRcx: WHV_REGISTER_NAME = 1;
pub const WHV_REGISTER_NAME_WHvX64RegisterRdx: WHV_REGISTER_NAME = 2;
pub const WHV_REGISTER_NAME_WHvX64RegisterRbx: WHV_REGISTER_NAME = 3;
pub const WHV_REGISTER_NAME_WHvX64RegisterRsp: WHV_REGISTER_NAME = 4;
pub const WHV_REGISTER_NAME_WHvX64RegisterRbp: WHV_REGISTER_NAME = 5;
pub const WHV_REGISTER_NAME_WHvX64RegisterRsi: WHV_REGISTER_NAME = 6;
pub const WHV_REGISTER_NAME_WHvX64RegisterRdi: WHV_REGISTER_NAME = 7;
pub const WHV_REGISTER_NAME_WHvX64RegisterR8: WHV_REGISTER_NAME = 8;
pub const WHV_REGISTER_NAME_WHvX64RegisterR9: WHV_REGISTER_NAME = 9;
pub const WHV_REGISTER_NAME_WHvX64RegisterR10: WHV_REGISTER_NAME = 10;
pub const WHV_REGISTER_NAME_WHvX64RegisterR11: WHV_REGISTER_NAME = 11;
pub const WHV_REGISTER_NAME_WHvX64RegisterR12: WHV_REGISTER_NAME = 12;
pub const WHV_REGISTER_NAME_WHvX64RegisterR13: WHV_REGISTER_NAME = 13;
pub const WHV_REGISTER_NAME_WHvX64RegisterR14: WHV_REGISTER_NAME = 14;
pub const WHV_REGISTER_NAME_WHvX64RegisterR15: WHV_REGISTER_NAME = 15;
pub const WHV_REGISTER_NAME_WHvX64RegisterRip: WHV_REGISTER_NAME = 16;
pub const WHV_REGISTER_NAME_WHvX64RegisterRflags: WHV_REGISTER_NAME = 17;
pub const WHV_REGISTER_NAME_WHvX64RegisterEs: WHV_REGISTER_NAME = 18;
pub const WHV_REGISTER_NAME_WHvX64RegisterCs: WHV_REGISTER_NAME = 19;
pub const WHV_REGISTER_NAME_WHvX64RegisterSs: WHV_REGISTER_NAME = 20;
pub const WHV_REGISTER_NAME_WHvX64RegisterDs: WHV_REGISTER_NAME = 21;
pub const WHV_REGISTER_NAME_WHvX64RegisterFs: WHV_REGISTER_NAME = 22;
pub const WHV_REGISTER_NAME_WHvX64RegisterGs: WHV_REGISTER_NAME = 23;
pub const WHV_REGISTER_NAME_WHvX64RegisterLdtr: WHV_REGISTER_NAME = 24;
pub const WHV_REGISTER_NAME_WHvX64RegisterTr: WHV_REGISTER_NAME = 25;
pub const WHV_REGISTER_NAME_WHvX64RegisterIdtr: WHV_REGISTER_NAME = 26;
pub const WHV_REGISTER_NAME_WHvX64RegisterGdtr: WHV_REGISTER_NAME = 27;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr0: WHV_REGISTER_NAME = 28;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr2: WHV_REGISTER_NAME = 29;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr3: WHV_REGISTER_NAME = 30;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr4: WHV_REGISTER_NAME = 31;
pub const WHV_REGISTER_NAME_WHvX64RegisterCr8: WHV_REGISTER_NAME = 32;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr0: WHV_REGISTER_NAME = 33;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr1: WHV_REGISTER_NAME = 34;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr2: WHV_REGISTER_NAME = 35;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr3: WHV_REGISTER_NAME = 36;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr6: WHV_REGISTER_NAME = 37;
pub const WHV_REGISTER_NAME_WHvX64RegisterDr7: WHV_REGISTER_NAME = 38;
pub const WHV_REGISTER_NAME_WHvX64RegisterXCr0: WHV_REGISTER_NAME = 39;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm0: WHV_REGISTER_NAME = 4096;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm1: WHV_REGISTER_NAME = 4097;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm2: WHV_REGISTER_NAME = 4098;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm3: WHV_REGISTER_NAME = 4099;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm4: WHV_REGISTER_NAME = 4100;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm5: WHV_REGISTER_NAME = 4101;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm6: WHV_REGISTER_NAME = 4102;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm7: WHV_REGISTER_NAME = 4103;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm8: WHV_REGISTER_NAME = 4104;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm9: WHV_REGISTER_NAME = 4105;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm10: WHV_REGISTER_NAME = 4106;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm11: WHV_REGISTER_NAME = 4107;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm12: WHV_REGISTER_NAME = 4108;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm13: WHV_REGISTER_NAME = 4109;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm14: WHV_REGISTER_NAME = 4110;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmm15: WHV_REGISTER_NAME = 4111;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx0: WHV_REGISTER_NAME = 4112;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx1: WHV_REGISTER_NAME = 4113;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx2: WHV_REGISTER_NAME = 4114;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx3: WHV_REGISTER_NAME = 4115;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx4: WHV_REGISTER_NAME = 4116;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx5: WHV_REGISTER_NAME = 4117;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx6: WHV_REGISTER_NAME = 4118;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpMmx7: WHV_REGISTER_NAME = 4119;
pub const WHV_REGISTER_NAME_WHvX64RegisterFpControlStatus: WHV_REGISTER_NAME = 4120;
pub const WHV_REGISTER_NAME_WHvX64RegisterXmmControlStatus: WHV_REGISTER_NAME = 4121;
pub const WHV_REGISTER_NAME_WHvX64RegisterTsc: WHV_REGISTER_NAME = 8192;
pub const WHV_REGISTER_NAME_WHvX64RegisterEfer: WHV_REGISTER_NAME = 8193;
pub const WHV_REGISTER_NAME_WHvX64RegisterKernelGsBase: WHV_REGISTER_NAME = 8194;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicBase: WHV_REGISTER_NAME = 8195;
pub const WHV_REGISTER_NAME_WHvX64RegisterPat: WHV_REGISTER_NAME = 8196;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterCs: WHV_REGISTER_NAME = 8197;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterEip: WHV_REGISTER_NAME = 8198;
pub const WHV_REGISTER_NAME_WHvX64RegisterSysenterEsp: WHV_REGISTER_NAME = 8199;
pub const WHV_REGISTER_NAME_WHvX64RegisterStar: WHV_REGISTER_NAME = 8200;
pub const WHV_REGISTER_NAME_WHvX64RegisterLstar: WHV_REGISTER_NAME = 8201;
pub const WHV_REGISTER_NAME_WHvX64RegisterCstar: WHV_REGISTER_NAME = 8202;
pub const WHV_REGISTER_NAME_WHvX64RegisterSfmask: WHV_REGISTER_NAME = 8203;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrCap: WHV_REGISTER_NAME = 8205;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrDefType: WHV_REGISTER_NAME = 8206;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase0: WHV_REGISTER_NAME = 8208;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase1: WHV_REGISTER_NAME = 8209;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase2: WHV_REGISTER_NAME = 8210;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase3: WHV_REGISTER_NAME = 8211;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase4: WHV_REGISTER_NAME = 8212;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase5: WHV_REGISTER_NAME = 8213;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase6: WHV_REGISTER_NAME = 8214;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase7: WHV_REGISTER_NAME = 8215;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase8: WHV_REGISTER_NAME = 8216;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBase9: WHV_REGISTER_NAME = 8217;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseA: WHV_REGISTER_NAME = 8218;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseB: WHV_REGISTER_NAME = 8219;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseC: WHV_REGISTER_NAME = 8220;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseD: WHV_REGISTER_NAME = 8221;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseE: WHV_REGISTER_NAME = 8222;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysBaseF: WHV_REGISTER_NAME = 8223;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask0: WHV_REGISTER_NAME = 8256;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask1: WHV_REGISTER_NAME = 8257;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask2: WHV_REGISTER_NAME = 8258;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask3: WHV_REGISTER_NAME = 8259;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask4: WHV_REGISTER_NAME = 8260;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask5: WHV_REGISTER_NAME = 8261;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask6: WHV_REGISTER_NAME = 8262;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask7: WHV_REGISTER_NAME = 8263;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask8: WHV_REGISTER_NAME = 8264;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMask9: WHV_REGISTER_NAME = 8265;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskA: WHV_REGISTER_NAME = 8266;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskB: WHV_REGISTER_NAME = 8267;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskC: WHV_REGISTER_NAME = 8268;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskD: WHV_REGISTER_NAME = 8269;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskE: WHV_REGISTER_NAME = 8270;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrPhysMaskF: WHV_REGISTER_NAME = 8271;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix64k00000: WHV_REGISTER_NAME = 8304;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix16k80000: WHV_REGISTER_NAME = 8305;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix16kA0000: WHV_REGISTER_NAME = 8306;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kC0000: WHV_REGISTER_NAME = 8307;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kC8000: WHV_REGISTER_NAME = 8308;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kD0000: WHV_REGISTER_NAME = 8309;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kD8000: WHV_REGISTER_NAME = 8310;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kE0000: WHV_REGISTER_NAME = 8311;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kE8000: WHV_REGISTER_NAME = 8312;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kF0000: WHV_REGISTER_NAME = 8313;
pub const WHV_REGISTER_NAME_WHvX64RegisterMsrMtrrFix4kF8000: WHV_REGISTER_NAME = 8314;
pub const WHV_REGISTER_NAME_WHvX64RegisterTscAux: WHV_REGISTER_NAME = 8315;
pub const WHV_REGISTER_NAME_WHvX64RegisterSpecCtrl: WHV_REGISTER_NAME = 8324;
pub const WHV_REGISTER_NAME_WHvX64RegisterPredCmd: WHV_REGISTER_NAME = 8325;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicId: WHV_REGISTER_NAME = 12290;
pub const WHV_REGISTER_NAME_WHvX64RegisterApicVersion: WHV_REGISTER_NAME = 12291;
pub const WHV_REGISTER_NAME_WHvRegisterPendingInterruption: WHV_REGISTER_NAME = -2147483648;
pub const WHV_REGISTER_NAME_WHvRegisterInterruptState: WHV_REGISTER_NAME = -2147483647;
pub const WHV_REGISTER_NAME_WHvRegisterPendingEvent: WHV_REGISTER_NAME = -2147483646;
pub const WHV_REGISTER_NAME_WHvX64RegisterDeliverabilityNotifications: WHV_REGISTER_NAME =
    -2147483644;
pub const WHV_REGISTER_NAME_WHvRegisterInternalActivityState: WHV_REGISTER_NAME = -2147483643;
pub type WHV_REGISTER_NAME = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_UINT128 {
    pub __bindgen_anon_1: WHV_UINT128__bindgen_ty_1,
    pub Dword: [UINT32; 4usize],
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_UINT128__bindgen_ty_1 {
    pub Low64: UINT64,
    pub High64: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_UINT128__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_UINT128__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_UINT128__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_UINT128__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_UINT128__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_UINT128__bindgen_ty_1>())).Low64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128__bindgen_ty_1),
            "::",
            stringify!(Low64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_UINT128__bindgen_ty_1>())).High64 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128__bindgen_ty_1),
            "::",
            stringify!(High64)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_UINT128() {
    assert_eq!(
        ::std::mem::size_of::<WHV_UINT128>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_UINT128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_UINT128>())).Dword as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_UINT128),
            "::",
            stringify!(Dword)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_REGISTER {
    pub __bindgen_anon_1: WHV_X64_FP_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_FP_REGISTER__bindgen_ty_1 {
    pub Mantissa: UINT64,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_REGISTER__bindgen_ty_1>())).Mantissa as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Mantissa)
        )
    );
}
impl WHV_X64_FP_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn BiasedExponent(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 15u8) as u64) }
    }
    #[inline]
    pub fn set_BiasedExponent(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 15u8, val as u64)
        }
    }
    #[inline]
    pub fn Sign(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_Sign(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        BiasedExponent: UINT64,
        Sign: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 15u8, {
            let BiasedExponent: u64 = unsafe { ::std::mem::transmute(BiasedExponent) };
            BiasedExponent as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Sign: u64 = unsafe { ::std::mem::transmute(Sign) };
            Sign as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_FP_REGISTER>())).AsUINT128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_CONTROL_STATUS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    pub FpControl: UINT16,
    pub FpStatus: UINT16,
    pub FpTag: UINT8,
    pub Reserved: UINT8,
    pub LastFpOp: UINT16,
    pub __bindgen_anon_1: WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpRip: UINT64,
    pub __bindgen_anon_1:
        WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpEip: UINT32,
    pub LastFpCs: UINT16,
    pub Reserved2: UINT16,
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpEip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpEip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpCs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpCs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved2 as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved2)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(
            )))
            .LastFpRip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastFpRip)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpControl
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpStatus
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).FpTag
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(FpTag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).Reserved
                as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1>())).LastFpOp
                as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(LastFpOp)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_FP_CONTROL_STATUS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_FP_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_FP_CONTROL_STATUS_REGISTER>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_FP_CONTROL_STATUS_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_XMM_CONTROL_STATUS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1,
    pub XmmStatusControl: UINT32,
    pub XmmStatusControlMask: UINT32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpRdp: UINT64,
    pub __bindgen_anon_1:
        WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 {
    pub LastFpDp: UINT32,
    pub LastFpDs: UINT16,
    pub Reserved: UINT16,
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1(
) {
    assert_eq!(
        ::std::mem::size_of::<
            WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        ::std::mem::align_of::<
            WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
        >(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            )
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpDp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpDp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .LastFpDs as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(LastFpDs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1,
            >()))
            .Reserved as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(
                WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1
            ),
            "::",
            stringify!(Reserved)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1>(
            )))
            .LastFpRdp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(LastFpRdp)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>()))
                .XmmStatusControl as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(XmmStatusControl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1>()))
                .XmmStatusControlMask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER__bindgen_ty_1),
            "::",
            stringify!(XmmStatusControlMask)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_XMM_CONTROL_STATUS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_XMM_CONTROL_STATUS_REGISTER>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_XMM_CONTROL_STATUS_REGISTER),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_SEGMENT_REGISTER {
    pub Base: UINT64,
    pub Limit: UINT32,
    pub Selector: UINT16,
    pub __bindgen_anon_1: WHV_X64_SEGMENT_REGISTER__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_SEGMENT_REGISTER__bindgen_ty_1 {
    pub __bindgen_anon_1: WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1,
    pub Attributes: UINT16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1)
        )
    );
}
impl WHV_X64_SEGMENT_REGISTER__bindgen_ty_1__bindgen_ty_1 {
    #[inline]
    pub fn SegmentType(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_SegmentType(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NonSystemSegment(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_NonSystemSegment(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DescriptorPrivilegeLevel(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_DescriptorPrivilegeLevel(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Present(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Present(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Available(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Available(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Long(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Long(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Default(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Default(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Granularity(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Granularity(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        SegmentType: UINT16,
        NonSystemSegment: UINT16,
        DescriptorPrivilegeLevel: UINT16,
        Present: UINT16,
        Reserved: UINT16,
        Available: UINT16,
        Long: UINT16,
        Default: UINT16,
        Granularity: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let SegmentType: u16 = unsafe { ::std::mem::transmute(SegmentType) };
            SegmentType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let NonSystemSegment: u16 = unsafe { ::std::mem::transmute(NonSystemSegment) };
            NonSystemSegment as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let DescriptorPrivilegeLevel: u16 =
                unsafe { ::std::mem::transmute(DescriptorPrivilegeLevel) };
            DescriptorPrivilegeLevel as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let Present: u16 = unsafe { ::std::mem::transmute(Present) };
            Present as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let Reserved: u16 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let Available: u16 = unsafe { ::std::mem::transmute(Available) };
            Available as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let Long: u16 = unsafe { ::std::mem::transmute(Long) };
            Long as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let Default: u16 = unsafe { ::std::mem::transmute(Default) };
            Default as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let Granularity: u16 = unsafe { ::std::mem::transmute(Granularity) };
            Granularity as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER__bindgen_ty_1>())).Attributes
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER__bindgen_ty_1),
            "::",
            stringify!(Attributes)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_X64_SEGMENT_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_SEGMENT_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_SEGMENT_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_SEGMENT_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_SEGMENT_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_SEGMENT_REGISTER>())).Selector as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_SEGMENT_REGISTER),
            "::",
            stringify!(Selector)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_TABLE_REGISTER {
    pub Pad: [UINT16; 3usize],
    pub Limit: UINT16,
    pub Base: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_TABLE_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_TABLE_REGISTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_TABLE_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_TABLE_REGISTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_TABLE_REGISTER))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Pad as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Limit as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_TABLE_REGISTER>())).Base as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_TABLE_REGISTER),
            "::",
            stringify!(Base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_INTERRUPT_STATE_REGISTER {
    pub __bindgen_anon_1: WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_X64_INTERRUPT_STATE_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptShadow(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptShadow(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn NmiMasked(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NmiMasked(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 62u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 62u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptShadow: UINT64,
        NmiMasked: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InterruptShadow: u64 = unsafe { ::std::mem::transmute(InterruptShadow) };
            InterruptShadow as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let NmiMasked: u64 = unsafe { ::std::mem::transmute(NmiMasked) };
            NmiMasked as u64
        });
        __bindgen_bitfield_unit.set(2usize, 62u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPT_STATE_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPT_STATE_REGISTER>(),
        8usize,
        concat!("Size of: ", stringify!(WHV_X64_INTERRUPT_STATE_REGISTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPT_STATE_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_INTERRUPT_STATE_REGISTER>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_INTERRUPT_STATE_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_INTERRUPTION_REGISTER {
    pub __bindgen_anon_1: WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub ErrorCode: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1>()))
                .ErrorCode as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1),
            "::",
            stringify!(ErrorCode)
        )
    );
}
impl WHV_X64_PENDING_INTERRUPTION_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn InterruptionPending(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionPending(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn DeliverErrorCode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeliverErrorCode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InstructionLength(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_InstructionLength(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn NestedEvent(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_NestedEvent(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(10usize, 6u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(10usize, 6u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionVector(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_InterruptionVector(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InterruptionPending: UINT32,
        InterruptionType: UINT32,
        DeliverErrorCode: UINT32,
        InstructionLength: UINT32,
        NestedEvent: UINT32,
        Reserved: UINT32,
        InterruptionVector: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let InterruptionPending: u32 = unsafe { ::std::mem::transmute(InterruptionPending) };
            InterruptionPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let InterruptionType: u32 = unsafe { ::std::mem::transmute(InterruptionType) };
            InterruptionType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let DeliverErrorCode: u32 = unsafe { ::std::mem::transmute(DeliverErrorCode) };
            DeliverErrorCode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 4u8, {
            let InstructionLength: u32 = unsafe { ::std::mem::transmute(InstructionLength) };
            InstructionLength as u64
        });
        __bindgen_bitfield_unit.set(9usize, 1u8, {
            let NestedEvent: u32 = unsafe { ::std::mem::transmute(NestedEvent) };
            NestedEvent as u64
        });
        __bindgen_bitfield_unit.set(10usize, 6u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let InterruptionVector: u32 = unsafe { ::std::mem::transmute(InterruptionVector) };
            InterruptionVector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_INTERRUPTION_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_INTERRUPTION_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_INTERRUPTION_REGISTER>())).AsUINT64 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_INTERRUPTION_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER {
    pub __bindgen_anon_1: WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1,
    pub AsUINT64: UINT64,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1)
        )
    );
}
impl WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER__bindgen_ty_1 {
    #[inline]
    pub fn NmiNotification(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_NmiNotification(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptNotification(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptNotification(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptPriority(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_InterruptPriority(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 58u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 58u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        NmiNotification: UINT64,
        InterruptNotification: UINT64,
        InterruptPriority: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let NmiNotification: u64 = unsafe { ::std::mem::transmute(NmiNotification) };
            NmiNotification as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let InterruptNotification: u64 =
                unsafe { ::std::mem::transmute(InterruptNotification) };
            InterruptNotification as u64
        });
        __bindgen_bitfield_unit.set(2usize, 4u8, {
            let InterruptPriority: u64 = unsafe { ::std::mem::transmute(InterruptPriority) };
            InterruptPriority as u64
        });
        __bindgen_bitfield_unit.set(6usize, 58u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER>())).AsUINT64
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER),
            "::",
            stringify!(AsUINT64)
        )
    );
}
pub const WHV_X64_PENDING_EVENT_TYPE_WHvX64PendingEventException: WHV_X64_PENDING_EVENT_TYPE = 0;
pub const WHV_X64_PENDING_EVENT_TYPE_WHvX64PendingEventExtInt: WHV_X64_PENDING_EVENT_TYPE = 5;
pub type WHV_X64_PENDING_EVENT_TYPE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_EXCEPTION_EVENT {
    pub __bindgen_anon_1: WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u16>,
    pub ErrorCode: UINT32,
    pub ExceptionParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>())).ErrorCode
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1>()))
                .ExceptionParameter as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1),
            "::",
            stringify!(ExceptionParameter)
        )
    );
}
impl WHV_X64_PENDING_EXCEPTION_EVENT__bindgen_ty_1 {
    #[inline]
    pub fn EventPending(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_EventPending(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EventType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_EventType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn DeliverErrorCode(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_DeliverErrorCode(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(9usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(9usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EventPending: UINT32,
        EventType: UINT32,
        Reserved0: UINT32,
        DeliverErrorCode: UINT32,
        Reserved1: UINT32,
        Vector: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u16> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u16> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EventPending: u32 = unsafe { ::std::mem::transmute(EventPending) };
            EventPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let EventType: u32 = unsafe { ::std::mem::transmute(EventType) };
            EventType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved0: u32 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 1u8, {
            let DeliverErrorCode: u32 = unsafe { ::std::mem::transmute(DeliverErrorCode) };
            DeliverErrorCode as u64
        });
        __bindgen_bitfield_unit.set(9usize, 7u8, {
            let Reserved1: u32 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let Vector: u32 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXCEPTION_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXCEPTION_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_EXCEPTION_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXCEPTION_EVENT>())).AsUINT128 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXCEPTION_EVENT),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_PENDING_EXT_INT_EVENT {
    pub __bindgen_anon_1: WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1,
    pub AsUINT128: WHV_UINT128,
    _bindgen_union_align: [u8; 16usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub Reserved2: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1>())).Reserved2
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1),
            "::",
            stringify!(Reserved2)
        )
    );
}
impl WHV_X64_PENDING_EXT_INT_EVENT__bindgen_ty_1 {
    #[inline]
    pub fn EventPending(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u64) }
    }
    #[inline]
    pub fn set_EventPending(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EventType(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u64) }
    }
    #[inline]
    pub fn set_EventType(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Vector(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Vector(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        EventPending: UINT64,
        EventType: UINT64,
        Reserved0: UINT64,
        Vector: UINT64,
        Reserved1: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let EventPending: u64 = unsafe { ::std::mem::transmute(EventPending) };
            EventPending as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let EventType: u64 = unsafe { ::std::mem::transmute(EventType) };
            EventType as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Reserved0: u64 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let Vector: u64 = unsafe { ::std::mem::transmute(Vector) };
            Vector as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved1: u64 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_PENDING_EXT_INT_EVENT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_PENDING_EXT_INT_EVENT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_PENDING_EXT_INT_EVENT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_PENDING_EXT_INT_EVENT>())).AsUINT128 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_PENDING_EXT_INT_EVENT),
            "::",
            stringify!(AsUINT128)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_REGISTER_VALUE {
    pub Reg128: WHV_UINT128,
    pub Reg64: UINT64,
    pub Reg32: UINT32,
    pub Reg16: UINT16,
    pub Reg8: UINT8,
    pub Fp: WHV_X64_FP_REGISTER,
    pub FpControlStatus: WHV_X64_FP_CONTROL_STATUS_REGISTER,
    pub XmmControlStatus: WHV_X64_XMM_CONTROL_STATUS_REGISTER,
    pub Segment: WHV_X64_SEGMENT_REGISTER,
    pub Table: WHV_X64_TABLE_REGISTER,
    pub InterruptState: WHV_X64_INTERRUPT_STATE_REGISTER,
    pub PendingInterruption: WHV_X64_PENDING_INTERRUPTION_REGISTER,
    pub DeliverabilityNotifications: WHV_X64_DELIVERABILITY_NOTIFICATIONS_REGISTER,
    pub ExceptionEvent: WHV_X64_PENDING_EXCEPTION_EVENT,
    pub ExtIntEvent: WHV_X64_PENDING_EXT_INT_EVENT,
    _bindgen_union_align: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_WHV_REGISTER_VALUE() {
    assert_eq!(
        ::std::mem::size_of::<WHV_REGISTER_VALUE>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_REGISTER_VALUE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg128)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Reg8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Reg8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Fp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).FpControlStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(FpControlStatus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).XmmControlStatus as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(XmmControlStatus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Segment as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Segment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).Table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(Table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).InterruptState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(InterruptState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).PendingInterruption as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(PendingInterruption)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).DeliverabilityNotifications as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(DeliverabilityNotifications)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).ExceptionEvent as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(ExceptionEvent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_REGISTER_VALUE>())).ExtIntEvent as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_REGISTER_VALUE),
            "::",
            stringify!(ExtIntEvent)
        )
    );
}
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonNone: WHV_RUN_VP_EXIT_REASON = 0;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonMemoryAccess: WHV_RUN_VP_EXIT_REASON = 1;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64IoPortAccess: WHV_RUN_VP_EXIT_REASON = 2;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonUnrecoverableException: WHV_RUN_VP_EXIT_REASON =
    4;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonInvalidVpRegisterValue: WHV_RUN_VP_EXIT_REASON =
    5;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonUnsupportedFeature: WHV_RUN_VP_EXIT_REASON = 6;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64InterruptWindow: WHV_RUN_VP_EXIT_REASON = 7;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Halt: WHV_RUN_VP_EXIT_REASON = 8;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64ApicEoi: WHV_RUN_VP_EXIT_REASON = 9;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64MsrAccess: WHV_RUN_VP_EXIT_REASON = 4096;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonX64Cpuid: WHV_RUN_VP_EXIT_REASON = 4097;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonException: WHV_RUN_VP_EXIT_REASON = 4098;
pub const WHV_RUN_VP_EXIT_REASON_WHvRunVpExitReasonCanceled: WHV_RUN_VP_EXIT_REASON = 8193;
pub type WHV_RUN_VP_EXIT_REASON = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_VP_EXECUTION_STATE {
    pub __bindgen_anon_1: WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1,
    pub AsUINT16: UINT16,
    _bindgen_union_align: u16,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub __bindgen_align: [u16; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1)
        )
    );
}
impl WHV_X64_VP_EXECUTION_STATE__bindgen_ty_1 {
    #[inline]
    pub fn Cpl(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u16) }
    }
    #[inline]
    pub fn set_Cpl(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr0Pe(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Cr0Pe(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr0Am(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_Cr0Am(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn EferLma(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_EferLma(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn DebugActive(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_DebugActive(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptionPending(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptionPending(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved0(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 5u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved0(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn InterruptShadow(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_InterruptShadow(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved1(&self) -> UINT16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(13usize, 3u8) as u16) }
    }
    #[inline]
    pub fn set_Reserved1(&mut self, val: UINT16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(13usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Cpl: UINT16,
        Cr0Pe: UINT16,
        Cr0Am: UINT16,
        EferLma: UINT16,
        DebugActive: UINT16,
        InterruptionPending: UINT16,
        Reserved0: UINT16,
        InterruptShadow: UINT16,
        Reserved1: UINT16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let Cpl: u16 = unsafe { ::std::mem::transmute(Cpl) };
            Cpl as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let Cr0Pe: u16 = unsafe { ::std::mem::transmute(Cr0Pe) };
            Cr0Pe as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let Cr0Am: u16 = unsafe { ::std::mem::transmute(Cr0Am) };
            Cr0Am as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let EferLma: u16 = unsafe { ::std::mem::transmute(EferLma) };
            EferLma as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let DebugActive: u16 = unsafe { ::std::mem::transmute(DebugActive) };
            DebugActive as u64
        });
        __bindgen_bitfield_unit.set(6usize, 1u8, {
            let InterruptionPending: u16 = unsafe { ::std::mem::transmute(InterruptionPending) };
            InterruptionPending as u64
        });
        __bindgen_bitfield_unit.set(7usize, 5u8, {
            let Reserved0: u16 = unsafe { ::std::mem::transmute(Reserved0) };
            Reserved0 as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let InterruptShadow: u16 = unsafe { ::std::mem::transmute(InterruptShadow) };
            InterruptShadow as u64
        });
        __bindgen_bitfield_unit.set(13usize, 3u8, {
            let Reserved1: u16 = unsafe { ::std::mem::transmute(Reserved1) };
            Reserved1 as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_VP_EXECUTION_STATE() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_VP_EXECUTION_STATE>(),
        2usize,
        concat!("Size of: ", stringify!(WHV_X64_VP_EXECUTION_STATE))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_VP_EXECUTION_STATE>(),
        2usize,
        concat!("Alignment of ", stringify!(WHV_X64_VP_EXECUTION_STATE))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_VP_EXECUTION_STATE>())).AsUINT16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_VP_EXECUTION_STATE),
            "::",
            stringify!(AsUINT16)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_VP_EXIT_CONTEXT {
    pub ExecutionState: WHV_X64_VP_EXECUTION_STATE,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub Reserved: UINT8,
    pub Reserved2: UINT32,
    pub Cs: WHV_X64_SEGMENT_REGISTER,
    pub Rip: UINT64,
    pub Rflags: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXIT_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXIT_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXIT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).ExecutionState as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(ExecutionState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Reserved as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Reserved2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Cs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Cs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Rip as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXIT_CONTEXT>())).Rflags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXIT_CONTEXT),
            "::",
            stringify!(Rflags)
        )
    );
}
impl WHV_VP_EXIT_CONTEXT {
    #[inline]
    pub fn InstructionLength(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_InstructionLength(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Cr8(&self) -> UINT8 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 4u8) as u8) }
    }
    #[inline]
    pub fn set_Cr8(&mut self, val: UINT8) {
        unsafe {
            let val: u8 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        InstructionLength: UINT8,
        Cr8: UINT8,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 4u8, {
            let InstructionLength: u8 = unsafe { ::std::mem::transmute(InstructionLength) };
            InstructionLength as u64
        });
        __bindgen_bitfield_unit.set(4usize, 4u8, {
            let Cr8: u8 = unsafe { ::std::mem::transmute(Cr8) };
            Cr8 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessRead: WHV_MEMORY_ACCESS_TYPE = 0;
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessWrite: WHV_MEMORY_ACCESS_TYPE = 1;
pub const WHV_MEMORY_ACCESS_TYPE_WHvMemoryAccessExecute: WHV_MEMORY_ACCESS_TYPE = 2;
pub type WHV_MEMORY_ACCESS_TYPE = i32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_MEMORY_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_MEMORY_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_MEMORY_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_MEMORY_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_MEMORY_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_MEMORY_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn AccessType(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_AccessType(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn GpaUnmapped(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GpaUnmapped(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn GvaValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(3usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_GvaValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(3usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 28u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 28u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        AccessType: UINT32,
        GpaUnmapped: UINT32,
        GvaValid: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 2u8, {
            let AccessType: u32 = unsafe { ::std::mem::transmute(AccessType) };
            AccessType as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let GpaUnmapped: u32 = unsafe { ::std::mem::transmute(GpaUnmapped) };
            GpaUnmapped as u64
        });
        __bindgen_bitfield_unit.set(3usize, 1u8, {
            let GvaValid: u32 = unsafe { ::std::mem::transmute(GvaValid) };
            GvaValid as u64
        });
        __bindgen_bitfield_unit.set(4usize, 28u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_MEMORY_ACCESS_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_INFO>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_MEMORY_ACCESS_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub AccessInfo: WHV_MEMORY_ACCESS_INFO,
    pub Gpa: WHV_GUEST_PHYSICAL_ADDRESS,
    pub Gva: WHV_GUEST_VIRTUAL_ADDRESS,
}
#[test]
fn bindgen_test_layout_WHV_MEMORY_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_MEMORY_ACCESS_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_MEMORY_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_MEMORY_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_MEMORY_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).InstructionByteCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).AccessInfo as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Gpa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Gpa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_MEMORY_ACCESS_CONTEXT>())).Gva as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_MEMORY_ACCESS_CONTEXT),
            "::",
            stringify!(Gva)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_IO_PORT_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_IO_PORT_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsWrite(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWrite(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn AccessSize(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_AccessSize(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn StringOp(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(4usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_StringOp(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(4usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn RepPrefix(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_RepPrefix(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 26u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(6usize, 26u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsWrite: UINT32,
        AccessSize: UINT32,
        StringOp: UINT32,
        RepPrefix: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsWrite: u32 = unsafe { ::std::mem::transmute(IsWrite) };
            IsWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 3u8, {
            let AccessSize: u32 = unsafe { ::std::mem::transmute(AccessSize) };
            AccessSize as u64
        });
        __bindgen_bitfield_unit.set(4usize, 1u8, {
            let StringOp: u32 = unsafe { ::std::mem::transmute(StringOp) };
            StringOp as u64
        });
        __bindgen_bitfield_unit.set(5usize, 1u8, {
            let RepPrefix: u32 = unsafe { ::std::mem::transmute(RepPrefix) };
            RepPrefix as u64
        });
        __bindgen_bitfield_unit.set(6usize, 26u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_IO_PORT_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_IO_PORT_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_INFO>())).AsUINT32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_IO_PORT_ACCESS_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub AccessInfo: WHV_X64_IO_PORT_ACCESS_INFO,
    pub PortNumber: UINT16,
    pub Reserved2: [UINT16; 3usize],
    pub Rax: UINT64,
    pub Rcx: UINT64,
    pub Rsi: UINT64,
    pub Rdi: UINT64,
    pub Ds: WHV_X64_SEGMENT_REGISTER,
    pub Es: WHV_X64_SEGMENT_REGISTER,
}
#[test]
fn bindgen_test_layout_WHV_X64_IO_PORT_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_IO_PORT_ACCESS_CONTEXT>(),
        96usize,
        concat!("Size of: ", stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_IO_PORT_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).InstructionByteCount
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).AccessInfo as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).PortNumber as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(PortNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Reserved2 as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rax as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rcx as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rsi as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Rdi as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Ds as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Ds)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_IO_PORT_ACCESS_CONTEXT>())).Es as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_IO_PORT_ACCESS_CONTEXT),
            "::",
            stringify!(Es)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_X64_MSR_ACCESS_INFO {
    pub __bindgen_anon_1: WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_X64_MSR_ACCESS_INFO__bindgen_ty_1 {
    #[inline]
    pub fn IsWrite(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_IsWrite(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 31u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 31u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        IsWrite: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let IsWrite: u32 = unsafe { ::std::mem::transmute(IsWrite) };
            IsWrite as u64
        });
        __bindgen_bitfield_unit.set(1usize, 31u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_ACCESS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_ACCESS_INFO))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_INFO>())).AsUINT32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_X64_MSR_ACCESS_CONTEXT {
    pub AccessInfo: WHV_X64_MSR_ACCESS_INFO,
    pub MsrNumber: UINT32,
    pub Rax: UINT64,
    pub Rdx: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_MSR_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_MSR_ACCESS_CONTEXT>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_X64_MSR_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_MSR_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_MSR_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).AccessInfo as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(AccessInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).MsrNumber as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(MsrNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).Rax as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_X64_MSR_ACCESS_CONTEXT>())).Rdx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_MSR_ACCESS_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_CPUID_ACCESS_CONTEXT {
    pub Rax: UINT64,
    pub Rcx: UINT64,
    pub Rdx: UINT64,
    pub Rbx: UINT64,
    pub DefaultResultRax: UINT64,
    pub DefaultResultRcx: UINT64,
    pub DefaultResultRdx: UINT64,
    pub DefaultResultRbx: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_CPUID_ACCESS_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_CPUID_ACCESS_CONTEXT>(),
        64usize,
        concat!("Size of: ", stringify!(WHV_X64_CPUID_ACCESS_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_CPUID_ACCESS_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_X64_CPUID_ACCESS_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rax as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rcx as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rdx as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).Rbx as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRax as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRax)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRcx as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRcx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRdx as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRdx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_CPUID_ACCESS_CONTEXT>())).DefaultResultRbx as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_CPUID_ACCESS_CONTEXT),
            "::",
            stringify!(DefaultResultRbx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_VP_EXCEPTION_INFO {
    pub __bindgen_anon_1: WHV_VP_EXCEPTION_INFO__bindgen_ty_1,
    pub AsUINT32: UINT32,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_VP_EXCEPTION_INFO__bindgen_ty_1 {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize], u32>,
    pub __bindgen_align: [u32; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_INFO__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_INFO__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_INFO__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_INFO__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_VP_EXCEPTION_INFO__bindgen_ty_1)
        )
    );
}
impl WHV_VP_EXCEPTION_INFO__bindgen_ty_1 {
    #[inline]
    pub fn ErrorCodeValid(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_ErrorCodeValid(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn SoftwareException(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_SoftwareException(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 30u8) as u32) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 30u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        ErrorCodeValid: UINT32,
        SoftwareException: UINT32,
        Reserved: UINT32,
    ) -> __BindgenBitfieldUnit<[u8; 4usize], u32> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize], u32> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let ErrorCodeValid: u32 = unsafe { ::std::mem::transmute(ErrorCodeValid) };
            ErrorCodeValid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let SoftwareException: u32 = unsafe { ::std::mem::transmute(SoftwareException) };
            SoftwareException as u64
        });
        __bindgen_bitfield_unit.set(2usize, 30u8, {
            let Reserved: u32 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_INFO() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_INFO>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_INFO>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXCEPTION_INFO))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_VP_EXCEPTION_INFO>())).AsUINT32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_INFO),
            "::",
            stringify!(AsUINT32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_VP_EXCEPTION_CONTEXT {
    pub InstructionByteCount: UINT8,
    pub Reserved: [UINT8; 3usize],
    pub InstructionBytes: [UINT8; 16usize],
    pub ExceptionInfo: WHV_VP_EXCEPTION_INFO,
    pub ExceptionType: UINT8,
    pub Reserved2: [UINT8; 3usize],
    pub ErrorCode: UINT32,
    pub ExceptionParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_VP_EXCEPTION_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_VP_EXCEPTION_CONTEXT>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_VP_EXCEPTION_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_VP_EXCEPTION_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_VP_EXCEPTION_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).InstructionByteCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(InstructionByteCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).Reserved as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).InstructionBytes as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(InstructionBytes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionInfo as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionInfo)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionType as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionType)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).Reserved2 as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(Reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ErrorCode as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ErrorCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_VP_EXCEPTION_CONTEXT>())).ExceptionParameter as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_VP_EXCEPTION_CONTEXT),
            "::",
            stringify!(ExceptionParameter)
        )
    );
}
pub const WHV_X64_UNSUPPORTED_FEATURE_CODE_WHvUnsupportedFeatureIntercept:
    WHV_X64_UNSUPPORTED_FEATURE_CODE = 1;
pub const WHV_X64_UNSUPPORTED_FEATURE_CODE_WHvUnsupportedFeatureTaskSwitchTss:
    WHV_X64_UNSUPPORTED_FEATURE_CODE = 2;
pub type WHV_X64_UNSUPPORTED_FEATURE_CODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_UNSUPPORTED_FEATURE_CONTEXT {
    pub FeatureCode: WHV_X64_UNSUPPORTED_FEATURE_CODE,
    pub Reserved: UINT32,
    pub FeatureParameter: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_X64_UNSUPPORTED_FEATURE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).FeatureCode as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(FeatureCode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).Reserved as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_UNSUPPORTED_FEATURE_CONTEXT>())).FeatureParameter
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_UNSUPPORTED_FEATURE_CONTEXT),
            "::",
            stringify!(FeatureParameter)
        )
    );
}
pub const WHV_RUN_VP_CANCEL_REASON_WhvRunVpCancelReasonUser: WHV_RUN_VP_CANCEL_REASON = 0;
pub type WHV_RUN_VP_CANCEL_REASON = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_RUN_VP_CANCELED_CONTEXT {
    pub CancelReason: WHV_RUN_VP_CANCEL_REASON,
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_CANCELED_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_CANCELED_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_RUN_VP_CANCELED_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_CANCELED_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_RUN_VP_CANCELED_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_CANCELED_CONTEXT>())).CancelReason as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_CANCELED_CONTEXT),
            "::",
            stringify!(CancelReason)
        )
    );
}
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingInterrupt:
    WHV_X64_PENDING_INTERRUPTION_TYPE = 0;
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingNmi: WHV_X64_PENDING_INTERRUPTION_TYPE = 2;
pub const WHV_X64_PENDING_INTERRUPTION_TYPE_WHvX64PendingException:
    WHV_X64_PENDING_INTERRUPTION_TYPE = 3;
pub type WHV_X64_PENDING_INTERRUPTION_TYPE = i32;
pub type PWHV_X64_PENDING_INTERRUPTION_TYPE = *mut WHV_X64_PENDING_INTERRUPTION_TYPE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT {
    pub DeliverableType: WHV_X64_PENDING_INTERRUPTION_TYPE,
}
#[test]
fn bindgen_test_layout_WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT>())).DeliverableType
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT),
            "::",
            stringify!(DeliverableType)
        )
    );
}
pub type PWHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT = *mut WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_X64_APIC_EOI_CONTEXT {
    pub InterruptVector: UINT32,
}
#[test]
fn bindgen_test_layout_WHV_X64_APIC_EOI_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_X64_APIC_EOI_CONTEXT>(),
        4usize,
        concat!("Size of: ", stringify!(WHV_X64_APIC_EOI_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_X64_APIC_EOI_CONTEXT>(),
        4usize,
        concat!("Alignment of ", stringify!(WHV_X64_APIC_EOI_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_X64_APIC_EOI_CONTEXT>())).InterruptVector as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_X64_APIC_EOI_CONTEXT),
            "::",
            stringify!(InterruptVector)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct WHV_RUN_VP_EXIT_CONTEXT {
    pub ExitReason: WHV_RUN_VP_EXIT_REASON,
    pub Reserved: UINT32,
    pub VpContext: WHV_VP_EXIT_CONTEXT,
    pub __bindgen_anon_1: WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1 {
    pub MemoryAccess: WHV_MEMORY_ACCESS_CONTEXT,
    pub IoPortAccess: WHV_X64_IO_PORT_ACCESS_CONTEXT,
    pub MsrAccess: WHV_X64_MSR_ACCESS_CONTEXT,
    pub CpuidAccess: WHV_X64_CPUID_ACCESS_CONTEXT,
    pub VpException: WHV_VP_EXCEPTION_CONTEXT,
    pub InterruptWindow: WHV_X64_INTERRUPTION_DELIVERABLE_CONTEXT,
    pub UnsupportedFeature: WHV_X64_UNSUPPORTED_FEATURE_CONTEXT,
    pub CancelReason: WHV_RUN_VP_CANCELED_CONTEXT,
    pub ApicEoi: WHV_X64_APIC_EOI_CONTEXT,
    _bindgen_union_align: [u64; 12usize],
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>(),
        96usize,
        concat!(
            "Size of: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).MemoryAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(MemoryAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).IoPortAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(IoPortAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).MsrAccess as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(MsrAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).CpuidAccess
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(CpuidAccess)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).VpException
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(VpException)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).InterruptWindow
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(InterruptWindow)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).UnsupportedFeature
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(UnsupportedFeature)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).CancelReason
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(CancelReason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1>())).ApicEoi as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT__bindgen_ty_1),
            "::",
            stringify!(ApicEoi)
        )
    );
}
#[test]
fn bindgen_test_layout_WHV_RUN_VP_EXIT_CONTEXT() {
    assert_eq!(
        ::std::mem::size_of::<WHV_RUN_VP_EXIT_CONTEXT>(),
        144usize,
        concat!("Size of: ", stringify!(WHV_RUN_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_RUN_VP_EXIT_CONTEXT>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_RUN_VP_EXIT_CONTEXT))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).ExitReason as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(ExitReason)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).Reserved as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(Reserved)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_RUN_VP_EXIT_CONTEXT>())).VpContext as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_RUN_VP_EXIT_CONTEXT),
            "::",
            stringify!(VpContext)
        )
    );
}
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeFixed: WHV_INTERRUPT_TYPE = 0;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeLowestPriority: WHV_INTERRUPT_TYPE = 1;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeNmi: WHV_INTERRUPT_TYPE = 4;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeInit: WHV_INTERRUPT_TYPE = 5;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeSipi: WHV_INTERRUPT_TYPE = 6;
pub const WHV_INTERRUPT_TYPE_WHvX64InterruptTypeLocalInt1: WHV_INTERRUPT_TYPE = 9;
pub type WHV_INTERRUPT_TYPE = i32;
pub const WHV_INTERRUPT_DESTINATION_MODE_WHvX64InterruptDestinationModePhysical:
    WHV_INTERRUPT_DESTINATION_MODE = 0;
pub const WHV_INTERRUPT_DESTINATION_MODE_WHvX64InterruptDestinationModeLogical:
    WHV_INTERRUPT_DESTINATION_MODE = 1;
pub type WHV_INTERRUPT_DESTINATION_MODE = i32;
pub const WHV_INTERRUPT_TRIGGER_MODE_WHvX64InterruptTriggerModeEdge: WHV_INTERRUPT_TRIGGER_MODE = 0;
pub const WHV_INTERRUPT_TRIGGER_MODE_WHvX64InterruptTriggerModeLevel: WHV_INTERRUPT_TRIGGER_MODE =
    1;
pub type WHV_INTERRUPT_TRIGGER_MODE = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_INTERRUPT_CONTROL {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize], u64>,
    pub Destination: UINT32,
    pub Vector: UINT32,
    pub __bindgen_align: [u64; 0usize],
}
#[test]
fn bindgen_test_layout_WHV_INTERRUPT_CONTROL() {
    assert_eq!(
        ::std::mem::size_of::<WHV_INTERRUPT_CONTROL>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_INTERRUPT_CONTROL))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_INTERRUPT_CONTROL>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_INTERRUPT_CONTROL))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_INTERRUPT_CONTROL>())).Destination as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERRUPT_CONTROL),
            "::",
            stringify!(Destination)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<WHV_INTERRUPT_CONTROL>())).Vector as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_INTERRUPT_CONTROL),
            "::",
            stringify!(Vector)
        )
    );
}
impl WHV_INTERRUPT_CONTROL {
    #[inline]
    pub fn Type(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u64) }
    }
    #[inline]
    pub fn set_Type(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn DestinationMode(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_DestinationMode(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn TriggerMode(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 4u8) as u64) }
    }
    #[inline]
    pub fn set_TriggerMode(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 4u8, val as u64)
        }
    }
    #[inline]
    pub fn Reserved(&self) -> UINT64 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 48u8) as u64) }
    }
    #[inline]
    pub fn set_Reserved(&mut self, val: UINT64) {
        unsafe {
            let val: u64 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 48u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        Type: UINT64,
        DestinationMode: UINT64,
        TriggerMode: UINT64,
        Reserved: UINT64,
    ) -> __BindgenBitfieldUnit<[u8; 8usize], u64> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize], u64> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let Type: u64 = unsafe { ::std::mem::transmute(Type) };
            Type as u64
        });
        __bindgen_bitfield_unit.set(8usize, 4u8, {
            let DestinationMode: u64 = unsafe { ::std::mem::transmute(DestinationMode) };
            DestinationMode as u64
        });
        __bindgen_bitfield_unit.set(12usize, 4u8, {
            let TriggerMode: u64 = unsafe { ::std::mem::transmute(TriggerMode) };
            TriggerMode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 48u8, {
            let Reserved: u64 = unsafe { ::std::mem::transmute(Reserved) };
            Reserved as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const WHV_PARTITION_COUNTER_SET_WHvPartitionCounterSetMemory: WHV_PARTITION_COUNTER_SET = 0;
pub type WHV_PARTITION_COUNTER_SET = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PARTITION_MEMORY_COUNTERS {
    pub Mapped4KPageCount: UINT64,
    pub Mapped2MPageCount: UINT64,
    pub Mapped1GPageCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PARTITION_MEMORY_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PARTITION_MEMORY_COUNTERS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PARTITION_MEMORY_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PARTITION_MEMORY_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PARTITION_MEMORY_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped4KPageCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped4KPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped2MPageCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped2MPageCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PARTITION_MEMORY_COUNTERS>())).Mapped1GPageCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PARTITION_MEMORY_COUNTERS),
            "::",
            stringify!(Mapped1GPageCount)
        )
    );
}
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetRuntime: WHV_PROCESSOR_COUNTER_SET = 0;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetIntercepts: WHV_PROCESSOR_COUNTER_SET = 1;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetEvents: WHV_PROCESSOR_COUNTER_SET = 2;
pub const WHV_PROCESSOR_COUNTER_SET_WHvProcessorCounterSetApic: WHV_PROCESSOR_COUNTER_SET = 3;
pub type WHV_PROCESSOR_COUNTER_SET = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_RUNTIME_COUNTERS {
    pub TotalRuntime100ns: UINT64,
    pub HypervisorRuntime100ns: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_RUNTIME_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_RUNTIME_COUNTERS>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_RUNTIME_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_RUNTIME_COUNTERS>())).TotalRuntime100ns as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS),
            "::",
            stringify!(TotalRuntime100ns)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_RUNTIME_COUNTERS>())).HypervisorRuntime100ns
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_RUNTIME_COUNTERS),
            "::",
            stringify!(HypervisorRuntime100ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_INTERCEPT_COUNTER {
    pub Count: UINT64,
    pub Time100ns: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_INTERCEPT_COUNTER() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_INTERCEPT_COUNTER>(),
        16usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_INTERCEPT_COUNTER>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTER>())).Count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER),
            "::",
            stringify!(Count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTER>())).Time100ns as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTER),
            "::",
            stringify!(Time100ns)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_INTERCEPT_COUNTERS {
    pub PageInvalidations: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub ControlRegisterAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub IoInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub HaltInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub CpuidInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub MsrAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub OtherIntercepts: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub PendingInterrupts: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub EmulatedInstructions: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub DebugRegisterAccesses: WHV_PROCESSOR_INTERCEPT_COUNTER,
    pub PageFaultIntercepts: WHV_PROCESSOR_INTERCEPT_COUNTER,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_INTERCEPT_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_INTERCEPT_COUNTERS>(),
        176usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_INTERCEPT_COUNTERS>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PageInvalidations
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PageInvalidations)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).ControlRegisterAccesses
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(ControlRegisterAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).IoInstructions as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(IoInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).HaltInstructions
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(HaltInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).CpuidInstructions
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(CpuidInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).MsrAccesses as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(MsrAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).OtherIntercepts as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(OtherIntercepts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PendingInterrupts
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PendingInterrupts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).EmulatedInstructions
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(EmulatedInstructions)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).DebugRegisterAccesses
                as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(DebugRegisterAccesses)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_INTERCEPT_COUNTERS>())).PageFaultIntercepts
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_INTERCEPT_COUNTERS),
            "::",
            stringify!(PageFaultIntercepts)
        )
    );
}
pub type WHV_PROCESSOR_ACTIVITY_COUNTERS = WHV_PROCESSOR_INTERCEPT_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_EVENT_COUNTERS {
    pub PageFaultCount: UINT64,
    pub ExceptionCount: UINT64,
    pub InterruptCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_EVENT_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_EVENT_COUNTERS>(),
        24usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_EVENT_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_EVENT_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_EVENT_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).PageFaultCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(PageFaultCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).ExceptionCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(ExceptionCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_EVENT_COUNTERS>())).InterruptCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_EVENT_COUNTERS),
            "::",
            stringify!(InterruptCount)
        )
    );
}
pub type WHV_PROCESSOR_GUEST_EVENT_COUNTERS = WHV_PROCESSOR_EVENT_COUNTERS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct WHV_PROCESSOR_APIC_COUNTERS {
    pub MmioAccessCount: UINT64,
    pub EoiAccessCount: UINT64,
    pub TprAccessCount: UINT64,
    pub SentIpiCount: UINT64,
    pub SelfIpiCount: UINT64,
}
#[test]
fn bindgen_test_layout_WHV_PROCESSOR_APIC_COUNTERS() {
    assert_eq!(
        ::std::mem::size_of::<WHV_PROCESSOR_APIC_COUNTERS>(),
        40usize,
        concat!("Size of: ", stringify!(WHV_PROCESSOR_APIC_COUNTERS))
    );
    assert_eq!(
        ::std::mem::align_of::<WHV_PROCESSOR_APIC_COUNTERS>(),
        8usize,
        concat!("Alignment of ", stringify!(WHV_PROCESSOR_APIC_COUNTERS))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).MmioAccessCount as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(MmioAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).EoiAccessCount as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(EoiAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).TprAccessCount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(TprAccessCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).SentIpiCount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(SentIpiCount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<WHV_PROCESSOR_APIC_COUNTERS>())).SelfIpiCount as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(WHV_PROCESSOR_APIC_COUNTERS),
            "::",
            stringify!(SelfIpiCount)
        )
    );
}
extern "C" {
    pub fn WHvGetCapability(
        CapabilityCode: WHV_CAPABILITY_CODE,
        CapabilityBuffer: *mut ::std::os::raw::c_void,
        CapabilityBufferSizeInBytes: UINT32,
        WrittenSizeInBytes: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvCreatePartition(Partition: *mut WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvSetupPartition(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvDeletePartition(Partition: WHV_PARTITION_HANDLE) -> HRESULT;
}
extern "C" {
    pub fn WHvGetPartitionProperty(
        Partition: WHV_PARTITION_HANDLE,
        PropertyCode: WHV_PARTITION_PROPERTY_CODE,
        PropertyBuffer: *mut ::std::os::raw::c_void,
        PropertyBufferSizeInBytes: UINT32,
        WrittenSizeInBytes: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetPartitionProperty(
        Partition: WHV_PARTITION_HANDLE,
        PropertyCode: WHV_PARTITION_PROPERTY_CODE,
        PropertyBuffer: *const ::std::os::raw::c_void,
        PropertyBufferSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvMapGpaRange(
        Partition: WHV_PARTITION_HANDLE,
        SourceAddress: *mut ::std::os::raw::c_void,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        SizeInBytes: UINT64,
        Flags: WHV_MAP_GPA_RANGE_FLAGS,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvUnmapGpaRange(
        Partition: WHV_PARTITION_HANDLE,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        SizeInBytes: UINT64,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvTranslateGva(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Gva: WHV_GUEST_VIRTUAL_ADDRESS,
        TranslateFlags: WHV_TRANSLATE_GVA_FLAGS,
        TranslationResult: *mut WHV_TRANSLATE_GVA_RESULT,
        Gpa: *mut WHV_GUEST_PHYSICAL_ADDRESS,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvCreateVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Flags: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvDeleteVirtualProcessor(Partition: WHV_PARTITION_HANDLE, VpIndex: UINT32) -> HRESULT;
}
extern "C" {
    pub fn WHvRunVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        ExitContext: *mut ::std::os::raw::c_void,
        ExitContextSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvCancelRunVirtualProcessor(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Flags: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorRegisters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *mut WHV_REGISTER_VALUE,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetVirtualProcessorRegisters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        RegisterNames: *const WHV_REGISTER_NAME,
        RegisterCount: UINT32,
        RegisterValues: *const WHV_REGISTER_VALUE,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorInterruptControllerState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *mut ::std::os::raw::c_void,
        StateSize: UINT32,
        WrittenSize: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetVirtualProcessorInterruptControllerState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        State: *const ::std::os::raw::c_void,
        StateSize: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvRequestInterrupt(
        Partition: WHV_PARTITION_HANDLE,
        Interrupt: *const WHV_INTERRUPT_CONTROL,
        InterruptControlSize: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorXsaveState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvSetVirtualProcessorXsaveState(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        Buffer: *const ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvQueryGpaRangeDirtyBitmap(
        Partition: WHV_PARTITION_HANDLE,
        GuestAddress: WHV_GUEST_PHYSICAL_ADDRESS,
        RangeSizeInBytes: UINT64,
        Bitmap: *mut UINT64,
        BitmapSizeInBytes: UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetPartitionCounters(
        Partition: WHV_PARTITION_HANDLE,
        CounterSet: WHV_PARTITION_COUNTER_SET,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn WHvGetVirtualProcessorCounters(
        Partition: WHV_PARTITION_HANDLE,
        VpIndex: UINT32,
        CounterSet: WHV_PROCESSOR_COUNTER_SET,
        Buffer: *mut ::std::os::raw::c_void,
        BufferSizeInBytes: UINT32,
        BytesWritten: *mut UINT32,
    ) -> HRESULT;
}
extern "C" {
    pub fn IsWHvGetCapabilityPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvCreatePartitionPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvSetupPartitionPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvDeletePartitionPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvGetPartitionPropertyPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvSetPartitionPropertyPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvMapGpaRangePresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvUnmapGpaRangePresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvTranslateGvaPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvCreateVirtualProcessorPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvDeleteVirtualProcessorPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvRunVirtualProcessorPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvCancelRunVirtualProcessorPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvGetVirtualProcessorRegistersPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvSetVirtualProcessorRegistersPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvGetVirtualProcessorInterruptControllerStatePresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvSetVirtualProcessorInterruptControllerStatePresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvRequestInterruptPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvGetVirtualProcessorXsaveStatePresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvSetVirtualProcessorXsaveStatePresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvQueryGpaRangeDirtyBitmapPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvGetPartitionCountersPresent() -> BOOLEAN;
}
extern "C" {
    pub fn IsWHvGetVirtualProcessorCountersPresent() -> BOOLEAN;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ACTIVATION_CONTEXT {
    pub _address: u8,
}
